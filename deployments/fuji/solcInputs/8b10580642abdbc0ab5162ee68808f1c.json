{
  "language": "Solidity",
  "sources": {
    "contracts/conduit/ConduitController.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.7;\r\n\r\n// prettier-ignore\r\nimport {\r\n\tConduitControllerInterface\r\n} from \"../interfaces/ConduitControllerInterface.sol\";\r\n\r\nimport { ConduitInterface } from \"../interfaces/ConduitInterface.sol\";\r\n\r\nimport { Conduit } from \"./Conduit.sol\";\r\n\r\n/**\r\n * @title ConduitController\r\n * @author 0age\r\n * @notice ConduitController enables deploying and managing new conduits, or\r\n *         contracts that allow registered callers (or open \"channels\") to\r\n *         transfer approved ERC20/721/1155 tokens on their behalf.\r\n */\r\ncontract ConduitController is ConduitControllerInterface {\r\n    // Register keys, owners, new potential owners, and channels by conduit.\r\n    mapping(address => ConduitProperties) internal _conduits;\r\n\r\n    // Set conduit creation code and runtime code hashes as immutable arguments.\r\n    bytes32 internal immutable _CONDUIT_CREATION_CODE_HASH;\r\n    bytes32 internal immutable _CONDUIT_RUNTIME_CODE_HASH;\r\n\r\n    /**\r\n     * @dev Initialize contract by deploying a conduit and setting the creation\r\n     *      code and runtime code hashes as immutable arguments.\r\n     */\r\n    constructor() {\r\n        // Derive the conduit creation code hash and set it as an immutable.\r\n        _CONDUIT_CREATION_CODE_HASH = keccak256(type(Conduit).creationCode);\r\n\r\n        // Deploy a conduit with the zero hash as the salt.\r\n        Conduit zeroConduit = new Conduit{ salt: bytes32(0) }();\r\n\r\n        // Retrieve the conduit runtime code hash and set it as an immutable.\r\n        _CONDUIT_RUNTIME_CODE_HASH = address(zeroConduit).codehash;\r\n    }\r\n\r\n    /**\r\n     * @notice Deploy a new conduit using a supplied conduit key and assigning\r\n     *         an initial owner for the deployed conduit. Note that the first\r\n     *         twenty bytes of the supplied conduit key must match the caller\r\n     *         and that a new conduit cannot be created if one has already been\r\n     *         deployed using the same conduit key.\r\n     *\r\n     * @param conduitKey   The conduit key used to deploy the conduit. Note that\r\n     *                     the first twenty bytes of the conduit key must match\r\n     *                     the caller of this contract.\r\n     * @param initialOwner The initial owner to set for the new conduit.\r\n     *\r\n     * @return conduit The address of the newly deployed conduit.\r\n     */\r\n    function createConduit(bytes32 conduitKey, address initialOwner)\r\n        external\r\n        override\r\n        returns (address conduit)\r\n    {\r\n        // Ensure that an initial owner has been supplied.\r\n        if (initialOwner == address(0)) {\r\n            revert InvalidInitialOwner();\r\n        }\r\n\r\n        // If the first 20 bytes of the conduit key do not match the caller...\r\n        if (address(uint160(bytes20(conduitKey))) != msg.sender) {\r\n            // Revert with an error indicating that the creator is invalid.\r\n            revert InvalidCreator();\r\n        }\r\n\r\n        // Derive address from deployer, conduit key and creation code hash.\r\n        conduit = address(\r\n            uint160(\r\n                uint256(\r\n                    keccak256(\r\n                        abi.encodePacked(\r\n                            bytes1(0xff),\r\n                            address(this),\r\n                            conduitKey,\r\n                            _CONDUIT_CREATION_CODE_HASH\r\n                        )\r\n                    )\r\n                )\r\n            )\r\n        );\r\n\r\n        // If derived conduit exists, as evidenced by comparing runtime code...\r\n        if (conduit.codehash == _CONDUIT_RUNTIME_CODE_HASH) {\r\n            // Revert with an error indicating that the conduit already exists.\r\n            revert ConduitAlreadyExists(conduit);\r\n        }\r\n\r\n        // Deploy the conduit via CREATE2 using the conduit key as the salt.\r\n        new Conduit{ salt: conduitKey }();\r\n\r\n        // Initialize storage variable referencing conduit properties.\r\n        ConduitProperties storage conduitProperties = _conduits[conduit];\r\n\r\n        // Set the supplied initial owner as the owner of the conduit.\r\n        conduitProperties.owner = initialOwner;\r\n\r\n        // Set conduit key used to deploy the conduit to enable reverse lookup.\r\n        conduitProperties.key = conduitKey;\r\n\r\n        // Emit an event indicating that the conduit has been deployed.\r\n        emit NewConduit(conduit, conduitKey);\r\n\r\n        // Emit an event indicating that conduit ownership has been assigned.\r\n        emit OwnershipTransferred(conduit, address(0), initialOwner);\r\n    }\r\n\r\n    /**\r\n     * @notice Open or close a channel on a given conduit, thereby allowing the\r\n     *         specified account to execute transfers against that conduit.\r\n     *         Extreme care must be taken when updating channels, as malicious\r\n     *         or vulnerable channels can transfer any ERC20, ERC721 and ERC1155\r\n     *         tokens where the token holder has granted the conduit approval.\r\n     *         Only the owner of the conduit in question may call this function.\r\n     *\r\n     * @param conduit The conduit for which to open or close the channel.\r\n     * @param channel The channel to open or close on the conduit.\r\n     * @param isOpen  A boolean indicating whether to open or close the channel.\r\n     */\r\n    function updateChannel(\r\n        address conduit,\r\n        address channel,\r\n        bool isOpen\r\n    ) external override {\r\n        // Ensure the caller is the current owner of the conduit in question.\r\n        _assertCallerIsConduitOwner(conduit);\r\n\r\n        // Call the conduit, updating the channel.\r\n        ConduitInterface(conduit).updateChannel(channel, isOpen);\r\n\r\n        // Retrieve storage region where channels for the conduit are tracked.\r\n        ConduitProperties storage conduitProperties = _conduits[conduit];\r\n\r\n        // Retrieve the index, if one currently exists, for the updated channel.\r\n        uint256 channelIndexPlusOne = (\r\n            conduitProperties.channelIndexesPlusOne[channel]\r\n        );\r\n\r\n        // Determine whether the updated channel is already tracked as open.\r\n        bool channelPreviouslyOpen = channelIndexPlusOne != 0;\r\n\r\n        // If the channel has been set to open and was previously closed...\r\n        if (isOpen && !channelPreviouslyOpen) {\r\n            // Add the channel to the channels array for the conduit.\r\n            conduitProperties.channels.push(channel);\r\n\r\n            // Add new open channel length to associated mapping as index + 1.\r\n            conduitProperties.channelIndexesPlusOne[channel] = (\r\n                conduitProperties.channels.length\r\n            );\r\n        } else if (!isOpen && channelPreviouslyOpen) {\r\n            // Set a previously open channel as closed via \"swap & pop\" method.\r\n            // Decrement located index to get the index of the closed channel.\r\n            uint256 removedChannelIndex;\r\n\r\n            // Skip underflow check as channelPreviouslyOpen being true ensures\r\n            // that channelIndexPlusOne is nonzero.\r\n            unchecked {\r\n                removedChannelIndex = channelIndexPlusOne - 1;\r\n            }\r\n\r\n            // Use length of channels array to determine index of last channel.\r\n            uint256 finalChannelIndex = conduitProperties.channels.length - 1;\r\n\r\n            // If closed channel is not last channel in the channels array...\r\n            if (finalChannelIndex != removedChannelIndex) {\r\n                // Retrieve the final channel and place the value on the stack.\r\n                address finalChannel = (\r\n                    conduitProperties.channels[finalChannelIndex]\r\n                );\r\n\r\n                // Overwrite the removed channel using the final channel value.\r\n                conduitProperties.channels[removedChannelIndex] = finalChannel;\r\n\r\n                // Update final index in associated mapping to removed index.\r\n                conduitProperties.channelIndexesPlusOne[finalChannel] = (\r\n                    channelIndexPlusOne\r\n                );\r\n            }\r\n\r\n            // Remove the last channel from the channels array for the conduit.\r\n            conduitProperties.channels.pop();\r\n\r\n            // Remove the closed channel from associated mapping of indexes.\r\n            delete conduitProperties.channelIndexesPlusOne[channel];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Initiate conduit ownership transfer by assigning a new potential\r\n     *         owner for the given conduit. Once set, the new potential owner\r\n     *         may call `acceptOwnership` to claim ownership of the conduit.\r\n     *         Only the owner of the conduit in question may call this function.\r\n     *\r\n     * @param conduit The conduit for which to initiate ownership transfer.\r\n     * @param newPotentialOwner The new potential owner of the conduit.\r\n     */\r\n    function transferOwnership(address conduit, address newPotentialOwner)\r\n        external\r\n        override\r\n    {\r\n        // Ensure the caller is the current owner of the conduit in question.\r\n        _assertCallerIsConduitOwner(conduit);\r\n\r\n        // Ensure the new potential owner is not an invalid address.\r\n        if (newPotentialOwner == address(0)) {\r\n            revert NewPotentialOwnerIsZeroAddress(conduit);\r\n        }\r\n\r\n        // Ensure the new potential owner is not already set.\r\n        if (newPotentialOwner == _conduits[conduit].potentialOwner) {\r\n            revert NewPotentialOwnerAlreadySet(conduit, newPotentialOwner);\r\n        }\r\n\r\n        // Emit an event indicating that the potential owner has been updated.\r\n        emit PotentialOwnerUpdated(newPotentialOwner);\r\n\r\n        // Set the new potential owner as the potential owner of the conduit.\r\n        _conduits[conduit].potentialOwner = newPotentialOwner;\r\n    }\r\n\r\n    /**\r\n     * @notice Clear the currently set potential owner, if any, from a conduit.\r\n     *         Only the owner of the conduit in question may call this function.\r\n     *\r\n     * @param conduit The conduit for which to cancel ownership transfer.\r\n     */\r\n    function cancelOwnershipTransfer(address conduit) external override {\r\n        // Ensure the caller is the current owner of the conduit in question.\r\n        _assertCallerIsConduitOwner(conduit);\r\n\r\n        // Ensure that ownership transfer is currently possible.\r\n        if (_conduits[conduit].potentialOwner == address(0)) {\r\n            revert NoPotentialOwnerCurrentlySet(conduit);\r\n        }\r\n\r\n        // Emit an event indicating that the potential owner has been cleared.\r\n        emit PotentialOwnerUpdated(address(0));\r\n\r\n        // Clear the current new potential owner from the conduit.\r\n        _conduits[conduit].potentialOwner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @notice Accept ownership of a supplied conduit. Only accounts that the\r\n     *         current owner has set as the new potential owner may call this\r\n     *         function.\r\n     *\r\n     * @param conduit The conduit for which to accept ownership.\r\n     */\r\n    function acceptOwnership(address conduit) external override {\r\n        // Ensure that the conduit in question exists.\r\n        _assertConduitExists(conduit);\r\n\r\n        // If caller does not match current potential owner of the conduit...\r\n        if (msg.sender != _conduits[conduit].potentialOwner) {\r\n            // Revert, indicating that caller is not current potential owner.\r\n            revert CallerIsNotNewPotentialOwner(conduit);\r\n        }\r\n\r\n        // Emit an event indicating that the potential owner has been cleared.\r\n        emit PotentialOwnerUpdated(address(0));\r\n\r\n        // Clear the current new potential owner from the conduit.\r\n        _conduits[conduit].potentialOwner = address(0);\r\n\r\n        // Emit an event indicating conduit ownership has been transferred.\r\n        emit OwnershipTransferred(\r\n            conduit,\r\n            _conduits[conduit].owner,\r\n            msg.sender\r\n        );\r\n\r\n        // Set the caller as the owner of the conduit.\r\n        _conduits[conduit].owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieve the current owner of a deployed conduit.\r\n     *\r\n     * @param conduit The conduit for which to retrieve the associated owner.\r\n     *\r\n     * @return owner The owner of the supplied conduit.\r\n     */\r\n    function ownerOf(address conduit)\r\n        external\r\n        view\r\n        override\r\n        returns (address owner)\r\n    {\r\n        // Ensure that the conduit in question exists.\r\n        _assertConduitExists(conduit);\r\n\r\n        // Retrieve the current owner of the conduit in question.\r\n        owner = _conduits[conduit].owner;\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieve the conduit key for a deployed conduit via reverse\r\n     *         lookup.\r\n     *\r\n     * @param conduit The conduit for which to retrieve the associated conduit\r\n     *                key.\r\n     *\r\n     * @return conduitKey The conduit key used to deploy the supplied conduit.\r\n     */\r\n    function getKey(address conduit)\r\n        external\r\n        view\r\n        override\r\n        returns (bytes32 conduitKey)\r\n    {\r\n        // Attempt to retrieve a conduit key for the conduit in question.\r\n        conduitKey = _conduits[conduit].key;\r\n\r\n        // Revert if no conduit key was located.\r\n        if (conduitKey == bytes32(0)) {\r\n            revert NoConduit();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Derive the conduit associated with a given conduit key and\r\n     *         determine whether that conduit exists (i.e. whether it has been\r\n     *         deployed).\r\n     *\r\n     * @param conduitKey The conduit key used to derive the conduit.\r\n     *\r\n     * @return conduit The derived address of the conduit.\r\n     * @return exists  A boolean indicating whether the derived conduit has been\r\n     *                 deployed or not.\r\n     */\r\n    function getConduit(bytes32 conduitKey)\r\n        external\r\n        view\r\n        override\r\n        returns (address conduit, bool exists)\r\n    {\r\n        // Derive address from deployer, conduit key and creation code hash.\r\n        conduit = address(\r\n            uint160(\r\n                uint256(\r\n                    keccak256(\r\n                        abi.encodePacked(\r\n                            bytes1(0xff),\r\n                            address(this),\r\n                            conduitKey,\r\n                            _CONDUIT_CREATION_CODE_HASH\r\n                        )\r\n                    )\r\n                )\r\n            )\r\n        );\r\n\r\n        // Determine whether conduit exists by retrieving its runtime code.\r\n        exists = (conduit.codehash == _CONDUIT_RUNTIME_CODE_HASH);\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieve the potential owner, if any, for a given conduit. The\r\n     *         current owner may set a new potential owner via\r\n     *         `transferOwnership` and that owner may then accept ownership of\r\n     *         the conduit in question via `acceptOwnership`.\r\n     *\r\n     * @param conduit The conduit for which to retrieve the potential owner.\r\n     *\r\n     * @return potentialOwner The potential owner, if any, for the conduit.\r\n     */\r\n    function getPotentialOwner(address conduit)\r\n        external\r\n        view\r\n        override\r\n        returns (address potentialOwner)\r\n    {\r\n        // Ensure that the conduit in question exists.\r\n        _assertConduitExists(conduit);\r\n\r\n        // Retrieve the current potential owner of the conduit in question.\r\n        potentialOwner = _conduits[conduit].potentialOwner;\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieve the status (either open or closed) of a given channel on\r\n     *         a conduit.\r\n     *\r\n     * @param conduit The conduit for which to retrieve the channel status.\r\n     * @param channel The channel for which to retrieve the status.\r\n     *\r\n     * @return isOpen The status of the channel on the given conduit.\r\n     */\r\n    function getChannelStatus(address conduit, address channel)\r\n        external\r\n        view\r\n        override\r\n        returns (bool isOpen)\r\n    {\r\n        // Ensure that the conduit in question exists.\r\n        _assertConduitExists(conduit);\r\n\r\n        // Retrieve the current channel status for the conduit in question.\r\n        isOpen = _conduits[conduit].channelIndexesPlusOne[channel] != 0;\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieve the total number of open channels for a given conduit.\r\n     *\r\n     * @param conduit The conduit for which to retrieve the total channel count.\r\n     *\r\n     * @return totalChannels The total number of open channels for the conduit.\r\n     */\r\n    function getTotalChannels(address conduit)\r\n        external\r\n        view\r\n        override\r\n        returns (uint256 totalChannels)\r\n    {\r\n        // Ensure that the conduit in question exists.\r\n        _assertConduitExists(conduit);\r\n\r\n        // Retrieve the total open channel count for the conduit in question.\r\n        totalChannels = _conduits[conduit].channels.length;\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieve an open channel at a specific index for a given conduit.\r\n     *         Note that the index of a channel can change as a result of other\r\n     *         channels being closed on the conduit.\r\n     *\r\n     * @param conduit      The conduit for which to retrieve the open channel.\r\n     * @param channelIndex The index of the channel in question.\r\n     *\r\n     * @return channel The open channel, if any, at the specified channel index.\r\n     */\r\n    function getChannel(address conduit, uint256 channelIndex)\r\n        external\r\n        view\r\n        override\r\n        returns (address channel)\r\n    {\r\n        // Ensure that the conduit in question exists.\r\n        _assertConduitExists(conduit);\r\n\r\n        // Retrieve the total open channel count for the conduit in question.\r\n        uint256 totalChannels = _conduits[conduit].channels.length;\r\n\r\n        // Ensure that the supplied index is within range.\r\n        if (channelIndex >= totalChannels) {\r\n            revert ChannelOutOfRange(conduit);\r\n        }\r\n\r\n        // Retrieve the channel at the given index.\r\n        channel = _conduits[conduit].channels[channelIndex];\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieve all open channels for a given conduit. Note that calling\r\n     *         this function for a conduit with many channels will revert with\r\n     *         an out-of-gas error.\r\n     *\r\n     * @param conduit The conduit for which to retrieve open channels.\r\n     *\r\n     * @return channels An array of open channels on the given conduit.\r\n     */\r\n    function getChannels(address conduit)\r\n        external\r\n        view\r\n        override\r\n        returns (address[] memory channels)\r\n    {\r\n        // Ensure that the conduit in question exists.\r\n        _assertConduitExists(conduit);\r\n\r\n        // Retrieve all of the open channels on the conduit in question.\r\n        channels = _conduits[conduit].channels;\r\n    }\r\n\r\n    /**\r\n     * @dev Retrieve the conduit creation code and runtime code hashes.\r\n     */\r\n    function getConduitCodeHashes()\r\n        external\r\n        view\r\n        override\r\n        returns (bytes32 creationCodeHash, bytes32 runtimeCodeHash)\r\n    {\r\n        // Retrieve the conduit creation code hash from runtime.\r\n        creationCodeHash = _CONDUIT_CREATION_CODE_HASH;\r\n\r\n        // Retrieve the conduit runtime code hash from runtime.\r\n        runtimeCodeHash = _CONDUIT_RUNTIME_CODE_HASH;\r\n    }\r\n\r\n    /**\r\n     * @dev Private view function to revert if the caller is not the owner of a\r\n     *      given conduit.\r\n     *\r\n     * @param conduit The conduit for which to assert ownership.\r\n     */\r\n    function _assertCallerIsConduitOwner(address conduit) private view {\r\n        // Ensure that the conduit in question exists.\r\n        _assertConduitExists(conduit);\r\n\r\n        // If the caller does not match the current owner of the conduit...\r\n        if (msg.sender != _conduits[conduit].owner) {\r\n            // Revert, indicating that the caller is not the owner.\r\n            revert CallerIsNotOwner(conduit);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Private view function to revert if a given conduit does not exist.\r\n     *\r\n     * @param conduit The conduit for which to assert existence.\r\n     */\r\n    function _assertConduitExists(address conduit) private view {\r\n        // Attempt to retrieve a conduit key for the conduit in question.\r\n        if (_conduits[conduit].key == bytes32(0)) {\r\n            // Revert if no conduit key was located.\r\n            revert NoConduit();\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/ConduitControllerInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.7;\r\n\r\n/**\r\n * @title ConduitControllerInterface\r\n * @author 0age\r\n * @notice ConduitControllerInterface contains all external function interfaces,\r\n *         structs, events, and errors for the conduit controller.\r\n */\r\ninterface ConduitControllerInterface {\r\n    /**\r\n     * @dev Track the conduit key, current owner, new potential owner, and open\r\n     *      channels for each deployed conduit.\r\n     */\r\n    struct ConduitProperties {\r\n        bytes32 key;\r\n        address owner;\r\n        address potentialOwner;\r\n        address[] channels;\r\n        mapping(address => uint256) channelIndexesPlusOne;\r\n    }\r\n\r\n    /**\r\n     * @dev Emit an event whenever a new conduit is created.\r\n     *\r\n     * @param conduit    The newly created conduit.\r\n     * @param conduitKey The conduit key used to create the new conduit.\r\n     */\r\n    event NewConduit(address conduit, bytes32 conduitKey);\r\n\r\n    /**\r\n     * @dev Emit an event whenever conduit ownership is transferred.\r\n     *\r\n     * @param conduit       The conduit for which ownership has been\r\n     *                      transferred.\r\n     * @param previousOwner The previous owner of the conduit.\r\n     * @param newOwner      The new owner of the conduit.\r\n     */\r\n    event OwnershipTransferred(\r\n        address indexed conduit,\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Emit an event whenever a conduit owner registers a new potential\r\n     *      owner for that conduit.\r\n     *\r\n     * @param newPotentialOwner The new potential owner of the conduit.\r\n     */\r\n    event PotentialOwnerUpdated(address indexed newPotentialOwner);\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to create a new conduit using a\r\n     *      conduit key where the first twenty bytes of the key do not match the\r\n     *      address of the caller.\r\n     */\r\n    error InvalidCreator();\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to create a new conduit when no\r\n     *      initial owner address is supplied.\r\n     */\r\n    error InvalidInitialOwner();\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to set a new potential owner\r\n     *      that is already set.\r\n     */\r\n    error NewPotentialOwnerAlreadySet(\r\n        address conduit,\r\n        address newPotentialOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to cancel ownership transfer\r\n     *      when no new potential owner is currently set.\r\n     */\r\n    error NoPotentialOwnerCurrentlySet(address conduit);\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to interact with a conduit that\r\n     *      does not yet exist.\r\n     */\r\n    error NoConduit();\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to create a conduit that\r\n     *      already exists.\r\n     */\r\n    error ConduitAlreadyExists(address conduit);\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to update channels or transfer\r\n     *      ownership of a conduit when the caller is not the owner of the\r\n     *      conduit in question.\r\n     */\r\n    error CallerIsNotOwner(address conduit);\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to register a new potential\r\n     *      owner and supplying the null address.\r\n     */\r\n    error NewPotentialOwnerIsZeroAddress(address conduit);\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to claim ownership of a conduit\r\n     *      with a caller that is not the current potential owner for the\r\n     *      conduit in question.\r\n     */\r\n    error CallerIsNotNewPotentialOwner(address conduit);\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to retrieve a channel using an\r\n     *      index that is out of range.\r\n     */\r\n    error ChannelOutOfRange(address conduit);\r\n\r\n    /**\r\n     * @notice Deploy a new conduit using a supplied conduit key and assigning\r\n     *         an initial owner for the deployed conduit. Note that the first\r\n     *         twenty bytes of the supplied conduit key must match the caller\r\n     *         and that a new conduit cannot be created if one has already been\r\n     *         deployed using the same conduit key.\r\n     *\r\n     * @param conduitKey   The conduit key used to deploy the conduit. Note that\r\n     *                     the first twenty bytes of the conduit key must match\r\n     *                     the caller of this contract.\r\n     * @param initialOwner The initial owner to set for the new conduit.\r\n     *\r\n     * @return conduit The address of the newly deployed conduit.\r\n     */\r\n    function createConduit(bytes32 conduitKey, address initialOwner)\r\n        external\r\n        returns (address conduit);\r\n\r\n    /**\r\n     * @notice Open or close a channel on a given conduit, thereby allowing the\r\n     *         specified account to execute transfers against that conduit.\r\n     *         Extreme care must be taken when updating channels, as malicious\r\n     *         or vulnerable channels can transfer any ERC20, ERC721 and ERC1155\r\n     *         tokens where the token holder has granted the conduit approval.\r\n     *         Only the owner of the conduit in question may call this function.\r\n     *\r\n     * @param conduit The conduit for which to open or close the channel.\r\n     * @param channel The channel to open or close on the conduit.\r\n     * @param isOpen  A boolean indicating whether to open or close the channel.\r\n     */\r\n    function updateChannel(\r\n        address conduit,\r\n        address channel,\r\n        bool isOpen\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Initiate conduit ownership transfer by assigning a new potential\r\n     *         owner for the given conduit. Once set, the new potential owner\r\n     *         may call `acceptOwnership` to claim ownership of the conduit.\r\n     *         Only the owner of the conduit in question may call this function.\r\n     *\r\n     * @param conduit The conduit for which to initiate ownership transfer.\r\n     * @param newPotentialOwner The new potential owner of the conduit.\r\n     */\r\n    function transferOwnership(address conduit, address newPotentialOwner)\r\n        external;\r\n\r\n    /**\r\n     * @notice Clear the currently set potential owner, if any, from a conduit.\r\n     *         Only the owner of the conduit in question may call this function.\r\n     *\r\n     * @param conduit The conduit for which to cancel ownership transfer.\r\n     */\r\n    function cancelOwnershipTransfer(address conduit) external;\r\n\r\n    /**\r\n     * @notice Accept ownership of a supplied conduit. Only accounts that the\r\n     *         current owner has set as the new potential owner may call this\r\n     *         function.\r\n     *\r\n     * @param conduit The conduit for which to accept ownership.\r\n     */\r\n    function acceptOwnership(address conduit) external;\r\n\r\n    /**\r\n     * @notice Retrieve the current owner of a deployed conduit.\r\n     *\r\n     * @param conduit The conduit for which to retrieve the associated owner.\r\n     *\r\n     * @return owner The owner of the supplied conduit.\r\n     */\r\n    function ownerOf(address conduit) external view returns (address owner);\r\n\r\n    /**\r\n     * @notice Retrieve the conduit key for a deployed conduit via reverse\r\n     *         lookup.\r\n     *\r\n     * @param conduit The conduit for which to retrieve the associated conduit\r\n     *                key.\r\n     *\r\n     * @return conduitKey The conduit key used to deploy the supplied conduit.\r\n     */\r\n    function getKey(address conduit) external view returns (bytes32 conduitKey);\r\n\r\n    /**\r\n     * @notice Derive the conduit associated with a given conduit key and\r\n     *         determine whether that conduit exists (i.e. whether it has been\r\n     *         deployed).\r\n     *\r\n     * @param conduitKey The conduit key used to derive the conduit.\r\n     *\r\n     * @return conduit The derived address of the conduit.\r\n     * @return exists  A boolean indicating whether the derived conduit has been\r\n     *                 deployed or not.\r\n     */\r\n    function getConduit(bytes32 conduitKey)\r\n        external\r\n        view\r\n        returns (address conduit, bool exists);\r\n\r\n    /**\r\n     * @notice Retrieve the potential owner, if any, for a given conduit. The\r\n     *         current owner may set a new potential owner via\r\n     *         `transferOwnership` and that owner may then accept ownership of\r\n     *         the conduit in question via `acceptOwnership`.\r\n     *\r\n     * @param conduit The conduit for which to retrieve the potential owner.\r\n     *\r\n     * @return potentialOwner The potential owner, if any, for the conduit.\r\n     */\r\n    function getPotentialOwner(address conduit)\r\n        external\r\n        view\r\n        returns (address potentialOwner);\r\n\r\n    /**\r\n     * @notice Retrieve the status (either open or closed) of a given channel on\r\n     *         a conduit.\r\n     *\r\n     * @param conduit The conduit for which to retrieve the channel status.\r\n     * @param channel The channel for which to retrieve the status.\r\n     *\r\n     * @return isOpen The status of the channel on the given conduit.\r\n     */\r\n    function getChannelStatus(address conduit, address channel)\r\n        external\r\n        view\r\n        returns (bool isOpen);\r\n\r\n    /**\r\n     * @notice Retrieve the total number of open channels for a given conduit.\r\n     *\r\n     * @param conduit The conduit for which to retrieve the total channel count.\r\n     *\r\n     * @return totalChannels The total number of open channels for the conduit.\r\n     */\r\n    function getTotalChannels(address conduit)\r\n        external\r\n        view\r\n        returns (uint256 totalChannels);\r\n\r\n    /**\r\n     * @notice Retrieve an open channel at a specific index for a given conduit.\r\n     *         Note that the index of a channel can change as a result of other\r\n     *         channels being closed on the conduit.\r\n     *\r\n     * @param conduit      The conduit for which to retrieve the open channel.\r\n     * @param channelIndex The index of the channel in question.\r\n     *\r\n     * @return channel The open channel, if any, at the specified channel index.\r\n     */\r\n    function getChannel(address conduit, uint256 channelIndex)\r\n        external\r\n        view\r\n        returns (address channel);\r\n\r\n    /**\r\n     * @notice Retrieve all open channels for a given conduit. Note that calling\r\n     *         this function for a conduit with many channels will revert with\r\n     *         an out-of-gas error.\r\n     *\r\n     * @param conduit The conduit for which to retrieve open channels.\r\n     *\r\n     * @return channels An array of open channels on the given conduit.\r\n     */\r\n    function getChannels(address conduit)\r\n        external\r\n        view\r\n        returns (address[] memory channels);\r\n\r\n    /**\r\n     * @dev Retrieve the conduit creation code and runtime code hashes.\r\n     */\r\n    function getConduitCodeHashes()\r\n        external\r\n        view\r\n        returns (bytes32 creationCodeHash, bytes32 runtimeCodeHash);\r\n}\r\n"
    },
    "contracts/interfaces/ConduitInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.7;\r\n\r\n// prettier-ignore\r\nimport {\r\n    ConduitTransfer,\r\n    ConduitBatch1155Transfer\r\n} from \"../conduit/lib/ConduitStructs.sol\";\r\n\r\n/**\r\n * @title ConduitInterface\r\n * @author 0age\r\n * @notice ConduitInterface contains all external function interfaces, events,\r\n *         and errors for conduit contracts.\r\n */\r\ninterface ConduitInterface {\r\n    /**\r\n     * @dev Revert with an error when attempting to execute transfers using a\r\n     *      caller that does not have an open channel.\r\n     */\r\n    error ChannelClosed(address channel);\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to update a channel to the\r\n     *      current status of that channel.\r\n     */\r\n    error ChannelStatusAlreadySet(address channel, bool isOpen);\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to execute a transfer for an\r\n     *      item that does not have an ERC20/721/1155 item type.\r\n     */\r\n    error InvalidItemType();\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to update the status of a\r\n     *      channel from a caller that is not the conduit controller.\r\n     */\r\n    error InvalidController();\r\n\r\n    /**\r\n     * @dev Emit an event whenever a channel is opened or closed.\r\n     *\r\n     * @param channel The channel that has been updated.\r\n     * @param open    A boolean indicating whether the conduit is open or not.\r\n     */\r\n    event ChannelUpdated(address indexed channel, bool open);\r\n\r\n    /**\r\n     * @notice Execute a sequence of ERC20/721/1155 transfers. Only a caller\r\n     *         with an open channel can call this function.\r\n     *\r\n     * @param transfers The ERC20/721/1155 transfers to perform.\r\n     *\r\n     * @return magicValue A magic value indicating that the transfers were\r\n     *                    performed successfully.\r\n     */\r\n    function execute(ConduitTransfer[] calldata transfers)\r\n        external\r\n        returns (bytes4 magicValue);\r\n\r\n    /**\r\n     * @notice Execute a sequence of batch 1155 transfers. Only a caller with an\r\n     *         open channel can call this function.\r\n     *\r\n     * @param batch1155Transfers The 1155 batch transfers to perform.\r\n     *\r\n     * @return magicValue A magic value indicating that the transfers were\r\n     *                    performed successfully.\r\n     */\r\n    function executeBatch1155(\r\n        ConduitBatch1155Transfer[] calldata batch1155Transfers\r\n    ) external returns (bytes4 magicValue);\r\n\r\n    /**\r\n     * @notice Execute a sequence of transfers, both single and batch 1155. Only\r\n     *         a caller with an open channel can call this function.\r\n     *\r\n     * @param standardTransfers  The ERC20/721/1155 transfers to perform.\r\n     * @param batch1155Transfers The 1155 batch transfers to perform.\r\n     *\r\n     * @return magicValue A magic value indicating that the transfers were\r\n     *                    performed successfully.\r\n     */\r\n    function executeWithBatch1155(\r\n        ConduitTransfer[] calldata standardTransfers,\r\n        ConduitBatch1155Transfer[] calldata batch1155Transfers\r\n    ) external returns (bytes4 magicValue);\r\n\r\n    /**\r\n     * @notice Open or close a given channel. Only callable by the controller.\r\n     *\r\n     * @param channel The channel to open or close.\r\n     * @param isOpen  The status of the channel (either open or closed).\r\n     */\r\n    function updateChannel(address channel, bool isOpen) external;\r\n}\r\n"
    },
    "contracts/conduit/Conduit.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.7;\r\n\r\nimport { ConduitInterface } from \"../interfaces/ConduitInterface.sol\";\r\n\r\nimport { ConduitItemType } from \"./lib/ConduitEnums.sol\";\r\n\r\nimport { TokenTransferrer } from \"../lib/TokenTransferrer.sol\";\r\n\r\n// prettier-ignore\r\nimport {\r\n    ConduitTransfer,\r\n    ConduitBatch1155Transfer\r\n} from \"./lib/ConduitStructs.sol\";\r\n\r\nimport \"./lib/ConduitConstants.sol\";\r\n\r\n/**\r\n * @title Conduit\r\n * @author 0age\r\n * @notice This contract serves as an originator for \"proxied\" transfers. Each\r\n *         conduit is deployed and controlled by a \"conduit controller\" that can\r\n *         add and remove \"channels\" or contracts that can instruct the conduit\r\n *         to transfer approved ERC20/721/1155 tokens. *IMPORTANT NOTE: each\r\n *         conduit has an owner that can arbitrarily add or remove channels, and\r\n *         a malicious or negligent owner can add a channel that allows for any\r\n *         approved ERC20/721/1155 tokens to be taken immediately — be extremely\r\n *         cautious with what conduits you give token approvals to!*\r\n */\r\ncontract Conduit is ConduitInterface, TokenTransferrer {\r\n    // Set deployer as an immutable controller that can update channel statuses.\r\n    address private immutable _controller;\r\n\r\n    // Track the status of each channel.\r\n    mapping(address => bool) private _channels;\r\n\r\n    /**\r\n     * @notice Ensure that the caller is currently registered as an open channel\r\n     *         on the conduit.\r\n     */\r\n    modifier onlyOpenChannel() {\r\n        // Utilize assembly to access channel storage mapping directly.\r\n        assembly {\r\n            // Write the caller to scratch space.\r\n            mstore(ChannelKey_channel_ptr, caller())\r\n\r\n            // Write the storage slot for _channels to scratch space.\r\n            mstore(ChannelKey_slot_ptr, _channels.slot)\r\n\r\n            // Derive the position in storage of _channels[msg.sender]\r\n            // and check if the stored value is zero.\r\n            if iszero(\r\n                sload(keccak256(ChannelKey_channel_ptr, ChannelKey_length))\r\n            ) {\r\n                // The caller is not an open channel; revert with\r\n                // ChannelClosed(caller). First, set error signature in memory.\r\n                mstore(ChannelClosed_error_ptr, ChannelClosed_error_signature)\r\n\r\n                // Next, set the caller as the argument.\r\n                mstore(ChannelClosed_channel_ptr, caller())\r\n\r\n                // Finally, revert, returning full custom error with argument.\r\n                revert(ChannelClosed_error_ptr, ChannelClosed_error_length)\r\n            }\r\n        }\r\n\r\n        // Continue with function execution.\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice In the constructor, set the deployer as the controller.\r\n     */\r\n    constructor() {\r\n        // Set the deployer as the controller.\r\n        _controller = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @notice Execute a sequence of ERC20/721/1155 transfers. Only a caller\r\n     *         with an open channel can call this function. Note that channels\r\n     *         are expected to implement reentrancy protection if desired, and\r\n     *         that cross-channel reentrancy may be possible if the conduit has\r\n     *         multiple open channels at once. Also note that channels are\r\n     *         expected to implement checks against transferring any zero-amount\r\n     *         items if that constraint is desired.\r\n     *\r\n     * @param transfers The ERC20/721/1155 transfers to perform.\r\n     *\r\n     * @return magicValue A magic value indicating that the transfers were\r\n     *                    performed successfully.\r\n     */\r\n    function execute(ConduitTransfer[] calldata transfers)\r\n        external\r\n        override\r\n        onlyOpenChannel\r\n        returns (bytes4 magicValue)\r\n    {\r\n        // Retrieve the total number of transfers and place on the stack.\r\n        uint256 totalStandardTransfers = transfers.length;\r\n\r\n        // Iterate over each transfer.\r\n        for (uint256 i = 0; i < totalStandardTransfers; ) {\r\n            // Retrieve the transfer in question and perform the transfer.\r\n            _transfer(transfers[i]);\r\n\r\n            // Skip overflow check as for loop is indexed starting at zero.\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n\r\n        // Return a magic value indicating that the transfers were performed.\r\n        magicValue = this.execute.selector;\r\n    }\r\n\r\n    /**\r\n     * @notice Execute a sequence of batch 1155 item transfers. Only a caller\r\n     *         with an open channel can call this function. Note that channels\r\n     *         are expected to implement reentrancy protection if desired, and\r\n     *         that cross-channel reentrancy may be possible if the conduit has\r\n     *         multiple open channels at once. Also note that channels are\r\n     *         expected to implement checks against transferring any zero-amount\r\n     *         items if that constraint is desired.\r\n     *\r\n     * @param batchTransfers The 1155 batch item transfers to perform.\r\n     *\r\n     * @return magicValue A magic value indicating that the item transfers were\r\n     *                    performed successfully.\r\n     */\r\n    function executeBatch1155(\r\n        ConduitBatch1155Transfer[] calldata batchTransfers\r\n    ) external override onlyOpenChannel returns (bytes4 magicValue) {\r\n        // Perform 1155 batch transfers. Note that memory should be considered\r\n        // entirely corrupted from this point forward.\r\n        _performERC1155BatchTransfers(batchTransfers);\r\n\r\n        // Return a magic value indicating that the transfers were performed.\r\n        magicValue = this.executeBatch1155.selector;\r\n    }\r\n\r\n    /**\r\n     * @notice Execute a sequence of transfers, both single ERC20/721/1155 item\r\n     *         transfers as well as batch 1155 item transfers. Only a caller\r\n     *         with an open channel can call this function. Note that channels\r\n     *         are expected to implement reentrancy protection if desired, and\r\n     *         that cross-channel reentrancy may be possible if the conduit has\r\n     *         multiple open channels at once. Also note that channels are\r\n     *         expected to implement checks against transferring any zero-amount\r\n     *         items if that constraint is desired.\r\n     *\r\n     * @param standardTransfers The ERC20/721/1155 item transfers to perform.\r\n     * @param batchTransfers    The 1155 batch item transfers to perform.\r\n     *\r\n     * @return magicValue A magic value indicating that the item transfers were\r\n     *                    performed successfully.\r\n     */\r\n    function executeWithBatch1155(\r\n        ConduitTransfer[] calldata standardTransfers,\r\n        ConduitBatch1155Transfer[] calldata batchTransfers\r\n    ) external override onlyOpenChannel returns (bytes4 magicValue) {\r\n        // Retrieve the total number of transfers and place on the stack.\r\n        uint256 totalStandardTransfers = standardTransfers.length;\r\n\r\n        // Iterate over each standard transfer.\r\n        for (uint256 i = 0; i < totalStandardTransfers; ) {\r\n            // Retrieve the transfer in question and perform the transfer.\r\n            _transfer(standardTransfers[i]);\r\n\r\n            // Skip overflow check as for loop is indexed starting at zero.\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n\r\n        // Perform 1155 batch transfers. Note that memory should be considered\r\n        // entirely corrupted from this point forward aside from the free memory\r\n        // pointer having the default value.\r\n        _performERC1155BatchTransfers(batchTransfers);\r\n\r\n        // Return a magic value indicating that the transfers were performed.\r\n        magicValue = this.executeWithBatch1155.selector;\r\n    }\r\n\r\n    /**\r\n     * @notice Open or close a given channel. Only callable by the controller.\r\n     *\r\n     * @param channel The channel to open or close.\r\n     * @param isOpen  The status of the channel (either open or closed).\r\n     */\r\n    function updateChannel(address channel, bool isOpen) external override {\r\n        // Ensure that the caller is the controller of this contract.\r\n        if (msg.sender != _controller) {\r\n            revert InvalidController();\r\n        }\r\n\r\n        // Ensure that the channel does not already have the indicated status.\r\n        if (_channels[channel] == isOpen) {\r\n            revert ChannelStatusAlreadySet(channel, isOpen);\r\n        }\r\n\r\n        // Update the status of the channel.\r\n        _channels[channel] = isOpen;\r\n\r\n        // Emit a corresponding event.\r\n        emit ChannelUpdated(channel, isOpen);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to transfer a given ERC20/721/1155 item. Note that\r\n     *      channels are expected to implement checks against transferring any\r\n     *      zero-amount items if that constraint is desired.\r\n     *\r\n     * @param item The ERC20/721/1155 item to transfer.\r\n     */\r\n    function _transfer(ConduitTransfer calldata item) internal {\r\n        // Determine the transfer method based on the respective item type.\r\n        if (item.itemType == ConduitItemType.ERC20) {\r\n            // Transfer ERC20 token. Note that item.identifier is ignored and\r\n            // therefore ERC20 transfer items are potentially malleable — this\r\n            // check should be performed by the calling channel if a constraint\r\n            // on item malleability is desired.\r\n            _performERC20Transfer(item.token, item.from, item.to, item.amount);\r\n        } else if (item.itemType == ConduitItemType.ERC721) {\r\n            // Ensure that exactly one 721 item is being transferred.\r\n            if (item.amount != 1) {\r\n                revert InvalidERC721TransferAmount();\r\n            }\r\n\r\n            // Transfer ERC721 token.\r\n            _performERC721Transfer(\r\n                item.token,\r\n                item.from,\r\n                item.to,\r\n                item.identifier\r\n            );\r\n        } else if (item.itemType == ConduitItemType.ERC1155) {\r\n            // Transfer ERC1155 token.\r\n            _performERC1155Transfer(\r\n                item.token,\r\n                item.from,\r\n                item.to,\r\n                item.identifier,\r\n                item.amount\r\n            );\r\n        } else {\r\n            // Throw with an error.\r\n            revert InvalidItemType();\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/conduit/lib/ConduitStructs.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.7;\r\n\r\nimport { ConduitItemType } from \"./ConduitEnums.sol\";\r\n\r\nstruct ConduitTransfer {\r\n    ConduitItemType itemType;\r\n    address token;\r\n    address from;\r\n    address to;\r\n    uint256 identifier;\r\n    uint256 amount;\r\n}\r\n\r\nstruct ConduitBatch1155Transfer {\r\n    address token;\r\n    address from;\r\n    address to;\r\n    uint256[] ids;\r\n    uint256[] amounts;\r\n}\r\n"
    },
    "contracts/conduit/lib/ConduitEnums.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.7;\r\n\r\nenum ConduitItemType {\r\n    NATIVE, // unused\r\n    ERC20,\r\n    ERC721,\r\n    ERC1155\r\n}\r\n"
    },
    "contracts/lib/TokenTransferrer.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.7;\r\n\r\nimport \"./TokenTransferrerConstants.sol\";\r\n\r\n// prettier-ignore\r\nimport {\r\n    TokenTransferrerErrors\r\n} from \"../interfaces/TokenTransferrerErrors.sol\";\r\n\r\nimport { ConduitBatch1155Transfer } from \"../conduit/lib/ConduitStructs.sol\";\r\n\r\n/**\r\n * @title TokenTransferrer\r\n * @author 0age\r\n * @custom:coauthor d1ll0n\r\n * @custom:coauthor transmissions11\r\n * @notice TokenTransferrer is a library for performing optimized ERC20, ERC721,\r\n *         ERC1155, and batch ERC1155 transfers, used by both Seaport as well as\r\n *         by conduits deployed by the ConduitController. Use great caution when\r\n *         considering these functions for use in other codebases, as there are\r\n *         significant side effects and edge cases that need to be thoroughly\r\n *         understood and carefully addressed.\r\n */\r\ncontract TokenTransferrer is TokenTransferrerErrors {\r\n    /**\r\n     * @dev Internal function to transfer ERC20 tokens from a given originator\r\n     *      to a given recipient. Sufficient approvals must be set on the\r\n     *      contract performing the transfer.\r\n     *\r\n     * @param token      The ERC20 token to transfer.\r\n     * @param from       The originator of the transfer.\r\n     * @param to         The recipient of the transfer.\r\n     * @param amount     The amount to transfer.\r\n     */\r\n    function _performERC20Transfer(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        // Utilize assembly to perform an optimized ERC20 token transfer.\r\n        assembly {\r\n            // The free memory pointer memory slot will be used when populating\r\n            // call data for the transfer; read the value and restore it later.\r\n            let memPointer := mload(FreeMemoryPointerSlot)\r\n\r\n            // Write call data into memory, starting with function selector.\r\n            mstore(ERC20_transferFrom_sig_ptr, ERC20_transferFrom_signature)\r\n            mstore(ERC20_transferFrom_from_ptr, from)\r\n            mstore(ERC20_transferFrom_to_ptr, to)\r\n            mstore(ERC20_transferFrom_amount_ptr, amount)\r\n\r\n            // Make call & copy up to 32 bytes of return data to scratch space.\r\n            // Scratch space does not need to be cleared ahead of time, as the\r\n            // subsequent check will ensure that either at least a full word of\r\n            // return data is received (in which case it will be overwritten) or\r\n            // that no data is received (in which case scratch space will be\r\n            // ignored) on a successful call to the given token.\r\n            let callStatus := call(\r\n                gas(),\r\n                token,\r\n                0,\r\n                ERC20_transferFrom_sig_ptr,\r\n                ERC20_transferFrom_length,\r\n                0,\r\n                OneWord\r\n            )\r\n\r\n            // Determine whether transfer was successful using status & result.\r\n            let success := and(\r\n                // Set success to whether the call reverted, if not check it\r\n                // either returned exactly 1 (can't just be non-zero data), or\r\n                // had no return data.\r\n                or(\r\n                    and(eq(mload(0), 1), gt(returndatasize(), 31)),\r\n                    iszero(returndatasize())\r\n                ),\r\n                callStatus\r\n            )\r\n\r\n            // Handle cases where either the transfer failed or no data was\r\n            // returned. Group these, as most transfers will succeed with data.\r\n            // Equivalent to `or(iszero(success), iszero(returndatasize()))`\r\n            // but after it's inverted for JUMPI this expression is cheaper.\r\n            if iszero(and(success, iszero(iszero(returndatasize())))) {\r\n                // If the token has no code or the transfer failed: Equivalent\r\n                // to `or(iszero(success), iszero(extcodesize(token)))` but\r\n                // after it's inverted for JUMPI this expression is cheaper.\r\n                if iszero(and(iszero(iszero(extcodesize(token))), success)) {\r\n                    // If the transfer failed:\r\n                    if iszero(success) {\r\n                        // If it was due to a revert:\r\n                        if iszero(callStatus) {\r\n                            // If it returned a message, bubble it up as long as\r\n                            // sufficient gas remains to do so:\r\n                            if returndatasize() {\r\n                                // Ensure that sufficient gas is available to\r\n                                // copy returndata while expanding memory where\r\n                                // necessary. Start by computing the word size\r\n                                // of returndata and allocated memory. Round up\r\n                                // to the nearest full word.\r\n                                let returnDataWords := div(\r\n                                    add(returndatasize(), AlmostOneWord),\r\n                                    OneWord\r\n                                )\r\n\r\n                                // Note: use the free memory pointer in place of\r\n                                // msize() to work around a Yul warning that\r\n                                // prevents accessing msize directly when the IR\r\n                                // pipeline is activated.\r\n                                let msizeWords := div(memPointer, OneWord)\r\n\r\n                                // Next, compute the cost of the returndatacopy.\r\n                                let cost := mul(CostPerWord, returnDataWords)\r\n\r\n                                // Then, compute cost of new memory allocation.\r\n                                if gt(returnDataWords, msizeWords) {\r\n                                    cost := add(\r\n                                        cost,\r\n                                        add(\r\n                                            mul(\r\n                                                sub(\r\n                                                    returnDataWords,\r\n                                                    msizeWords\r\n                                                ),\r\n                                                CostPerWord\r\n                                            ),\r\n                                            div(\r\n                                                sub(\r\n                                                    mul(\r\n                                                        returnDataWords,\r\n                                                        returnDataWords\r\n                                                    ),\r\n                                                    mul(msizeWords, msizeWords)\r\n                                                ),\r\n                                                MemoryExpansionCoefficient\r\n                                            )\r\n                                        )\r\n                                    )\r\n                                }\r\n\r\n                                // Finally, add a small constant and compare to\r\n                                // gas remaining; bubble up the revert data if\r\n                                // enough gas is still available.\r\n                                if lt(add(cost, ExtraGasBuffer), gas()) {\r\n                                    // Copy returndata to memory; overwrite\r\n                                    // existing memory.\r\n                                    returndatacopy(0, 0, returndatasize())\r\n\r\n                                    // Revert, specifying memory region with\r\n                                    // copied returndata.\r\n                                    revert(0, returndatasize())\r\n                                }\r\n                            }\r\n\r\n                            // Otherwise revert with a generic error message.\r\n                            mstore(\r\n                                TokenTransferGenericFailure_error_sig_ptr,\r\n                                TokenTransferGenericFailure_error_signature\r\n                            )\r\n                            mstore(\r\n                                TokenTransferGenericFailure_error_token_ptr,\r\n                                token\r\n                            )\r\n                            mstore(\r\n                                TokenTransferGenericFailure_error_from_ptr,\r\n                                from\r\n                            )\r\n                            mstore(TokenTransferGenericFailure_error_to_ptr, to)\r\n                            mstore(TokenTransferGenericFailure_error_id_ptr, 0)\r\n                            mstore(\r\n                                TokenTransferGenericFailure_error_amount_ptr,\r\n                                amount\r\n                            )\r\n                            revert(\r\n                                TokenTransferGenericFailure_error_sig_ptr,\r\n                                TokenTransferGenericFailure_error_length\r\n                            )\r\n                        }\r\n\r\n                        // Otherwise revert with a message about the token\r\n                        // returning false or non-compliant return values.\r\n                        mstore(\r\n                            BadReturnValueFromERC20OnTransfer_error_sig_ptr,\r\n                            BadReturnValueFromERC20OnTransfer_error_signature\r\n                        )\r\n                        mstore(\r\n                            BadReturnValueFromERC20OnTransfer_error_token_ptr,\r\n                            token\r\n                        )\r\n                        mstore(\r\n                            BadReturnValueFromERC20OnTransfer_error_from_ptr,\r\n                            from\r\n                        )\r\n                        mstore(\r\n                            BadReturnValueFromERC20OnTransfer_error_to_ptr,\r\n                            to\r\n                        )\r\n                        mstore(\r\n                            BadReturnValueFromERC20OnTransfer_error_amount_ptr,\r\n                            amount\r\n                        )\r\n                        revert(\r\n                            BadReturnValueFromERC20OnTransfer_error_sig_ptr,\r\n                            BadReturnValueFromERC20OnTransfer_error_length\r\n                        )\r\n                    }\r\n\r\n                    // Otherwise, revert with error about token not having code:\r\n                    mstore(NoContract_error_sig_ptr, NoContract_error_signature)\r\n                    mstore(NoContract_error_token_ptr, token)\r\n                    revert(NoContract_error_sig_ptr, NoContract_error_length)\r\n                }\r\n\r\n                // Otherwise, the token just returned no data despite the call\r\n                // having succeeded; no need to optimize for this as it's not\r\n                // technically ERC20 compliant.\r\n            }\r\n\r\n            // Restore the original free memory pointer.\r\n            mstore(FreeMemoryPointerSlot, memPointer)\r\n\r\n            // Restore the zero slot to zero.\r\n            mstore(ZeroSlot, 0)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to transfer an ERC721 token from a given\r\n     *      originator to a given recipient. Sufficient approvals must be set on\r\n     *      the contract performing the transfer. Note that this function does\r\n     *      not check whether the receiver can accept the ERC721 token (i.e. it\r\n     *      does not use `safeTransferFrom`).\r\n     *\r\n     * @param token      The ERC721 token to transfer.\r\n     * @param from       The originator of the transfer.\r\n     * @param to         The recipient of the transfer.\r\n     * @param identifier The tokenId to transfer.\r\n     */\r\n    function _performERC721Transfer(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 identifier\r\n    ) internal {\r\n        // Utilize assembly to perform an optimized ERC721 token transfer.\r\n        assembly {\r\n            // If the token has no code, revert.\r\n            if iszero(extcodesize(token)) {\r\n                mstore(NoContract_error_sig_ptr, NoContract_error_signature)\r\n                mstore(NoContract_error_token_ptr, token)\r\n                revert(NoContract_error_sig_ptr, NoContract_error_length)\r\n            }\r\n\r\n            // The free memory pointer memory slot will be used when populating\r\n            // call data for the transfer; read the value and restore it later.\r\n            let memPointer := mload(FreeMemoryPointerSlot)\r\n\r\n            // Write call data to memory starting with function selector.\r\n            mstore(ERC721_transferFrom_sig_ptr, ERC721_transferFrom_signature)\r\n            mstore(ERC721_transferFrom_from_ptr, from)\r\n            mstore(ERC721_transferFrom_to_ptr, to)\r\n            mstore(ERC721_transferFrom_id_ptr, identifier)\r\n\r\n            // Perform the call, ignoring return data.\r\n            let success := call(\r\n                gas(),\r\n                token,\r\n                0,\r\n                ERC721_transferFrom_sig_ptr,\r\n                ERC721_transferFrom_length,\r\n                0,\r\n                0\r\n            )\r\n\r\n            // If the transfer reverted:\r\n            if iszero(success) {\r\n                // If it returned a message, bubble it up as long as sufficient\r\n                // gas remains to do so:\r\n                if returndatasize() {\r\n                    // Ensure that sufficient gas is available to copy\r\n                    // returndata while expanding memory where necessary. Start\r\n                    // by computing word size of returndata & allocated memory.\r\n                    // Round up to the nearest full word.\r\n                    let returnDataWords := div(\r\n                        add(returndatasize(), AlmostOneWord),\r\n                        OneWord\r\n                    )\r\n\r\n                    // Note: use the free memory pointer in place of msize() to\r\n                    // work around a Yul warning that prevents accessing msize\r\n                    // directly when the IR pipeline is activated.\r\n                    let msizeWords := div(memPointer, OneWord)\r\n\r\n                    // Next, compute the cost of the returndatacopy.\r\n                    let cost := mul(CostPerWord, returnDataWords)\r\n\r\n                    // Then, compute cost of new memory allocation.\r\n                    if gt(returnDataWords, msizeWords) {\r\n                        cost := add(\r\n                            cost,\r\n                            add(\r\n                                mul(\r\n                                    sub(returnDataWords, msizeWords),\r\n                                    CostPerWord\r\n                                ),\r\n                                div(\r\n                                    sub(\r\n                                        mul(returnDataWords, returnDataWords),\r\n                                        mul(msizeWords, msizeWords)\r\n                                    ),\r\n                                    MemoryExpansionCoefficient\r\n                                )\r\n                            )\r\n                        )\r\n                    }\r\n\r\n                    // Finally, add a small constant and compare to gas\r\n                    // remaining; bubble up the revert data if enough gas is\r\n                    // still available.\r\n                    if lt(add(cost, ExtraGasBuffer), gas()) {\r\n                        // Copy returndata to memory; overwrite existing memory.\r\n                        returndatacopy(0, 0, returndatasize())\r\n\r\n                        // Revert, giving memory region with copied returndata.\r\n                        revert(0, returndatasize())\r\n                    }\r\n                }\r\n\r\n                // Otherwise revert with a generic error message.\r\n                mstore(\r\n                    TokenTransferGenericFailure_error_sig_ptr,\r\n                    TokenTransferGenericFailure_error_signature\r\n                )\r\n                mstore(TokenTransferGenericFailure_error_token_ptr, token)\r\n                mstore(TokenTransferGenericFailure_error_from_ptr, from)\r\n                mstore(TokenTransferGenericFailure_error_to_ptr, to)\r\n                mstore(TokenTransferGenericFailure_error_id_ptr, identifier)\r\n                mstore(TokenTransferGenericFailure_error_amount_ptr, 1)\r\n                revert(\r\n                    TokenTransferGenericFailure_error_sig_ptr,\r\n                    TokenTransferGenericFailure_error_length\r\n                )\r\n            }\r\n\r\n            // Restore the original free memory pointer.\r\n            mstore(FreeMemoryPointerSlot, memPointer)\r\n\r\n            // Restore the zero slot to zero.\r\n            mstore(ZeroSlot, 0)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to transfer ERC1155 tokens from a given\r\n     *      originator to a given recipient. Sufficient approvals must be set on\r\n     *      the contract performing the transfer and contract recipients must\r\n     *      implement the ERC1155TokenReceiver interface to indicate that they\r\n     *      are willing to accept the transfer.\r\n     *\r\n     * @param token      The ERC1155 token to transfer.\r\n     * @param from       The originator of the transfer.\r\n     * @param to         The recipient of the transfer.\r\n     * @param identifier The id to transfer.\r\n     * @param amount     The amount to transfer.\r\n     */\r\n    function _performERC1155Transfer(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 identifier,\r\n        uint256 amount\r\n    ) internal {\r\n        // Utilize assembly to perform an optimized ERC1155 token transfer.\r\n        assembly {\r\n            // If the token has no code, revert.\r\n            if iszero(extcodesize(token)) {\r\n                mstore(NoContract_error_sig_ptr, NoContract_error_signature)\r\n                mstore(NoContract_error_token_ptr, token)\r\n                revert(NoContract_error_sig_ptr, NoContract_error_length)\r\n            }\r\n\r\n            // The following memory slots will be used when populating call data\r\n            // for the transfer; read the values and restore them later.\r\n            let memPointer := mload(FreeMemoryPointerSlot)\r\n            let slot0x80 := mload(Slot0x80)\r\n            let slot0xA0 := mload(Slot0xA0)\r\n            let slot0xC0 := mload(Slot0xC0)\r\n\r\n            // Write call data into memory, beginning with function selector.\r\n            mstore(\r\n                ERC1155_safeTransferFrom_sig_ptr,\r\n                ERC1155_safeTransferFrom_signature\r\n            )\r\n            mstore(ERC1155_safeTransferFrom_from_ptr, from)\r\n            mstore(ERC1155_safeTransferFrom_to_ptr, to)\r\n            mstore(ERC1155_safeTransferFrom_id_ptr, identifier)\r\n            mstore(ERC1155_safeTransferFrom_amount_ptr, amount)\r\n            mstore(\r\n                ERC1155_safeTransferFrom_data_offset_ptr,\r\n                ERC1155_safeTransferFrom_data_length_offset\r\n            )\r\n            mstore(ERC1155_safeTransferFrom_data_length_ptr, 0)\r\n\r\n            // Perform the call, ignoring return data.\r\n            let success := call(\r\n                gas(),\r\n                token,\r\n                0,\r\n                ERC1155_safeTransferFrom_sig_ptr,\r\n                ERC1155_safeTransferFrom_length,\r\n                0,\r\n                0\r\n            )\r\n\r\n            // If the transfer reverted:\r\n            if iszero(success) {\r\n                // If it returned a message, bubble it up as long as sufficient\r\n                // gas remains to do so:\r\n                if returndatasize() {\r\n                    // Ensure that sufficient gas is available to copy\r\n                    // returndata while expanding memory where necessary. Start\r\n                    // by computing word size of returndata & allocated memory.\r\n                    // Round up to the nearest full word.\r\n                    let returnDataWords := div(\r\n                        add(returndatasize(), AlmostOneWord),\r\n                        OneWord\r\n                    )\r\n\r\n                    // Note: use the free memory pointer in place of msize() to\r\n                    // work around a Yul warning that prevents accessing msize\r\n                    // directly when the IR pipeline is activated.\r\n                    let msizeWords := div(memPointer, OneWord)\r\n\r\n                    // Next, compute the cost of the returndatacopy.\r\n                    let cost := mul(CostPerWord, returnDataWords)\r\n\r\n                    // Then, compute cost of new memory allocation.\r\n                    if gt(returnDataWords, msizeWords) {\r\n                        cost := add(\r\n                            cost,\r\n                            add(\r\n                                mul(\r\n                                    sub(returnDataWords, msizeWords),\r\n                                    CostPerWord\r\n                                ),\r\n                                div(\r\n                                    sub(\r\n                                        mul(returnDataWords, returnDataWords),\r\n                                        mul(msizeWords, msizeWords)\r\n                                    ),\r\n                                    MemoryExpansionCoefficient\r\n                                )\r\n                            )\r\n                        )\r\n                    }\r\n\r\n                    // Finally, add a small constant and compare to gas\r\n                    // remaining; bubble up the revert data if enough gas is\r\n                    // still available.\r\n                    if lt(add(cost, ExtraGasBuffer), gas()) {\r\n                        // Copy returndata to memory; overwrite existing memory.\r\n                        returndatacopy(0, 0, returndatasize())\r\n\r\n                        // Revert, giving memory region with copied returndata.\r\n                        revert(0, returndatasize())\r\n                    }\r\n                }\r\n\r\n                // Otherwise revert with a generic error message.\r\n                mstore(\r\n                    TokenTransferGenericFailure_error_sig_ptr,\r\n                    TokenTransferGenericFailure_error_signature\r\n                )\r\n                mstore(TokenTransferGenericFailure_error_token_ptr, token)\r\n                mstore(TokenTransferGenericFailure_error_from_ptr, from)\r\n                mstore(TokenTransferGenericFailure_error_to_ptr, to)\r\n                mstore(TokenTransferGenericFailure_error_id_ptr, identifier)\r\n                mstore(TokenTransferGenericFailure_error_amount_ptr, amount)\r\n                revert(\r\n                    TokenTransferGenericFailure_error_sig_ptr,\r\n                    TokenTransferGenericFailure_error_length\r\n                )\r\n            }\r\n\r\n            mstore(Slot0x80, slot0x80) // Restore slot 0x80.\r\n            mstore(Slot0xA0, slot0xA0) // Restore slot 0xA0.\r\n            mstore(Slot0xC0, slot0xC0) // Restore slot 0xC0.\r\n\r\n            // Restore the original free memory pointer.\r\n            mstore(FreeMemoryPointerSlot, memPointer)\r\n\r\n            // Restore the zero slot to zero.\r\n            mstore(ZeroSlot, 0)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to transfer ERC1155 tokens from a given\r\n     *      originator to a given recipient. Sufficient approvals must be set on\r\n     *      the contract performing the transfer and contract recipients must\r\n     *      implement the ERC1155TokenReceiver interface to indicate that they\r\n     *      are willing to accept the transfer. NOTE: this function is not\r\n     *      memory-safe; it will overwrite existing memory, restore the free\r\n     *      memory pointer to the default value, and overwrite the zero slot.\r\n     *      This function should only be called once memory is no longer\r\n     *      required and when uninitialized arrays are not utilized, and memory\r\n     *      should be considered fully corrupted (aside from the existence of a\r\n     *      default-value free memory pointer) after calling this function.\r\n     *\r\n     * @param batchTransfers The group of 1155 batch transfers to perform.\r\n     */\r\n    function _performERC1155BatchTransfers(\r\n        ConduitBatch1155Transfer[] calldata batchTransfers\r\n    ) internal {\r\n        // Utilize assembly to perform optimized batch 1155 transfers.\r\n        assembly {\r\n            let len := batchTransfers.length\r\n            // Pointer to first head in the array, which is offset to the struct\r\n            // at each index. This gets incremented after each loop to avoid\r\n            // multiplying by 32 to get the offset for each element.\r\n            let nextElementHeadPtr := batchTransfers.offset\r\n\r\n            // Pointer to beginning of the head of the array. This is the\r\n            // reference position each offset references. It's held static to\r\n            // let each loop calculate the data position for an element.\r\n            let arrayHeadPtr := nextElementHeadPtr\r\n\r\n            // Write the function selector, which will be reused for each call:\r\n            // safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)\r\n            mstore(\r\n                ConduitBatch1155Transfer_from_offset,\r\n                ERC1155_safeBatchTransferFrom_signature\r\n            )\r\n\r\n            // Iterate over each batch transfer.\r\n            for {\r\n                let i := 0\r\n            } lt(i, len) {\r\n                i := add(i, 1)\r\n            } {\r\n                // Read the offset to the beginning of the element and add\r\n                // it to pointer to the beginning of the array head to get\r\n                // the absolute position of the element in calldata.\r\n                let elementPtr := add(\r\n                    arrayHeadPtr,\r\n                    calldataload(nextElementHeadPtr)\r\n                )\r\n\r\n                // Retrieve the token from calldata.\r\n                let token := calldataload(elementPtr)\r\n\r\n                // If the token has no code, revert.\r\n                if iszero(extcodesize(token)) {\r\n                    mstore(NoContract_error_sig_ptr, NoContract_error_signature)\r\n                    mstore(NoContract_error_token_ptr, token)\r\n                    revert(NoContract_error_sig_ptr, NoContract_error_length)\r\n                }\r\n\r\n                // Get the total number of supplied ids.\r\n                let idsLength := calldataload(\r\n                    add(elementPtr, ConduitBatch1155Transfer_ids_length_offset)\r\n                )\r\n\r\n                // Determine the expected offset for the amounts array.\r\n                let expectedAmountsOffset := add(\r\n                    ConduitBatch1155Transfer_amounts_length_baseOffset,\r\n                    mul(idsLength, OneWord)\r\n                )\r\n\r\n                // Validate struct encoding.\r\n                let invalidEncoding := iszero(\r\n                    and(\r\n                        // ids.length == amounts.length\r\n                        eq(\r\n                            idsLength,\r\n                            calldataload(add(elementPtr, expectedAmountsOffset))\r\n                        ),\r\n                        and(\r\n                            // ids_offset == 0xa0\r\n                            eq(\r\n                                calldataload(\r\n                                    add(\r\n                                        elementPtr,\r\n                                        ConduitBatch1155Transfer_ids_head_offset\r\n                                    )\r\n                                ),\r\n                                ConduitBatch1155Transfer_ids_length_offset\r\n                            ),\r\n                            // amounts_offset == 0xc0 + ids.length*32\r\n                            eq(\r\n                                calldataload(\r\n                                    add(\r\n                                        elementPtr,\r\n                                        ConduitBatchTransfer_amounts_head_offset\r\n                                    )\r\n                                ),\r\n                                expectedAmountsOffset\r\n                            )\r\n                        )\r\n                    )\r\n                )\r\n\r\n                // Revert with an error if the encoding is not valid.\r\n                if invalidEncoding {\r\n                    mstore(\r\n                        Invalid1155BatchTransferEncoding_ptr,\r\n                        Invalid1155BatchTransferEncoding_selector\r\n                    )\r\n                    revert(\r\n                        Invalid1155BatchTransferEncoding_ptr,\r\n                        Invalid1155BatchTransferEncoding_length\r\n                    )\r\n                }\r\n\r\n                // Update the offset position for the next loop\r\n                nextElementHeadPtr := add(nextElementHeadPtr, OneWord)\r\n\r\n                // Copy the first section of calldata (before dynamic values).\r\n                calldatacopy(\r\n                    BatchTransfer1155Params_ptr,\r\n                    add(elementPtr, ConduitBatch1155Transfer_from_offset),\r\n                    ConduitBatch1155Transfer_usable_head_size\r\n                )\r\n\r\n                // Determine size of calldata required for ids and amounts. Note\r\n                // that the size includes both lengths as well as the data.\r\n                let idsAndAmountsSize := add(TwoWords, mul(idsLength, TwoWords))\r\n\r\n                // Update the offset for the data array in memory.\r\n                mstore(\r\n                    BatchTransfer1155Params_data_head_ptr,\r\n                    add(\r\n                        BatchTransfer1155Params_ids_length_offset,\r\n                        idsAndAmountsSize\r\n                    )\r\n                )\r\n\r\n                // Set the length of the data array in memory to zero.\r\n                mstore(\r\n                    add(\r\n                        BatchTransfer1155Params_data_length_basePtr,\r\n                        idsAndAmountsSize\r\n                    ),\r\n                    0\r\n                )\r\n\r\n                // Determine the total calldata size for the call to transfer.\r\n                let transferDataSize := add(\r\n                    BatchTransfer1155Params_calldata_baseSize,\r\n                    idsAndAmountsSize\r\n                )\r\n\r\n                // Copy second section of calldata (including dynamic values).\r\n                calldatacopy(\r\n                    BatchTransfer1155Params_ids_length_ptr,\r\n                    add(elementPtr, ConduitBatch1155Transfer_ids_length_offset),\r\n                    idsAndAmountsSize\r\n                )\r\n\r\n                // Perform the call to transfer 1155 tokens.\r\n                let success := call(\r\n                    gas(),\r\n                    token,\r\n                    0,\r\n                    ConduitBatch1155Transfer_from_offset, // Data portion start.\r\n                    transferDataSize, // Location of the length of callData.\r\n                    0,\r\n                    0\r\n                )\r\n\r\n                // If the transfer reverted:\r\n                if iszero(success) {\r\n                    // If it returned a message, bubble it up as long as\r\n                    // sufficient gas remains to do so:\r\n                    if returndatasize() {\r\n                        // Ensure that sufficient gas is available to copy\r\n                        // returndata while expanding memory where necessary.\r\n                        // Start by computing word size of returndata and\r\n                        // allocated memory. Round up to the nearest full word.\r\n                        let returnDataWords := div(\r\n                            add(returndatasize(), AlmostOneWord),\r\n                            OneWord\r\n                        )\r\n\r\n                        // Note: use transferDataSize in place of msize() to\r\n                        // work around a Yul warning that prevents accessing\r\n                        // msize directly when the IR pipeline is activated.\r\n                        // The free memory pointer is not used here because\r\n                        // this function does almost all memory management\r\n                        // manually and does not update it, and transferDataSize\r\n                        // should be the largest memory value used (unless a\r\n                        // previous batch was larger).\r\n                        let msizeWords := div(transferDataSize, OneWord)\r\n\r\n                        // Next, compute the cost of the returndatacopy.\r\n                        let cost := mul(CostPerWord, returnDataWords)\r\n\r\n                        // Then, compute cost of new memory allocation.\r\n                        if gt(returnDataWords, msizeWords) {\r\n                            cost := add(\r\n                                cost,\r\n                                add(\r\n                                    mul(\r\n                                        sub(returnDataWords, msizeWords),\r\n                                        CostPerWord\r\n                                    ),\r\n                                    div(\r\n                                        sub(\r\n                                            mul(\r\n                                                returnDataWords,\r\n                                                returnDataWords\r\n                                            ),\r\n                                            mul(msizeWords, msizeWords)\r\n                                        ),\r\n                                        MemoryExpansionCoefficient\r\n                                    )\r\n                                )\r\n                            )\r\n                        }\r\n\r\n                        // Finally, add a small constant and compare to gas\r\n                        // remaining; bubble up the revert data if enough gas is\r\n                        // still available.\r\n                        if lt(add(cost, ExtraGasBuffer), gas()) {\r\n                            // Copy returndata to memory; overwrite existing.\r\n                            returndatacopy(0, 0, returndatasize())\r\n\r\n                            // Revert with memory region containing returndata.\r\n                            revert(0, returndatasize())\r\n                        }\r\n                    }\r\n\r\n                    // Set the error signature.\r\n                    mstore(\r\n                        0,\r\n                        ERC1155BatchTransferGenericFailure_error_signature\r\n                    )\r\n\r\n                    // Write the token.\r\n                    mstore(ERC1155BatchTransferGenericFailure_token_ptr, token)\r\n\r\n                    // Increase the offset to ids by 32.\r\n                    mstore(\r\n                        BatchTransfer1155Params_ids_head_ptr,\r\n                        ERC1155BatchTransferGenericFailure_ids_offset\r\n                    )\r\n\r\n                    // Increase the offset to amounts by 32.\r\n                    mstore(\r\n                        BatchTransfer1155Params_amounts_head_ptr,\r\n                        add(\r\n                            OneWord,\r\n                            mload(BatchTransfer1155Params_amounts_head_ptr)\r\n                        )\r\n                    )\r\n\r\n                    // Return modified region. The total size stays the same as\r\n                    // `token` uses the same number of bytes as `data.length`.\r\n                    revert(0, transferDataSize)\r\n                }\r\n            }\r\n\r\n            // Reset the free memory pointer to the default value; memory must\r\n            // be assumed to be dirtied and not reused from this point forward.\r\n            // Also note that the zero slot is not reset to zero, meaning empty\r\n            // arrays cannot be safely created or utilized until it is restored.\r\n            mstore(FreeMemoryPointerSlot, DefaultFreeMemoryPointer)\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/conduit/lib/ConduitConstants.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.7;\r\n\r\n// error ChannelClosed(address channel)\r\nuint256 constant ChannelClosed_error_signature = (\r\n    0x93daadf200000000000000000000000000000000000000000000000000000000\r\n);\r\nuint256 constant ChannelClosed_error_ptr = 0x00;\r\nuint256 constant ChannelClosed_channel_ptr = 0x4;\r\nuint256 constant ChannelClosed_error_length = 0x24;\r\n\r\n// For the mapping:\r\n// mapping(address => bool) channels\r\n// The position in storage for a particular account is:\r\n// keccak256(abi.encode(account, channels.slot))\r\nuint256 constant ChannelKey_channel_ptr = 0x00;\r\nuint256 constant ChannelKey_slot_ptr = 0x20;\r\nuint256 constant ChannelKey_length = 0x40;\r\n"
    },
    "contracts/lib/TokenTransferrerConstants.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.7;\r\n\r\n/*\r\n * -------------------------- Disambiguation & Other Notes ---------------------\r\n *    - The term \"head\" is used as it is in the documentation for ABI encoding,\r\n *      but only in reference to dynamic types, i.e. it always refers to the\r\n *      offset or pointer to the body of a dynamic type. In calldata, the head\r\n *      is always an offset (relative to the parent object), while in memory,\r\n *      the head is always the pointer to the body. More information found here:\r\n *      https://docs.soliditylang.org/en/v0.8.14/abi-spec.html#argument-encoding\r\n *        - Note that the length of an array is separate from and precedes the\r\n *          head of the array.\r\n *\r\n *    - The term \"body\" is used in place of the term \"head\" used in the ABI\r\n *      documentation. It refers to the start of the data for a dynamic type,\r\n *      e.g. the first word of a struct or the first word of the first element\r\n *      in an array.\r\n *\r\n *    - The term \"pointer\" is used to describe the absolute position of a value\r\n *      and never an offset relative to another value.\r\n *        - The suffix \"_ptr\" refers to a memory pointer.\r\n *        - The suffix \"_cdPtr\" refers to a calldata pointer.\r\n *\r\n *    - The term \"offset\" is used to describe the position of a value relative\r\n *      to some parent value. For example, OrderParameters_conduit_offset is the\r\n *      offset to the \"conduit\" value in the OrderParameters struct relative to\r\n *      the start of the body.\r\n *        - Note: Offsets are used to derive pointers.\r\n *\r\n *    - Some structs have pointers defined for all of their fields in this file.\r\n *      Lines which are commented out are fields that are not used in the\r\n *      codebase but have been left in for readability.\r\n */\r\n\r\nuint256 constant AlmostOneWord = 0x1f;\r\nuint256 constant OneWord = 0x20;\r\nuint256 constant TwoWords = 0x40;\r\nuint256 constant ThreeWords = 0x60;\r\n\r\nuint256 constant FreeMemoryPointerSlot = 0x40;\r\nuint256 constant ZeroSlot = 0x60;\r\nuint256 constant DefaultFreeMemoryPointer = 0x80;\r\n\r\nuint256 constant Slot0x80 = 0x80;\r\nuint256 constant Slot0xA0 = 0xa0;\r\nuint256 constant Slot0xC0 = 0xc0;\r\n\r\n// abi.encodeWithSignature(\"transferFrom(address,address,uint256)\")\r\nuint256 constant ERC20_transferFrom_signature = (\r\n    0x23b872dd00000000000000000000000000000000000000000000000000000000\r\n);\r\nuint256 constant ERC20_transferFrom_sig_ptr = 0x0;\r\nuint256 constant ERC20_transferFrom_from_ptr = 0x04;\r\nuint256 constant ERC20_transferFrom_to_ptr = 0x24;\r\nuint256 constant ERC20_transferFrom_amount_ptr = 0x44;\r\nuint256 constant ERC20_transferFrom_length = 0x64; // 4 + 32 * 3 == 100\r\n\r\n// abi.encodeWithSignature(\r\n//     \"safeTransferFrom(address,address,uint256,uint256,bytes)\"\r\n// )\r\nuint256 constant ERC1155_safeTransferFrom_signature = (\r\n    0xf242432a00000000000000000000000000000000000000000000000000000000\r\n);\r\nuint256 constant ERC1155_safeTransferFrom_sig_ptr = 0x0;\r\nuint256 constant ERC1155_safeTransferFrom_from_ptr = 0x04;\r\nuint256 constant ERC1155_safeTransferFrom_to_ptr = 0x24;\r\nuint256 constant ERC1155_safeTransferFrom_id_ptr = 0x44;\r\nuint256 constant ERC1155_safeTransferFrom_amount_ptr = 0x64;\r\nuint256 constant ERC1155_safeTransferFrom_data_offset_ptr = 0x84;\r\nuint256 constant ERC1155_safeTransferFrom_data_length_ptr = 0xa4;\r\nuint256 constant ERC1155_safeTransferFrom_length = 0xc4; // 4 + 32 * 6 == 196\r\nuint256 constant ERC1155_safeTransferFrom_data_length_offset = 0xa0;\r\n\r\n// abi.encodeWithSignature(\r\n//     \"safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)\"\r\n// )\r\nuint256 constant ERC1155_safeBatchTransferFrom_signature = (\r\n    0x2eb2c2d600000000000000000000000000000000000000000000000000000000\r\n);\r\n\r\nbytes4 constant ERC1155_safeBatchTransferFrom_selector = bytes4(\r\n    bytes32(ERC1155_safeBatchTransferFrom_signature)\r\n);\r\n\r\nuint256 constant ERC721_transferFrom_signature = ERC20_transferFrom_signature;\r\nuint256 constant ERC721_transferFrom_sig_ptr = 0x0;\r\nuint256 constant ERC721_transferFrom_from_ptr = 0x04;\r\nuint256 constant ERC721_transferFrom_to_ptr = 0x24;\r\nuint256 constant ERC721_transferFrom_id_ptr = 0x44;\r\nuint256 constant ERC721_transferFrom_length = 0x64; // 4 + 32 * 3 == 100\r\n\r\n// abi.encodeWithSignature(\"NoContract(address)\")\r\nuint256 constant NoContract_error_signature = (\r\n    0x5f15d67200000000000000000000000000000000000000000000000000000000\r\n);\r\nuint256 constant NoContract_error_sig_ptr = 0x0;\r\nuint256 constant NoContract_error_token_ptr = 0x4;\r\nuint256 constant NoContract_error_length = 0x24; // 4 + 32 == 36\r\n\r\n// abi.encodeWithSignature(\r\n//     \"TokenTransferGenericFailure(address,address,address,uint256,uint256)\"\r\n// )\r\nuint256 constant TokenTransferGenericFailure_error_signature = (\r\n    0xf486bc8700000000000000000000000000000000000000000000000000000000\r\n);\r\nuint256 constant TokenTransferGenericFailure_error_sig_ptr = 0x0;\r\nuint256 constant TokenTransferGenericFailure_error_token_ptr = 0x4;\r\nuint256 constant TokenTransferGenericFailure_error_from_ptr = 0x24;\r\nuint256 constant TokenTransferGenericFailure_error_to_ptr = 0x44;\r\nuint256 constant TokenTransferGenericFailure_error_id_ptr = 0x64;\r\nuint256 constant TokenTransferGenericFailure_error_amount_ptr = 0x84;\r\n\r\n// 4 + 32 * 5 == 164\r\nuint256 constant TokenTransferGenericFailure_error_length = 0xa4;\r\n\r\n// abi.encodeWithSignature(\r\n//     \"BadReturnValueFromERC20OnTransfer(address,address,address,uint256)\"\r\n// )\r\nuint256 constant BadReturnValueFromERC20OnTransfer_error_signature = (\r\n    0x9889192300000000000000000000000000000000000000000000000000000000\r\n);\r\nuint256 constant BadReturnValueFromERC20OnTransfer_error_sig_ptr = 0x0;\r\nuint256 constant BadReturnValueFromERC20OnTransfer_error_token_ptr = 0x4;\r\nuint256 constant BadReturnValueFromERC20OnTransfer_error_from_ptr = 0x24;\r\nuint256 constant BadReturnValueFromERC20OnTransfer_error_to_ptr = 0x44;\r\nuint256 constant BadReturnValueFromERC20OnTransfer_error_amount_ptr = 0x64;\r\n\r\n// 4 + 32 * 4 == 132\r\nuint256 constant BadReturnValueFromERC20OnTransfer_error_length = 0x84;\r\n\r\nuint256 constant ExtraGasBuffer = 0x20;\r\nuint256 constant CostPerWord = 3;\r\nuint256 constant MemoryExpansionCoefficient = 0x200;\r\n\r\n// Values are offset by 32 bytes in order to write the token to the beginning\r\n// in the event of a revert\r\nuint256 constant BatchTransfer1155Params_ptr = 0x24;\r\nuint256 constant BatchTransfer1155Params_ids_head_ptr = 0x64;\r\nuint256 constant BatchTransfer1155Params_amounts_head_ptr = 0x84;\r\nuint256 constant BatchTransfer1155Params_data_head_ptr = 0xa4;\r\nuint256 constant BatchTransfer1155Params_data_length_basePtr = 0xc4;\r\nuint256 constant BatchTransfer1155Params_calldata_baseSize = 0xc4;\r\n\r\nuint256 constant BatchTransfer1155Params_ids_length_ptr = 0xc4;\r\n\r\nuint256 constant BatchTransfer1155Params_ids_length_offset = 0xa0;\r\nuint256 constant BatchTransfer1155Params_amounts_length_baseOffset = 0xc0;\r\nuint256 constant BatchTransfer1155Params_data_length_baseOffset = 0xe0;\r\n\r\nuint256 constant ConduitBatch1155Transfer_usable_head_size = 0x80;\r\n\r\nuint256 constant ConduitBatch1155Transfer_from_offset = 0x20;\r\nuint256 constant ConduitBatch1155Transfer_ids_head_offset = 0x60;\r\nuint256 constant ConduitBatch1155Transfer_amounts_head_offset = 0x80;\r\nuint256 constant ConduitBatch1155Transfer_ids_length_offset = 0xa0;\r\nuint256 constant ConduitBatch1155Transfer_amounts_length_baseOffset = 0xc0;\r\nuint256 constant ConduitBatch1155Transfer_calldata_baseSize = 0xc0;\r\n\r\n// Note: abbreviated version of above constant to adhere to line length limit.\r\nuint256 constant ConduitBatchTransfer_amounts_head_offset = 0x80;\r\n\r\nuint256 constant Invalid1155BatchTransferEncoding_ptr = 0x00;\r\nuint256 constant Invalid1155BatchTransferEncoding_length = 0x04;\r\nuint256 constant Invalid1155BatchTransferEncoding_selector = (\r\n    0xeba2084c00000000000000000000000000000000000000000000000000000000\r\n);\r\n\r\nuint256 constant ERC1155BatchTransferGenericFailure_error_signature = (\r\n    0xafc445e200000000000000000000000000000000000000000000000000000000\r\n);\r\nuint256 constant ERC1155BatchTransferGenericFailure_token_ptr = 0x04;\r\nuint256 constant ERC1155BatchTransferGenericFailure_ids_offset = 0xc0;\r\n"
    },
    "contracts/interfaces/TokenTransferrerErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.7;\r\n\r\n/**\r\n * @title TokenTransferrerErrors\r\n */\r\ninterface TokenTransferrerErrors {\r\n    /**\r\n     * @dev Revert with an error when an ERC721 transfer with amount other than\r\n     *      one is attempted.\r\n     */\r\n    error InvalidERC721TransferAmount();\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to fulfill an order where an\r\n     *      item has an amount of zero.\r\n     */\r\n    error MissingItemAmount();\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to fulfill an order where an\r\n     *      item has unused parameters. This includes both the token and the\r\n     *      identifier parameters for native transfers as well as the identifier\r\n     *      parameter for ERC20 transfers. Note that the conduit does not\r\n     *      perform this check, leaving it up to the calling channel to enforce\r\n     *      when desired.\r\n     */\r\n    error UnusedItemParameters();\r\n\r\n    /**\r\n     * @dev Revert with an error when an ERC20, ERC721, or ERC1155 token\r\n     *      transfer reverts.\r\n     *\r\n     * @param token      The token for which the transfer was attempted.\r\n     * @param from       The source of the attempted transfer.\r\n     * @param to         The recipient of the attempted transfer.\r\n     * @param identifier The identifier for the attempted transfer.\r\n     * @param amount     The amount for the attempted transfer.\r\n     */\r\n    error TokenTransferGenericFailure(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 identifier,\r\n        uint256 amount\r\n    );\r\n\r\n    /**\r\n     * @dev Revert with an error when a batch ERC1155 token transfer reverts.\r\n     *\r\n     * @param token       The token for which the transfer was attempted.\r\n     * @param from        The source of the attempted transfer.\r\n     * @param to          The recipient of the attempted transfer.\r\n     * @param identifiers The identifiers for the attempted transfer.\r\n     * @param amounts     The amounts for the attempted transfer.\r\n     */\r\n    error ERC1155BatchTransferGenericFailure(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256[] identifiers,\r\n        uint256[] amounts\r\n    );\r\n\r\n    /**\r\n     * @dev Revert with an error when an ERC20 token transfer returns a falsey\r\n     *      value.\r\n     *\r\n     * @param token      The token for which the ERC20 transfer was attempted.\r\n     * @param from       The source of the attempted ERC20 transfer.\r\n     * @param to         The recipient of the attempted ERC20 transfer.\r\n     * @param amount     The amount for the attempted ERC20 transfer.\r\n     */\r\n    error BadReturnValueFromERC20OnTransfer(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    );\r\n\r\n    /**\r\n     * @dev Revert with an error when an account being called as an assumed\r\n     *      contract does not have code and returns no data.\r\n     *\r\n     * @param account The account that should contain code.\r\n     */\r\n    error NoContract(address account);\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to execute an 1155 batch\r\n     *      transfer using calldata not produced by default ABI encoding or with\r\n     *      different lengths for ids and amounts arrays.\r\n     */\r\n    error Invalid1155BatchTransferEncoding();\r\n}\r\n"
    }
  },
  "settings": {
    "viaIR": true,
    "optimizer": {
      "enabled": true,
      "runs": 1000000
    },
    "debug": {
      "debugInfo": []
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}