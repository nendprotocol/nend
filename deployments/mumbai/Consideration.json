{
  "address": "0x799D5eCdcfe1Ee82515cD4C3304ebFa3B8C9005C",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "conduitController",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "BadContractSignature",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "BadFraction",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "BadReturnValueFromERC20OnTransfer",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint8",
          "name": "v",
          "type": "uint8"
        }
      ],
      "name": "BadSignatureV",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ConsiderationCriteriaResolverOutOfRange",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "orderIndex",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "considerationIndex",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "shortfallAmount",
          "type": "uint256"
        }
      ],
      "name": "ConsiderationNotMet",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "CriteriaNotEnabledForItem",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256[]",
          "name": "identifiers",
          "type": "uint256[]"
        },
        {
          "internalType": "uint256[]",
          "name": "amounts",
          "type": "uint256[]"
        }
      ],
      "name": "ERC1155BatchTransferGenericFailure",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "EtherTransferGenericFailure",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InexactFraction",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InsufficientEtherSupplied",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "Invalid1155BatchTransferEncoding",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidBasicOrderParameterEncoding",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "conduit",
          "type": "address"
        }
      ],
      "name": "InvalidCallToConduit",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidCanceller",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "conduitKey",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "conduit",
          "type": "address"
        }
      ],
      "name": "InvalidConduit",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidERC721TransferAmount",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidFulfillmentComponentData",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "InvalidMsgValue",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidNativeOfferItem",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidProof",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "orderHash",
          "type": "bytes32"
        }
      ],
      "name": "InvalidRestrictedOrder",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidSignature",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidSigner",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidTime",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "MismatchedFulfillmentOfferAndConsiderationComponents",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "enum Side",
          "name": "side",
          "type": "uint8"
        }
      ],
      "name": "MissingFulfillmentComponentOnAggregation",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "MissingItemAmount",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "MissingOriginalConsiderationItems",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "NoContract",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NoReentrantCalls",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NoSpecifiedOrdersAvailable",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "OfferAndConsiderationRequiredOnFulfillment",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "OfferCriteriaResolverOutOfRange",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "orderHash",
          "type": "bytes32"
        }
      ],
      "name": "OrderAlreadyFilled",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "OrderCriteriaResolverOutOfRange",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "orderHash",
          "type": "bytes32"
        }
      ],
      "name": "OrderIsCancelled",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "orderHash",
          "type": "bytes32"
        }
      ],
      "name": "OrderPartiallyFilled",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "PartialFillsNotEnabledForOrder",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "identifier",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "TokenTransferGenericFailure",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "UnresolvedConsiderationCriteria",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "UnresolvedOfferCriteria",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "UnusedItemParameters",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newCounter",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "offerer",
          "type": "address"
        }
      ],
      "name": "CounterIncremented",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "orderHash",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "offerer",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "zone",
          "type": "address"
        }
      ],
      "name": "OrderCancelled",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "orderHash",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "offerer",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "zone",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "enum ItemType",
              "name": "itemType",
              "type": "uint8"
            },
            {
              "internalType": "address",
              "name": "token",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "identifier",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            }
          ],
          "indexed": false,
          "internalType": "struct SpentItem[]",
          "name": "offer",
          "type": "tuple[]"
        },
        {
          "components": [
            {
              "internalType": "enum ItemType",
              "name": "itemType",
              "type": "uint8"
            },
            {
              "internalType": "address",
              "name": "token",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "identifier",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            },
            {
              "internalType": "address payable",
              "name": "recipient",
              "type": "address"
            }
          ],
          "indexed": false,
          "internalType": "struct ReceivedItem[]",
          "name": "consideration",
          "type": "tuple[]"
        }
      ],
      "name": "OrderFulfilled",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "orderHash",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "offerer",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "zone",
          "type": "address"
        }
      ],
      "name": "OrderValidated",
      "type": "event"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "offerer",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "zone",
              "type": "address"
            },
            {
              "components": [
                {
                  "internalType": "enum ItemType",
                  "name": "itemType",
                  "type": "uint8"
                },
                {
                  "internalType": "address",
                  "name": "token",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "identifierOrCriteria",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "startAmount",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "endAmount",
                  "type": "uint256"
                }
              ],
              "internalType": "struct OfferItem[]",
              "name": "offer",
              "type": "tuple[]"
            },
            {
              "components": [
                {
                  "internalType": "enum ItemType",
                  "name": "itemType",
                  "type": "uint8"
                },
                {
                  "internalType": "address",
                  "name": "token",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "identifierOrCriteria",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "startAmount",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "endAmount",
                  "type": "uint256"
                },
                {
                  "internalType": "address payable",
                  "name": "recipient",
                  "type": "address"
                }
              ],
              "internalType": "struct ConsiderationItem[]",
              "name": "consideration",
              "type": "tuple[]"
            },
            {
              "internalType": "enum OrderType",
              "name": "orderType",
              "type": "uint8"
            },
            {
              "internalType": "uint256",
              "name": "startTime",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "endTime",
              "type": "uint256"
            },
            {
              "internalType": "bytes32",
              "name": "zoneHash",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "salt",
              "type": "uint256"
            },
            {
              "internalType": "bytes32",
              "name": "conduitKey",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "counter",
              "type": "uint256"
            }
          ],
          "internalType": "struct OrderComponents[]",
          "name": "orders",
          "type": "tuple[]"
        }
      ],
      "name": "cancel",
      "outputs": [
        {
          "internalType": "bool",
          "name": "cancelled",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "offerer",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "zone",
                  "type": "address"
                },
                {
                  "components": [
                    {
                      "internalType": "enum ItemType",
                      "name": "itemType",
                      "type": "uint8"
                    },
                    {
                      "internalType": "address",
                      "name": "token",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256",
                      "name": "identifierOrCriteria",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "startAmount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "endAmount",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct OfferItem[]",
                  "name": "offer",
                  "type": "tuple[]"
                },
                {
                  "components": [
                    {
                      "internalType": "enum ItemType",
                      "name": "itemType",
                      "type": "uint8"
                    },
                    {
                      "internalType": "address",
                      "name": "token",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256",
                      "name": "identifierOrCriteria",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "startAmount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "endAmount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "address payable",
                      "name": "recipient",
                      "type": "address"
                    }
                  ],
                  "internalType": "struct ConsiderationItem[]",
                  "name": "consideration",
                  "type": "tuple[]"
                },
                {
                  "internalType": "enum OrderType",
                  "name": "orderType",
                  "type": "uint8"
                },
                {
                  "internalType": "uint256",
                  "name": "startTime",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "endTime",
                  "type": "uint256"
                },
                {
                  "internalType": "bytes32",
                  "name": "zoneHash",
                  "type": "bytes32"
                },
                {
                  "internalType": "uint256",
                  "name": "salt",
                  "type": "uint256"
                },
                {
                  "internalType": "bytes32",
                  "name": "conduitKey",
                  "type": "bytes32"
                },
                {
                  "internalType": "uint256",
                  "name": "totalOriginalConsiderationItems",
                  "type": "uint256"
                }
              ],
              "internalType": "struct OrderParameters",
              "name": "parameters",
              "type": "tuple"
            },
            {
              "internalType": "uint120",
              "name": "numerator",
              "type": "uint120"
            },
            {
              "internalType": "uint120",
              "name": "denominator",
              "type": "uint120"
            },
            {
              "internalType": "bytes",
              "name": "signature",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "extraData",
              "type": "bytes"
            }
          ],
          "internalType": "struct AdvancedOrder",
          "name": "advancedOrder",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "orderIndex",
              "type": "uint256"
            },
            {
              "internalType": "enum Side",
              "name": "side",
              "type": "uint8"
            },
            {
              "internalType": "uint256",
              "name": "index",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "identifier",
              "type": "uint256"
            },
            {
              "internalType": "bytes32[]",
              "name": "criteriaProof",
              "type": "bytes32[]"
            }
          ],
          "internalType": "struct CriteriaResolver[]",
          "name": "criteriaResolvers",
          "type": "tuple[]"
        },
        {
          "internalType": "bytes32",
          "name": "fulfillerConduitKey",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        }
      ],
      "name": "fulfillAdvancedOrder",
      "outputs": [
        {
          "internalType": "bool",
          "name": "fulfilled",
          "type": "bool"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "offerer",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "zone",
                  "type": "address"
                },
                {
                  "components": [
                    {
                      "internalType": "enum ItemType",
                      "name": "itemType",
                      "type": "uint8"
                    },
                    {
                      "internalType": "address",
                      "name": "token",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256",
                      "name": "identifierOrCriteria",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "startAmount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "endAmount",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct OfferItem[]",
                  "name": "offer",
                  "type": "tuple[]"
                },
                {
                  "components": [
                    {
                      "internalType": "enum ItemType",
                      "name": "itemType",
                      "type": "uint8"
                    },
                    {
                      "internalType": "address",
                      "name": "token",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256",
                      "name": "identifierOrCriteria",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "startAmount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "endAmount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "address payable",
                      "name": "recipient",
                      "type": "address"
                    }
                  ],
                  "internalType": "struct ConsiderationItem[]",
                  "name": "consideration",
                  "type": "tuple[]"
                },
                {
                  "internalType": "enum OrderType",
                  "name": "orderType",
                  "type": "uint8"
                },
                {
                  "internalType": "uint256",
                  "name": "startTime",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "endTime",
                  "type": "uint256"
                },
                {
                  "internalType": "bytes32",
                  "name": "zoneHash",
                  "type": "bytes32"
                },
                {
                  "internalType": "uint256",
                  "name": "salt",
                  "type": "uint256"
                },
                {
                  "internalType": "bytes32",
                  "name": "conduitKey",
                  "type": "bytes32"
                },
                {
                  "internalType": "uint256",
                  "name": "totalOriginalConsiderationItems",
                  "type": "uint256"
                }
              ],
              "internalType": "struct OrderParameters",
              "name": "parameters",
              "type": "tuple"
            },
            {
              "internalType": "uint120",
              "name": "numerator",
              "type": "uint120"
            },
            {
              "internalType": "uint120",
              "name": "denominator",
              "type": "uint120"
            },
            {
              "internalType": "bytes",
              "name": "signature",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "extraData",
              "type": "bytes"
            }
          ],
          "internalType": "struct AdvancedOrder[]",
          "name": "advancedOrders",
          "type": "tuple[]"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "orderIndex",
              "type": "uint256"
            },
            {
              "internalType": "enum Side",
              "name": "side",
              "type": "uint8"
            },
            {
              "internalType": "uint256",
              "name": "index",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "identifier",
              "type": "uint256"
            },
            {
              "internalType": "bytes32[]",
              "name": "criteriaProof",
              "type": "bytes32[]"
            }
          ],
          "internalType": "struct CriteriaResolver[]",
          "name": "criteriaResolvers",
          "type": "tuple[]"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "orderIndex",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "itemIndex",
              "type": "uint256"
            }
          ],
          "internalType": "struct FulfillmentComponent[][]",
          "name": "offerFulfillments",
          "type": "tuple[][]"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "orderIndex",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "itemIndex",
              "type": "uint256"
            }
          ],
          "internalType": "struct FulfillmentComponent[][]",
          "name": "considerationFulfillments",
          "type": "tuple[][]"
        },
        {
          "internalType": "bytes32",
          "name": "fulfillerConduitKey",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "maximumFulfilled",
          "type": "uint256"
        }
      ],
      "name": "fulfillAvailableAdvancedOrders",
      "outputs": [
        {
          "internalType": "bool[]",
          "name": "availableOrders",
          "type": "bool[]"
        },
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "enum ItemType",
                  "name": "itemType",
                  "type": "uint8"
                },
                {
                  "internalType": "address",
                  "name": "token",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "identifier",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "internalType": "address payable",
                  "name": "recipient",
                  "type": "address"
                }
              ],
              "internalType": "struct ReceivedItem",
              "name": "item",
              "type": "tuple"
            },
            {
              "internalType": "address",
              "name": "offerer",
              "type": "address"
            },
            {
              "internalType": "bytes32",
              "name": "conduitKey",
              "type": "bytes32"
            }
          ],
          "internalType": "struct Execution[]",
          "name": "executions",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "offerer",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "zone",
                  "type": "address"
                },
                {
                  "components": [
                    {
                      "internalType": "enum ItemType",
                      "name": "itemType",
                      "type": "uint8"
                    },
                    {
                      "internalType": "address",
                      "name": "token",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256",
                      "name": "identifierOrCriteria",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "startAmount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "endAmount",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct OfferItem[]",
                  "name": "offer",
                  "type": "tuple[]"
                },
                {
                  "components": [
                    {
                      "internalType": "enum ItemType",
                      "name": "itemType",
                      "type": "uint8"
                    },
                    {
                      "internalType": "address",
                      "name": "token",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256",
                      "name": "identifierOrCriteria",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "startAmount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "endAmount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "address payable",
                      "name": "recipient",
                      "type": "address"
                    }
                  ],
                  "internalType": "struct ConsiderationItem[]",
                  "name": "consideration",
                  "type": "tuple[]"
                },
                {
                  "internalType": "enum OrderType",
                  "name": "orderType",
                  "type": "uint8"
                },
                {
                  "internalType": "uint256",
                  "name": "startTime",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "endTime",
                  "type": "uint256"
                },
                {
                  "internalType": "bytes32",
                  "name": "zoneHash",
                  "type": "bytes32"
                },
                {
                  "internalType": "uint256",
                  "name": "salt",
                  "type": "uint256"
                },
                {
                  "internalType": "bytes32",
                  "name": "conduitKey",
                  "type": "bytes32"
                },
                {
                  "internalType": "uint256",
                  "name": "totalOriginalConsiderationItems",
                  "type": "uint256"
                }
              ],
              "internalType": "struct OrderParameters",
              "name": "parameters",
              "type": "tuple"
            },
            {
              "internalType": "bytes",
              "name": "signature",
              "type": "bytes"
            }
          ],
          "internalType": "struct Order[]",
          "name": "orders",
          "type": "tuple[]"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "orderIndex",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "itemIndex",
              "type": "uint256"
            }
          ],
          "internalType": "struct FulfillmentComponent[][]",
          "name": "offerFulfillments",
          "type": "tuple[][]"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "orderIndex",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "itemIndex",
              "type": "uint256"
            }
          ],
          "internalType": "struct FulfillmentComponent[][]",
          "name": "considerationFulfillments",
          "type": "tuple[][]"
        },
        {
          "internalType": "bytes32",
          "name": "fulfillerConduitKey",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "maximumFulfilled",
          "type": "uint256"
        }
      ],
      "name": "fulfillAvailableOrders",
      "outputs": [
        {
          "internalType": "bool[]",
          "name": "availableOrders",
          "type": "bool[]"
        },
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "enum ItemType",
                  "name": "itemType",
                  "type": "uint8"
                },
                {
                  "internalType": "address",
                  "name": "token",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "identifier",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "internalType": "address payable",
                  "name": "recipient",
                  "type": "address"
                }
              ],
              "internalType": "struct ReceivedItem",
              "name": "item",
              "type": "tuple"
            },
            {
              "internalType": "address",
              "name": "offerer",
              "type": "address"
            },
            {
              "internalType": "bytes32",
              "name": "conduitKey",
              "type": "bytes32"
            }
          ],
          "internalType": "struct Execution[]",
          "name": "executions",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "considerationToken",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "considerationIdentifier",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "considerationAmount",
              "type": "uint256"
            },
            {
              "internalType": "address payable",
              "name": "offerer",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "zone",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "offerToken",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "offerIdentifier",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "offerAmount",
              "type": "uint256"
            },
            {
              "internalType": "enum BasicOrderType",
              "name": "basicOrderType",
              "type": "uint8"
            },
            {
              "internalType": "uint256",
              "name": "startTime",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "endTime",
              "type": "uint256"
            },
            {
              "internalType": "bytes32",
              "name": "zoneHash",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "salt",
              "type": "uint256"
            },
            {
              "internalType": "bytes32",
              "name": "offererConduitKey",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "fulfillerConduitKey",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "totalOriginalAdditionalRecipients",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "internalType": "address payable",
                  "name": "recipient",
                  "type": "address"
                }
              ],
              "internalType": "struct AdditionalRecipient[]",
              "name": "additionalRecipients",
              "type": "tuple[]"
            },
            {
              "internalType": "bytes",
              "name": "signature",
              "type": "bytes"
            }
          ],
          "internalType": "struct BasicOrderParameters",
          "name": "parameters",
          "type": "tuple"
        }
      ],
      "name": "fulfillBasicOrder",
      "outputs": [
        {
          "internalType": "bool",
          "name": "fulfilled",
          "type": "bool"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "offerer",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "zone",
                  "type": "address"
                },
                {
                  "components": [
                    {
                      "internalType": "enum ItemType",
                      "name": "itemType",
                      "type": "uint8"
                    },
                    {
                      "internalType": "address",
                      "name": "token",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256",
                      "name": "identifierOrCriteria",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "startAmount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "endAmount",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct OfferItem[]",
                  "name": "offer",
                  "type": "tuple[]"
                },
                {
                  "components": [
                    {
                      "internalType": "enum ItemType",
                      "name": "itemType",
                      "type": "uint8"
                    },
                    {
                      "internalType": "address",
                      "name": "token",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256",
                      "name": "identifierOrCriteria",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "startAmount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "endAmount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "address payable",
                      "name": "recipient",
                      "type": "address"
                    }
                  ],
                  "internalType": "struct ConsiderationItem[]",
                  "name": "consideration",
                  "type": "tuple[]"
                },
                {
                  "internalType": "enum OrderType",
                  "name": "orderType",
                  "type": "uint8"
                },
                {
                  "internalType": "uint256",
                  "name": "startTime",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "endTime",
                  "type": "uint256"
                },
                {
                  "internalType": "bytes32",
                  "name": "zoneHash",
                  "type": "bytes32"
                },
                {
                  "internalType": "uint256",
                  "name": "salt",
                  "type": "uint256"
                },
                {
                  "internalType": "bytes32",
                  "name": "conduitKey",
                  "type": "bytes32"
                },
                {
                  "internalType": "uint256",
                  "name": "totalOriginalConsiderationItems",
                  "type": "uint256"
                }
              ],
              "internalType": "struct OrderParameters",
              "name": "parameters",
              "type": "tuple"
            },
            {
              "internalType": "bytes",
              "name": "signature",
              "type": "bytes"
            }
          ],
          "internalType": "struct Order",
          "name": "order",
          "type": "tuple"
        },
        {
          "internalType": "bytes32",
          "name": "fulfillerConduitKey",
          "type": "bytes32"
        }
      ],
      "name": "fulfillOrder",
      "outputs": [
        {
          "internalType": "bool",
          "name": "fulfilled",
          "type": "bool"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "offerer",
          "type": "address"
        }
      ],
      "name": "getCounter",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "counter",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "offerer",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "zone",
              "type": "address"
            },
            {
              "components": [
                {
                  "internalType": "enum ItemType",
                  "name": "itemType",
                  "type": "uint8"
                },
                {
                  "internalType": "address",
                  "name": "token",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "identifierOrCriteria",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "startAmount",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "endAmount",
                  "type": "uint256"
                }
              ],
              "internalType": "struct OfferItem[]",
              "name": "offer",
              "type": "tuple[]"
            },
            {
              "components": [
                {
                  "internalType": "enum ItemType",
                  "name": "itemType",
                  "type": "uint8"
                },
                {
                  "internalType": "address",
                  "name": "token",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "identifierOrCriteria",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "startAmount",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "endAmount",
                  "type": "uint256"
                },
                {
                  "internalType": "address payable",
                  "name": "recipient",
                  "type": "address"
                }
              ],
              "internalType": "struct ConsiderationItem[]",
              "name": "consideration",
              "type": "tuple[]"
            },
            {
              "internalType": "enum OrderType",
              "name": "orderType",
              "type": "uint8"
            },
            {
              "internalType": "uint256",
              "name": "startTime",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "endTime",
              "type": "uint256"
            },
            {
              "internalType": "bytes32",
              "name": "zoneHash",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "salt",
              "type": "uint256"
            },
            {
              "internalType": "bytes32",
              "name": "conduitKey",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "counter",
              "type": "uint256"
            }
          ],
          "internalType": "struct OrderComponents",
          "name": "order",
          "type": "tuple"
        }
      ],
      "name": "getOrderHash",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "orderHash",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "orderHash",
          "type": "bytes32"
        }
      ],
      "name": "getOrderStatus",
      "outputs": [
        {
          "internalType": "bool",
          "name": "isValidated",
          "type": "bool"
        },
        {
          "internalType": "bool",
          "name": "isCancelled",
          "type": "bool"
        },
        {
          "internalType": "uint256",
          "name": "totalFilled",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "totalSize",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "incrementCounter",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "newCounter",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "information",
      "outputs": [
        {
          "internalType": "string",
          "name": "version",
          "type": "string"
        },
        {
          "internalType": "bytes32",
          "name": "domainSeparator",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "conduitController",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "offerer",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "zone",
                  "type": "address"
                },
                {
                  "components": [
                    {
                      "internalType": "enum ItemType",
                      "name": "itemType",
                      "type": "uint8"
                    },
                    {
                      "internalType": "address",
                      "name": "token",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256",
                      "name": "identifierOrCriteria",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "startAmount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "endAmount",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct OfferItem[]",
                  "name": "offer",
                  "type": "tuple[]"
                },
                {
                  "components": [
                    {
                      "internalType": "enum ItemType",
                      "name": "itemType",
                      "type": "uint8"
                    },
                    {
                      "internalType": "address",
                      "name": "token",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256",
                      "name": "identifierOrCriteria",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "startAmount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "endAmount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "address payable",
                      "name": "recipient",
                      "type": "address"
                    }
                  ],
                  "internalType": "struct ConsiderationItem[]",
                  "name": "consideration",
                  "type": "tuple[]"
                },
                {
                  "internalType": "enum OrderType",
                  "name": "orderType",
                  "type": "uint8"
                },
                {
                  "internalType": "uint256",
                  "name": "startTime",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "endTime",
                  "type": "uint256"
                },
                {
                  "internalType": "bytes32",
                  "name": "zoneHash",
                  "type": "bytes32"
                },
                {
                  "internalType": "uint256",
                  "name": "salt",
                  "type": "uint256"
                },
                {
                  "internalType": "bytes32",
                  "name": "conduitKey",
                  "type": "bytes32"
                },
                {
                  "internalType": "uint256",
                  "name": "totalOriginalConsiderationItems",
                  "type": "uint256"
                }
              ],
              "internalType": "struct OrderParameters",
              "name": "parameters",
              "type": "tuple"
            },
            {
              "internalType": "uint120",
              "name": "numerator",
              "type": "uint120"
            },
            {
              "internalType": "uint120",
              "name": "denominator",
              "type": "uint120"
            },
            {
              "internalType": "bytes",
              "name": "signature",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "extraData",
              "type": "bytes"
            }
          ],
          "internalType": "struct AdvancedOrder[]",
          "name": "advancedOrders",
          "type": "tuple[]"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "orderIndex",
              "type": "uint256"
            },
            {
              "internalType": "enum Side",
              "name": "side",
              "type": "uint8"
            },
            {
              "internalType": "uint256",
              "name": "index",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "identifier",
              "type": "uint256"
            },
            {
              "internalType": "bytes32[]",
              "name": "criteriaProof",
              "type": "bytes32[]"
            }
          ],
          "internalType": "struct CriteriaResolver[]",
          "name": "criteriaResolvers",
          "type": "tuple[]"
        },
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "orderIndex",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "itemIndex",
                  "type": "uint256"
                }
              ],
              "internalType": "struct FulfillmentComponent[]",
              "name": "offerComponents",
              "type": "tuple[]"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "orderIndex",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "itemIndex",
                  "type": "uint256"
                }
              ],
              "internalType": "struct FulfillmentComponent[]",
              "name": "considerationComponents",
              "type": "tuple[]"
            }
          ],
          "internalType": "struct Fulfillment[]",
          "name": "fulfillments",
          "type": "tuple[]"
        }
      ],
      "name": "matchAdvancedOrders",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "enum ItemType",
                  "name": "itemType",
                  "type": "uint8"
                },
                {
                  "internalType": "address",
                  "name": "token",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "identifier",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "internalType": "address payable",
                  "name": "recipient",
                  "type": "address"
                }
              ],
              "internalType": "struct ReceivedItem",
              "name": "item",
              "type": "tuple"
            },
            {
              "internalType": "address",
              "name": "offerer",
              "type": "address"
            },
            {
              "internalType": "bytes32",
              "name": "conduitKey",
              "type": "bytes32"
            }
          ],
          "internalType": "struct Execution[]",
          "name": "executions",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "offerer",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "zone",
                  "type": "address"
                },
                {
                  "components": [
                    {
                      "internalType": "enum ItemType",
                      "name": "itemType",
                      "type": "uint8"
                    },
                    {
                      "internalType": "address",
                      "name": "token",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256",
                      "name": "identifierOrCriteria",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "startAmount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "endAmount",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct OfferItem[]",
                  "name": "offer",
                  "type": "tuple[]"
                },
                {
                  "components": [
                    {
                      "internalType": "enum ItemType",
                      "name": "itemType",
                      "type": "uint8"
                    },
                    {
                      "internalType": "address",
                      "name": "token",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256",
                      "name": "identifierOrCriteria",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "startAmount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "endAmount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "address payable",
                      "name": "recipient",
                      "type": "address"
                    }
                  ],
                  "internalType": "struct ConsiderationItem[]",
                  "name": "consideration",
                  "type": "tuple[]"
                },
                {
                  "internalType": "enum OrderType",
                  "name": "orderType",
                  "type": "uint8"
                },
                {
                  "internalType": "uint256",
                  "name": "startTime",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "endTime",
                  "type": "uint256"
                },
                {
                  "internalType": "bytes32",
                  "name": "zoneHash",
                  "type": "bytes32"
                },
                {
                  "internalType": "uint256",
                  "name": "salt",
                  "type": "uint256"
                },
                {
                  "internalType": "bytes32",
                  "name": "conduitKey",
                  "type": "bytes32"
                },
                {
                  "internalType": "uint256",
                  "name": "totalOriginalConsiderationItems",
                  "type": "uint256"
                }
              ],
              "internalType": "struct OrderParameters",
              "name": "parameters",
              "type": "tuple"
            },
            {
              "internalType": "bytes",
              "name": "signature",
              "type": "bytes"
            }
          ],
          "internalType": "struct Order[]",
          "name": "orders",
          "type": "tuple[]"
        },
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "orderIndex",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "itemIndex",
                  "type": "uint256"
                }
              ],
              "internalType": "struct FulfillmentComponent[]",
              "name": "offerComponents",
              "type": "tuple[]"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "orderIndex",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "itemIndex",
                  "type": "uint256"
                }
              ],
              "internalType": "struct FulfillmentComponent[]",
              "name": "considerationComponents",
              "type": "tuple[]"
            }
          ],
          "internalType": "struct Fulfillment[]",
          "name": "fulfillments",
          "type": "tuple[]"
        }
      ],
      "name": "matchOrders",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "enum ItemType",
                  "name": "itemType",
                  "type": "uint8"
                },
                {
                  "internalType": "address",
                  "name": "token",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "identifier",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "internalType": "address payable",
                  "name": "recipient",
                  "type": "address"
                }
              ],
              "internalType": "struct ReceivedItem",
              "name": "item",
              "type": "tuple"
            },
            {
              "internalType": "address",
              "name": "offerer",
              "type": "address"
            },
            {
              "internalType": "bytes32",
              "name": "conduitKey",
              "type": "bytes32"
            }
          ],
          "internalType": "struct Execution[]",
          "name": "executions",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "name",
      "outputs": [
        {
          "internalType": "string",
          "name": "contractName",
          "type": "string"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "offerer",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "zone",
                  "type": "address"
                },
                {
                  "components": [
                    {
                      "internalType": "enum ItemType",
                      "name": "itemType",
                      "type": "uint8"
                    },
                    {
                      "internalType": "address",
                      "name": "token",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256",
                      "name": "identifierOrCriteria",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "startAmount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "endAmount",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct OfferItem[]",
                  "name": "offer",
                  "type": "tuple[]"
                },
                {
                  "components": [
                    {
                      "internalType": "enum ItemType",
                      "name": "itemType",
                      "type": "uint8"
                    },
                    {
                      "internalType": "address",
                      "name": "token",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256",
                      "name": "identifierOrCriteria",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "startAmount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "endAmount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "address payable",
                      "name": "recipient",
                      "type": "address"
                    }
                  ],
                  "internalType": "struct ConsiderationItem[]",
                  "name": "consideration",
                  "type": "tuple[]"
                },
                {
                  "internalType": "enum OrderType",
                  "name": "orderType",
                  "type": "uint8"
                },
                {
                  "internalType": "uint256",
                  "name": "startTime",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "endTime",
                  "type": "uint256"
                },
                {
                  "internalType": "bytes32",
                  "name": "zoneHash",
                  "type": "bytes32"
                },
                {
                  "internalType": "uint256",
                  "name": "salt",
                  "type": "uint256"
                },
                {
                  "internalType": "bytes32",
                  "name": "conduitKey",
                  "type": "bytes32"
                },
                {
                  "internalType": "uint256",
                  "name": "totalOriginalConsiderationItems",
                  "type": "uint256"
                }
              ],
              "internalType": "struct OrderParameters",
              "name": "parameters",
              "type": "tuple"
            },
            {
              "internalType": "bytes",
              "name": "signature",
              "type": "bytes"
            }
          ],
          "internalType": "struct Order[]",
          "name": "orders",
          "type": "tuple[]"
        }
      ],
      "name": "validate",
      "outputs": [
        {
          "internalType": "bool",
          "name": "validated",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xeebdcbc0b5324f5b2eb247e681c2334714acd896e26ac4b17948360a12fab691",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0x4a580D71c0F73202C51C58147aA7c7E09245b10A",
    "contractAddress": null,
    "transactionIndex": 1,
    "gasUsed": "4760166",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000008000000000000000000000000000000000800000000000000000000100000000000000000000000000000000000000000000200000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000020000080000000000020000000000000000000000000000004000000000000000000001000000000100000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000100000",
    "blockHash": "0x6986b0d1e9f68388a3b3d688c140a949a4b7293a6dc2335bc721194770f65e33",
    "transactionHash": "0xeebdcbc0b5324f5b2eb247e681c2334714acd896e26ac4b17948360a12fab691",
    "logs": [
      {
        "transactionIndex": 1,
        "blockNumber": 29586811,
        "transactionHash": "0xeebdcbc0b5324f5b2eb247e681c2334714acd896e26ac4b17948360a12fab691",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x0000000000000000000000004a580d71c0f73202c51c58147aa7c7e09245b10a",
          "0x0000000000000000000000003a22c8bc68e98b0faf40f349dd2b2890fae01484"
        ],
        "data": "0x000000000000000000000000000000000000000000000000003b30b5cc8a5466000000000000000000000000000000000000000000000000d3529189b47986e60000000000000000000000000000000000000000000000b29187a2d6687e1ff3000000000000000000000000000000000000000000000000d31760d3e7ef32800000000000000000000000000000000000000000000000b291c2d38c35087459",
        "logIndex": 13,
        "blockHash": "0x6986b0d1e9f68388a3b3d688c140a949a4b7293a6dc2335bc721194770f65e33"
      }
    ],
    "blockNumber": 29586811,
    "cumulativeGasUsed": "5080354",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x84C209E1466C119295BcE52BCDD3df20faD4fe61"
  ],
  "numDeployments": 1,
  "solcInputHash": "a98b85679c117a20c3b99df23d476f7d",
  "metadata": "{\"compiler\":{\"version\":\"0.8.14+commit.80d49f37\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"conduitController\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"BadContractSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BadFraction\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BadReturnValueFromERC20OnTransfer\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"name\":\"BadSignatureV\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ConsiderationCriteriaResolverOutOfRange\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"considerationIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shortfallAmount\",\"type\":\"uint256\"}],\"name\":\"ConsiderationNotMet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CriteriaNotEnabledForItem\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"identifiers\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"ERC1155BatchTransferGenericFailure\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EtherTransferGenericFailure\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InexactFraction\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientEtherSupplied\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Invalid1155BatchTransferEncoding\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidBasicOrderParameterEncoding\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"conduit\",\"type\":\"address\"}],\"name\":\"InvalidCallToConduit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidCanceller\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"conduit\",\"type\":\"address\"}],\"name\":\"InvalidConduit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidERC721TransferAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidFulfillmentComponentData\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"InvalidMsgValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidNativeOfferItem\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidProof\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"InvalidRestrictedOrder\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSigner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTime\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MismatchedFulfillmentOfferAndConsiderationComponents\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"enum Side\",\"name\":\"side\",\"type\":\"uint8\"}],\"name\":\"MissingFulfillmentComponentOnAggregation\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MissingItemAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MissingOriginalConsiderationItems\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"NoContract\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoReentrantCalls\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoSpecifiedOrdersAvailable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OfferAndConsiderationRequiredOnFulfillment\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OfferCriteriaResolverOutOfRange\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"OrderAlreadyFilled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OrderCriteriaResolverOutOfRange\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"OrderIsCancelled\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"OrderPartiallyFilled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PartialFillsNotEnabledForOrder\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenTransferGenericFailure\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnresolvedConsiderationCriteria\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnresolvedOfferCriteria\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnusedItemParameters\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCounter\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"}],\"name\":\"CounterIncremented\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"}],\"name\":\"OrderCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct SpentItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"indexed\":false,\"internalType\":\"struct ReceivedItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"}],\"name\":\"OrderFulfilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"}],\"name\":\"OrderValidated\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"counter\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderComponents[]\",\"name\":\"orders\",\"type\":\"tuple[]\"}],\"name\":\"cancel\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"cancelled\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalConsiderationItems\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderParameters\",\"name\":\"parameters\",\"type\":\"tuple\"},{\"internalType\":\"uint120\",\"name\":\"numerator\",\"type\":\"uint120\"},{\"internalType\":\"uint120\",\"name\":\"denominator\",\"type\":\"uint120\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct AdvancedOrder\",\"name\":\"advancedOrder\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"enum Side\",\"name\":\"side\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"criteriaProof\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct CriteriaResolver[]\",\"name\":\"criteriaResolvers\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes32\",\"name\":\"fulfillerConduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"fulfillAdvancedOrder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"fulfilled\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalConsiderationItems\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderParameters\",\"name\":\"parameters\",\"type\":\"tuple\"},{\"internalType\":\"uint120\",\"name\":\"numerator\",\"type\":\"uint120\"},{\"internalType\":\"uint120\",\"name\":\"denominator\",\"type\":\"uint120\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct AdvancedOrder[]\",\"name\":\"advancedOrders\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"enum Side\",\"name\":\"side\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"criteriaProof\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct CriteriaResolver[]\",\"name\":\"criteriaResolvers\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct FulfillmentComponent[][]\",\"name\":\"offerFulfillments\",\"type\":\"tuple[][]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct FulfillmentComponent[][]\",\"name\":\"considerationFulfillments\",\"type\":\"tuple[][]\"},{\"internalType\":\"bytes32\",\"name\":\"fulfillerConduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maximumFulfilled\",\"type\":\"uint256\"}],\"name\":\"fulfillAvailableAdvancedOrders\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"availableOrders\",\"type\":\"bool[]\"},{\"components\":[{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ReceivedItem\",\"name\":\"item\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"}],\"internalType\":\"struct Execution[]\",\"name\":\"executions\",\"type\":\"tuple[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalConsiderationItems\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderParameters\",\"name\":\"parameters\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct Order[]\",\"name\":\"orders\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct FulfillmentComponent[][]\",\"name\":\"offerFulfillments\",\"type\":\"tuple[][]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct FulfillmentComponent[][]\",\"name\":\"considerationFulfillments\",\"type\":\"tuple[][]\"},{\"internalType\":\"bytes32\",\"name\":\"fulfillerConduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"maximumFulfilled\",\"type\":\"uint256\"}],\"name\":\"fulfillAvailableOrders\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"availableOrders\",\"type\":\"bool[]\"},{\"components\":[{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ReceivedItem\",\"name\":\"item\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"}],\"internalType\":\"struct Execution[]\",\"name\":\"executions\",\"type\":\"tuple[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"considerationToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"considerationIdentifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"considerationAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"offerToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"offerIdentifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offerAmount\",\"type\":\"uint256\"},{\"internalType\":\"enum BasicOrderType\",\"name\":\"basicOrderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"offererConduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"fulfillerConduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalAdditionalRecipients\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct AdditionalRecipient[]\",\"name\":\"additionalRecipients\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct BasicOrderParameters\",\"name\":\"parameters\",\"type\":\"tuple\"}],\"name\":\"fulfillBasicOrder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"fulfilled\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalConsiderationItems\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderParameters\",\"name\":\"parameters\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct Order\",\"name\":\"order\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"fulfillerConduitKey\",\"type\":\"bytes32\"}],\"name\":\"fulfillOrder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"fulfilled\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"}],\"name\":\"getCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"counter\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"counter\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderComponents\",\"name\":\"order\",\"type\":\"tuple\"}],\"name\":\"getOrderHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"getOrderStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isValidated\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isCancelled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"totalFilled\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSize\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"incrementCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"newCounter\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"information\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"domainSeparator\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"conduitController\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalConsiderationItems\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderParameters\",\"name\":\"parameters\",\"type\":\"tuple\"},{\"internalType\":\"uint120\",\"name\":\"numerator\",\"type\":\"uint120\"},{\"internalType\":\"uint120\",\"name\":\"denominator\",\"type\":\"uint120\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct AdvancedOrder[]\",\"name\":\"advancedOrders\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"enum Side\",\"name\":\"side\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"criteriaProof\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct CriteriaResolver[]\",\"name\":\"criteriaResolvers\",\"type\":\"tuple[]\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct FulfillmentComponent[]\",\"name\":\"offerComponents\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct FulfillmentComponent[]\",\"name\":\"considerationComponents\",\"type\":\"tuple[]\"}],\"internalType\":\"struct Fulfillment[]\",\"name\":\"fulfillments\",\"type\":\"tuple[]\"}],\"name\":\"matchAdvancedOrders\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ReceivedItem\",\"name\":\"item\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"}],\"internalType\":\"struct Execution[]\",\"name\":\"executions\",\"type\":\"tuple[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalConsiderationItems\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderParameters\",\"name\":\"parameters\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct Order[]\",\"name\":\"orders\",\"type\":\"tuple[]\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct FulfillmentComponent[]\",\"name\":\"offerComponents\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct FulfillmentComponent[]\",\"name\":\"considerationComponents\",\"type\":\"tuple[]\"}],\"internalType\":\"struct Fulfillment[]\",\"name\":\"fulfillments\",\"type\":\"tuple[]\"}],\"name\":\"matchOrders\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ReceivedItem\",\"name\":\"item\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"}],\"internalType\":\"struct Execution[]\",\"name\":\"executions\",\"type\":\"tuple[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"contractName\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalConsiderationItems\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderParameters\",\"name\":\"parameters\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct Order[]\",\"name\":\"orders\",\"type\":\"tuple[]\"}],\"name\":\"validate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"validated\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"0age\",\"custom:coauthor\":\"d1ll0ntransmissions11\",\"custom:version\":\"1.1\",\"errors\":{\"BadContractSignature()\":[{\"details\":\"Revert with an error when an EIP-1271 call to an account fails.\"}],\"BadFraction()\":[{\"details\":\"Revert with an error when supplying a fraction with a value of zero      for the numerator or denominator, or one where the numerator exceeds      the denominator.\"}],\"BadReturnValueFromERC20OnTransfer(address,address,address,uint256)\":[{\"details\":\"Revert with an error when an ERC20 token transfer returns a falsey      value.\",\"params\":{\"amount\":\"The amount for the attempted ERC20 transfer.\",\"from\":\"The source of the attempted ERC20 transfer.\",\"to\":\"The recipient of the attempted ERC20 transfer.\",\"token\":\"The token for which the ERC20 transfer was attempted.\"}}],\"BadSignatureV(uint8)\":[{\"details\":\"Revert with an error when a signature that does not contain a v      value of 27 or 28 has been supplied.\",\"params\":{\"v\":\"The invalid v value.\"}}],\"ConsiderationCriteriaResolverOutOfRange()\":[{\"details\":\"Revert with an error when providing a criteria resolver that refers      to an order with a consideration item that has not been supplied.\"}],\"ConsiderationNotMet(uint256,uint256,uint256)\":[{\"details\":\"Revert with an error if a consideration amount has not been fully      zeroed out after applying all fulfillments.\",\"params\":{\"considerationIndex\":\"The index of the consideration item on the                           order.\",\"orderIndex\":\"The index of the order with the consideration                           item with a shortfall.\",\"shortfallAmount\":\"The unfulfilled consideration amount.\"}}],\"CriteriaNotEnabledForItem()\":[{\"details\":\"Revert with an error when providing a criteria resolver that refers      to an order with an item that does not expect a criteria to be      resolved.\"}],\"ERC1155BatchTransferGenericFailure(address,address,address,uint256[],uint256[])\":[{\"details\":\"Revert with an error when a batch ERC1155 token transfer reverts.\",\"params\":{\"amounts\":\"The amounts for the attempted transfer.\",\"from\":\"The source of the attempted transfer.\",\"identifiers\":\"The identifiers for the attempted transfer.\",\"to\":\"The recipient of the attempted transfer.\",\"token\":\"The token for which the transfer was attempted.\"}}],\"EtherTransferGenericFailure(address,uint256)\":[{\"details\":\"Revert with an error when an ether transfer reverts.\"}],\"InexactFraction()\":[{\"details\":\"Revert with an error when attempting to apply a fraction as part of      a partial fill that does not divide the target amount cleanly.\"}],\"InsufficientEtherSupplied()\":[{\"details\":\"Revert with an error when insufficient ether is supplied as part of      msg.value when fulfilling orders.\"}],\"Invalid1155BatchTransferEncoding()\":[{\"details\":\"Revert with an error when attempting to execute an 1155 batch      transfer using calldata not produced by default ABI encoding or with      different lengths for ids and amounts arrays.\"}],\"InvalidBasicOrderParameterEncoding()\":[{\"details\":\"Revert with an error when attempting to fill a basic order using      calldata not produced by default ABI encoding.\"}],\"InvalidCallToConduit(address)\":[{\"details\":\"Revert with an error when a call to a conduit fails with revert data      that is too expensive to return.\"}],\"InvalidCanceller()\":[{\"details\":\"Revert with an error when attempting to cancel an order as a caller      other than the indicated offerer or zone.\"}],\"InvalidConduit(bytes32,address)\":[{\"details\":\"Revert with an error when attempting to fill an order referencing an      invalid conduit (i.e. one that has not been deployed).\"}],\"InvalidERC721TransferAmount()\":[{\"details\":\"Revert with an error when an ERC721 transfer with amount other than      one is attempted.\"}],\"InvalidFulfillmentComponentData()\":[{\"details\":\"Revert with an error when an order or item index are out of range      or a fulfillment component does not match the type, token,      identifier, or conduit preference of the initial consideration item.\"}],\"InvalidMsgValue(uint256)\":[{\"details\":\"Revert with an error when a caller attempts to supply callvalue to a      non-payable basic order route or does not supply any callvalue to a      payable basic order route.\"}],\"InvalidNativeOfferItem()\":[{\"details\":\"Revert with an error when attempting to fulfill an order with an      offer for ETH outside of matching orders.\"}],\"InvalidProof()\":[{\"details\":\"Revert with an error when providing a criteria resolver that      contains an invalid proof with respect to the given item and      chosen identifier.\"}],\"InvalidRestrictedOrder(bytes32)\":[{\"details\":\"Revert with an error when attempting to fill an order that specifies      a restricted submitter as its order type when not submitted by      either the offerer or the order's zone or approved as valid by the      zone in question via a staticcall to `isValidOrder`.\",\"params\":{\"orderHash\":\"The order hash for the invalid restricted order.\"}}],\"InvalidSignature()\":[{\"details\":\"Revert with an error when a signer cannot be recovered from the      supplied signature.\"}],\"InvalidSigner()\":[{\"details\":\"Revert with an error when the signer recovered by the supplied      signature does not match the offerer or an allowed EIP-1271 signer      as specified by the offerer in the event they are a contract.\"}],\"InvalidTime()\":[{\"details\":\"Revert with an error when attempting to fill an order outside the      specified start time and end time.\"}],\"MismatchedFulfillmentOfferAndConsiderationComponents()\":[{\"details\":\"Revert with an error when the initial offer item named by a      fulfillment component does not match the type, token, identifier,      or conduit preference of the initial consideration item.\"}],\"MissingFulfillmentComponentOnAggregation(uint8)\":[{\"details\":\"Revert with an error when a fulfillment is provided that does not      declare at least one component as part of a call to fulfill      available orders.\"}],\"MissingItemAmount()\":[{\"details\":\"Revert with an error when attempting to fulfill an order where an      item has an amount of zero.\"}],\"MissingOriginalConsiderationItems()\":[{\"details\":\"Revert with an error when an order is supplied for fulfillment with      a consideration array that is shorter than the original array.\"}],\"NoContract(address)\":[{\"details\":\"Revert with an error when an account being called as an assumed      contract does not have code and returns no data.\",\"params\":{\"account\":\"The account that should contain code.\"}}],\"NoReentrantCalls()\":[{\"details\":\"Revert with an error when a caller attempts to reenter a protected      function.\"}],\"NoSpecifiedOrdersAvailable()\":[{\"details\":\"Revert with an error when attempting to fulfill any number of      available orders when none are fulfillable.\"}],\"OfferAndConsiderationRequiredOnFulfillment()\":[{\"details\":\"Revert with an error when a fulfillment is provided that does not      declare at least one offer component and at least one consideration      component.\"}],\"OfferCriteriaResolverOutOfRange()\":[{\"details\":\"Revert with an error when providing a criteria resolver that refers      to an order with an offer item that has not been supplied.\"}],\"OrderAlreadyFilled(bytes32)\":[{\"details\":\"Revert with an error when attempting to fill an order that has      already been fully filled.\",\"params\":{\"orderHash\":\"The order hash on which a fill was attempted.\"}}],\"OrderCriteriaResolverOutOfRange()\":[{\"details\":\"Revert with an error when providing a criteria resolver that refers      to an order that has not been supplied.\"}],\"OrderIsCancelled(bytes32)\":[{\"details\":\"Revert with an error when attempting to fill an order that has been      cancelled.\",\"params\":{\"orderHash\":\"The hash of the cancelled order.\"}}],\"OrderPartiallyFilled(bytes32)\":[{\"details\":\"Revert with an error when attempting to fill a basic order that has      been partially filled.\",\"params\":{\"orderHash\":\"The hash of the partially used order.\"}}],\"PartialFillsNotEnabledForOrder()\":[{\"details\":\"Revert with an error when a partial fill is attempted on an order      that does not specify partial fill support in its order type.\"}],\"TokenTransferGenericFailure(address,address,address,uint256,uint256)\":[{\"details\":\"Revert with an error when an ERC20, ERC721, or ERC1155 token      transfer reverts.\",\"params\":{\"amount\":\"The amount for the attempted transfer.\",\"from\":\"The source of the attempted transfer.\",\"identifier\":\"The identifier for the attempted transfer.\",\"to\":\"The recipient of the attempted transfer.\",\"token\":\"The token for which the transfer was attempted.\"}}],\"UnresolvedConsiderationCriteria()\":[{\"details\":\"Revert with an error if a consideration item still has unresolved      criteria after applying all criteria resolvers.\"}],\"UnresolvedOfferCriteria()\":[{\"details\":\"Revert with an error if an offer item still has unresolved criteria      after applying all criteria resolvers.\"}],\"UnusedItemParameters()\":[{\"details\":\"Revert with an error when attempting to fulfill an order where an      item has unused parameters. This includes both the token and the      identifier parameters for native transfers as well as the identifier      parameter for ERC20 transfers. Note that the conduit does not      perform this check, leaving it up to the calling channel to enforce      when desired.\"}]},\"kind\":\"dev\",\"methods\":{\"cancel((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256)[])\":{\"params\":{\"orders\":\"The orders to cancel.\"},\"returns\":{\"cancelled\":\"A boolean indicating whether the supplied orders have                   been successfully cancelled.\"}},\"constructor\":{\"params\":{\"conduitController\":\"A contract that deploys conduits, or proxies                          that may optionally be used to transfer approved                          ERC20/721/1155 tokens.\"}},\"fulfillAdvancedOrder(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),uint120,uint120,bytes,bytes),(uint256,uint8,uint256,uint256,bytes32[])[],bytes32,address)\":{\"params\":{\"advancedOrder\":\"The order to fulfill along with the fraction                            of the order to attempt to fill. Note that                            both the offerer and the fulfiller must first                            approve this contract (or their conduit if                            indicated by the order) to transfer any                            relevant tokens on their behalf and that                            contracts must implement `onERC1155Received`                            to receive ERC1155 tokens as consideration.                            Also note that all offer and consideration                            components must have no remainder after                            multiplication of the respective amount with                            the supplied fraction for the partial fill to                            be considered valid.\",\"criteriaResolvers\":\"An array where each element contains a                            reference to a specific offer or                            consideration, a token identifier, and a proof                            that the supplied token identifier is                            contained in the merkle root held by the item                            in question's criteria element. Note that an                            empty criteria indicates that any                            (transferable) token identifier on the token                            in question is valid and that no associated                            proof needs to be supplied.\",\"fulfillerConduitKey\":\"A bytes32 value indicating what conduit, if                            any, to source the fulfiller's token approvals                            from. The zero hash signifies that no conduit                            should be used (and direct approvals set on                            Consideration).\",\"recipient\":\"The intended recipient for all received items,                            with `address(0)` indicating that the caller                            should receive the items.\"},\"returns\":{\"fulfilled\":\"A boolean indicating whether the order has been                   successfully fulfilled.\"}},\"fulfillAvailableAdvancedOrders(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),uint120,uint120,bytes,bytes)[],(uint256,uint8,uint256,uint256,bytes32[])[],(uint256,uint256)[][],(uint256,uint256)[][],bytes32,address,uint256)\":{\"params\":{\"advancedOrders\":\"The orders to fulfill along with the                                  fraction of those orders to attempt to                                  fill. Note that both the offerer and the                                  fulfiller must first approve this                                  contract (or their conduit if indicated                                  by the order) to transfer any relevant                                  tokens on their behalf and that                                  contracts must implement                                  `onERC1155Received` in order to receive                                  ERC1155 tokens as consideration. Also                                  note that all offer and consideration                                  components must have no remainder after                                  multiplication of the respective amount                                  with the supplied fraction for an                                  order's partial fill amount to be                                  considered valid.\",\"considerationFulfillments\":\"An array of FulfillmentComponent arrays                                  indicating which consideration items to                                  attempt to aggregate when preparing                                  executions.\",\"criteriaResolvers\":\"An array where each element contains a                                  reference to a specific offer or                                  consideration, a token identifier, and a                                  proof that the supplied token identifier                                  is contained in the merkle root held by                                  the item in question's criteria element.                                  Note that an empty criteria indicates                                  that any (transferable) token                                  identifier on the token in question is                                  valid and that no associated proof needs                                  to be supplied.\",\"fulfillerConduitKey\":\"A bytes32 value indicating what conduit,                                  if any, to source the fulfiller's token                                  approvals from. The zero hash signifies                                  that no conduit should be used (and                                  direct approvals set on Consideration).\",\"maximumFulfilled\":\"The maximum number of orders to fulfill.\",\"offerFulfillments\":\"An array of FulfillmentComponent arrays                                  indicating which offer items to attempt                                  to aggregate when preparing executions.\",\"recipient\":\"The intended recipient for all received                                  items, with `address(0)` indicating that                                  the caller should receive the items.\"},\"returns\":{\"availableOrders\":\"An array of booleans indicating if each order                         with an index corresponding to the index of the                         returned boolean was fulfillable or not.\",\"executions\":\"     An array of elements indicating the sequence of                         transfers performed as part of matching the given                         orders.\"}},\"fulfillAvailableOrders(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),bytes)[],(uint256,uint256)[][],(uint256,uint256)[][],bytes32,uint256)\":{\"params\":{\"considerationFulfillments\":\"An array of FulfillmentComponent arrays                                  indicating which consideration items to                                  attempt to aggregate when preparing                                  executions.\",\"fulfillerConduitKey\":\"A bytes32 value indicating what conduit,                                  if any, to source the fulfiller's token                                  approvals from. The zero hash signifies                                  that no conduit should be used (and                                  direct approvals set on Consideration).\",\"maximumFulfilled\":\"The maximum number of orders to fulfill.\",\"offerFulfillments\":\"An array of FulfillmentComponent arrays                                  indicating which offer items to attempt                                  to aggregate when preparing executions.\",\"orders\":\"The orders to fulfill. Note that both                                  the offerer and the fulfiller must first                                  approve this contract (or the                                  corresponding conduit if indicated) to                                  transfer any relevant tokens on their                                  behalf and that contracts must implement                                  `onERC1155Received` to receive ERC1155                                  tokens as consideration.\"},\"returns\":{\"availableOrders\":\"An array of booleans indicating if each order                         with an index corresponding to the index of the                         returned boolean was fulfillable or not.\",\"executions\":\"     An array of elements indicating the sequence of                         transfers performed as part of matching the given                         orders.\"}},\"fulfillBasicOrder((address,uint256,uint256,address,address,address,uint256,uint256,uint8,uint256,uint256,bytes32,uint256,bytes32,bytes32,uint256,(uint256,address)[],bytes))\":{\"params\":{\"parameters\":\"Additional information on the fulfilled order. Note                   that the offerer and the fulfiller must first approve                   this contract (or their chosen conduit if indicated)                   before any tokens can be transferred. Also note that                   contract recipients of ERC1155 consideration items must                   implement `onERC1155Received` in order to receive those                   items.\"},\"returns\":{\"fulfilled\":\"A boolean indicating whether the order has been                   successfully fulfilled.\"}},\"fulfillOrder(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),bytes),bytes32)\":{\"params\":{\"fulfillerConduitKey\":\"A bytes32 value indicating what conduit, if                            any, to source the fulfiller's token approvals                            from. The zero hash signifies that no conduit                            should be used (and direct approvals set on                            Consideration).\",\"order\":\"The order to fulfill. Note that both the                            offerer and the fulfiller must first approve                            this contract (or the corresponding conduit if                            indicated) to transfer any relevant tokens on                            their behalf and that contracts must implement                            `onERC1155Received` to receive ERC1155 tokens                            as consideration.\"},\"returns\":{\"fulfilled\":\"A boolean indicating whether the order has been                   successfully fulfilled.\"}},\"getCounter(address)\":{\"params\":{\"offerer\":\"The offerer in question.\"},\"returns\":{\"counter\":\"The current counter.\"}},\"getOrderHash((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256))\":{\"params\":{\"order\":\"The components of the order.\"},\"returns\":{\"orderHash\":\"The order hash.\"}},\"getOrderStatus(bytes32)\":{\"params\":{\"orderHash\":\"The order hash in question.\"},\"returns\":{\"isCancelled\":\"A boolean indicating whether the order in question                     has been cancelled.\",\"isValidated\":\"A boolean indicating whether the order in question                     has been validated (i.e. previously approved or                     partially filled).\",\"totalFilled\":\"The total portion of the order that has been filled                     (i.e. the \\\"numerator\\\").\",\"totalSize\":\"  The total size of the order that is either filled or                     unfilled (i.e. the \\\"denominator\\\").\"}},\"incrementCounter()\":{\"returns\":{\"newCounter\":\"The new counter.\"}},\"information()\":{\"returns\":{\"conduitController\":\"The conduit Controller set for this contract.\",\"domainSeparator\":\"  The domain separator for this contract.\",\"version\":\"          The contract version.\"}},\"matchAdvancedOrders(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),uint120,uint120,bytes,bytes)[],(uint256,uint8,uint256,uint256,bytes32[])[],((uint256,uint256)[],(uint256,uint256)[])[])\":{\"params\":{\"advancedOrders\":\"The advanced orders to match. Note that both the                          offerer and fulfiller on each order must first                          approve this contract (or their conduit if                          indicated by the order) to transfer any relevant                          tokens on their behalf and each consideration                          recipient must implement `onERC1155Received` in                          order to receive ERC1155 tokens. Also note that                          the offer and consideration components for each                          order must have no remainder after multiplying                          the respective amount with the supplied fraction                          in order for the group of partial fills to be                          considered valid.\",\"criteriaResolvers\":\"An array where each element contains a reference                          to a specific order as well as that order's                          offer or consideration, a token identifier, and                          a proof that the supplied token identifier is                          contained in the order's merkle root. Note that                          an empty root indicates that any (transferable)                          token identifier is valid and that no associated                          proof needs to be supplied.\",\"fulfillments\":\"An array of elements allocating offer components                          to consideration components. Note that each                          consideration component must be fully met in                          order for the match operation to be valid.\"},\"returns\":{\"executions\":\"An array of elements indicating the sequence of                    transfers performed as part of matching the given                    orders.\"}},\"matchOrders(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),bytes)[],((uint256,uint256)[],(uint256,uint256)[])[])\":{\"params\":{\"fulfillments\":\"An array of elements allocating offer components                          to consideration components. Note that each                          consideration component must be fully met in                          order for the match operation to be valid.\",\"orders\":\"The orders to match. Note that both the offerer                          and fulfiller on each order must first approve                          this contract (or their conduit if indicated by                          the order) to transfer any relevant tokens on                          their behalf and each consideration recipient                          must implement `onERC1155Received` in order to                          receive ERC1155 tokens.\"},\"returns\":{\"executions\":\"An array of elements indicating the sequence of                    transfers performed as part of matching the given                    orders.\"}},\"name()\":{\"returns\":{\"contractName\":\"The name of this contract.\"}},\"validate(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),bytes)[])\":{\"params\":{\"orders\":\"The orders to validate.\"},\"returns\":{\"validated\":\"A boolean indicating whether the supplied orders have                   been successfully validated.\"}}},\"title\":\"Consideration\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"cancel((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256)[])\":{\"notice\":\"Cancel an arbitrary number of orders. Note that only the offerer         or the zone of a given order may cancel it. Callers should ensure         that the intended order was cancelled by calling `getOrderStatus`         and confirming that `isCancelled` returns `true`.\"},\"constructor\":{\"notice\":\"Derive and set hashes, reference chainId, and associated domain         separator during deployment.\"},\"fulfillAdvancedOrder(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),uint120,uint120,bytes,bytes),(uint256,uint8,uint256,uint256,bytes32[])[],bytes32,address)\":{\"notice\":\"Fill an order, fully or partially, with an arbitrary number of         items for offer and consideration alongside criteria resolvers         containing specific token identifiers and associated proofs.\"},\"fulfillAvailableAdvancedOrders(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),uint120,uint120,bytes,bytes)[],(uint256,uint8,uint256,uint256,bytes32[])[],(uint256,uint256)[][],(uint256,uint256)[][],bytes32,address,uint256)\":{\"notice\":\"Attempt to fill a group of orders, fully or partially, with an         arbitrary number of items for offer and consideration per order         alongside criteria resolvers containing specific token         identifiers and associated proofs. Any order that is not         currently active, has already been fully filled, or has been         cancelled will be omitted. Remaining offer and consideration         items will then be aggregated where possible as indicated by the         supplied offer and consideration component arrays and aggregated         items will be transferred to the fulfiller or to each intended         recipient, respectively. Note that a failing item transfer or an         issue with order formatting will cause the entire batch to fail.\"},\"fulfillAvailableOrders(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),bytes)[],(uint256,uint256)[][],(uint256,uint256)[][],bytes32,uint256)\":{\"notice\":\"Attempt to fill a group of orders, each with an arbitrary number         of items for offer and consideration. Any order that is not         currently active, has already been fully filled, or has been         cancelled will be omitted. Remaining offer and consideration         items will then be aggregated where possible as indicated by the         supplied offer and consideration component arrays and aggregated         items will be transferred to the fulfiller or to each intended         recipient, respectively. Note that a failing item transfer or an         issue with order formatting will cause the entire batch to fail.         Note that this function does not support criteria-based orders or         partial filling of orders (though filling the remainder of a         partially-filled order is supported).\"},\"fulfillBasicOrder((address,uint256,uint256,address,address,address,uint256,uint256,uint8,uint256,uint256,bytes32,uint256,bytes32,bytes32,uint256,(uint256,address)[],bytes))\":{\"notice\":\"Fulfill an order offering an ERC20, ERC721, or ERC1155 item by         supplying Ether (or other native tokens), ERC20 tokens, an ERC721         item, or an ERC1155 item as consideration. Six permutations are         supported: Native token to ERC721, Native token to ERC1155, ERC20         to ERC721, ERC20 to ERC1155, ERC721 to ERC20, and ERC1155 to         ERC20 (with native tokens supplied as msg.value). For an order to         be eligible for fulfillment via this method, it must contain a         single offer item (though that item may have a greater amount if         the item is not an ERC721). An arbitrary number of \\\"additional         recipients\\\" may also be supplied which will each receive native         tokens or ERC20 items from the fulfiller as consideration. Refer         to the documentation for a more comprehensive summary of how to         utilize this method and what orders are compatible with it.\"},\"fulfillOrder(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),bytes),bytes32)\":{\"notice\":\"Fulfill an order with an arbitrary number of items for offer and         consideration. Note that this function does not support         criteria-based orders or partial filling of orders (though         filling the remainder of a partially-filled order is supported).\"},\"getCounter(address)\":{\"notice\":\"Retrieve the current counter for a given offerer.\"},\"getOrderHash((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256))\":{\"notice\":\"Retrieve the order hash for a given order.\"},\"getOrderStatus(bytes32)\":{\"notice\":\"Retrieve the status of a given order by hash, including whether         the order has been cancelled or validated and the fraction of the         order that has been filled.\"},\"incrementCounter()\":{\"notice\":\"Cancel all orders from a given offerer with a given zone in bulk         by incrementing a counter. Note that only the offerer may         increment the counter.\"},\"information()\":{\"notice\":\"Retrieve configuration information for this contract.\"},\"matchAdvancedOrders(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),uint120,uint120,bytes,bytes)[],(uint256,uint8,uint256,uint256,bytes32[])[],((uint256,uint256)[],(uint256,uint256)[])[])\":{\"notice\":\"Match an arbitrary number of full or partial orders, each with an         arbitrary number of items for offer and consideration, supplying         criteria resolvers containing specific token identifiers and         associated proofs as well as fulfillments allocating offer         components to consideration components.\"},\"matchOrders(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),bytes)[],((uint256,uint256)[],(uint256,uint256)[])[])\":{\"notice\":\"Match an arbitrary number of orders, each with an arbitrary         number of items for offer and consideration along with a set of         fulfillments allocating offer components to consideration         components. Note that this function does not support         criteria-based or partial filling of orders (though filling the         remainder of a partially-filled order is supported).\"},\"name()\":{\"notice\":\"Retrieve the name of this contract.\"},\"validate(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),bytes)[])\":{\"notice\":\"Validate an arbitrary number of orders, thereby registering their         signatures as valid and allowing the fulfiller to skip signature         verification on fulfillment. Note that validated orders may still         be unfulfillable due to invalid item amounts or other factors;         callers should determine whether validated orders are fulfillable         by simulating the fulfillment call prior to execution. Also note         that anyone can validate a signed order, but only the offerer can         validate an order without supplying a signature.\"}},\"notice\":\"Consideration is a generalized ETH/ERC20/ERC721/ERC1155 marketplace.         It minimizes external calls to the greatest extent possible and         provides lightweight methods for common routes as well as more         flexible methods for composing advanced orders or groups of orders.         Each order contains an arbitrary number of items that may be spent         (the \\\"offer\\\") along with an arbitrary number of items that must be         received back by the indicated recipients (the \\\"consideration\\\").\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/lib/Consideration.sol\":\"Consideration\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":500},\"remappings\":[],\"viaIR\":true},\"sources\":{\"contracts/conduit/lib/ConduitEnums.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.7;\\r\\n\\r\\nenum ConduitItemType {\\r\\n    NATIVE, // unused\\r\\n    ERC20,\\r\\n    ERC721,\\r\\n    ERC1155\\r\\n}\\r\\n\",\"keccak256\":\"0x7e05a70aa7804d5706cba5e474c8256a8a330b13ded8c772994e5462737d1d4d\",\"license\":\"MIT\"},\"contracts/conduit/lib/ConduitStructs.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.7;\\r\\n\\r\\nimport { ConduitItemType } from \\\"./ConduitEnums.sol\\\";\\r\\n\\r\\nstruct ConduitTransfer {\\r\\n    ConduitItemType itemType;\\r\\n    address token;\\r\\n    address from;\\r\\n    address to;\\r\\n    uint256 identifier;\\r\\n    uint256 amount;\\r\\n}\\r\\n\\r\\nstruct ConduitBatch1155Transfer {\\r\\n    address token;\\r\\n    address from;\\r\\n    address to;\\r\\n    uint256[] ids;\\r\\n    uint256[] amounts;\\r\\n}\\r\\n\",\"keccak256\":\"0x4e9b5d93c9c8152bb4e36ab0efb5dd6fdfe87c39f9304c4d64816f99577de82a\",\"license\":\"MIT\"},\"contracts/interfaces/AmountDerivationErrors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.7;\\r\\n\\r\\n/**\\r\\n * @title AmountDerivationErrors\\r\\n * @author 0age\\r\\n * @notice AmountDerivationErrors contains errors related to amount derivation.\\r\\n */\\r\\ninterface AmountDerivationErrors {\\r\\n    /**\\r\\n     * @dev Revert with an error when attempting to apply a fraction as part of\\r\\n     *      a partial fill that does not divide the target amount cleanly.\\r\\n     */\\r\\n    error InexactFraction();\\r\\n}\\r\\n\",\"keccak256\":\"0x9ee3f62d72d01d6a2857c175c37f2bdef9392ff60cac73ae7b3d675091c4e50a\",\"license\":\"MIT\"},\"contracts/interfaces/ConduitControllerInterface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.7;\\r\\n\\r\\n/**\\r\\n * @title ConduitControllerInterface\\r\\n * @author 0age\\r\\n * @notice ConduitControllerInterface contains all external function interfaces,\\r\\n *         structs, events, and errors for the conduit controller.\\r\\n */\\r\\ninterface ConduitControllerInterface {\\r\\n    /**\\r\\n     * @dev Track the conduit key, current owner, new potential owner, and open\\r\\n     *      channels for each deployed conduit.\\r\\n     */\\r\\n    struct ConduitProperties {\\r\\n        bytes32 key;\\r\\n        address owner;\\r\\n        address potentialOwner;\\r\\n        address[] channels;\\r\\n        mapping(address => uint256) channelIndexesPlusOne;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Emit an event whenever a new conduit is created.\\r\\n     *\\r\\n     * @param conduit    The newly created conduit.\\r\\n     * @param conduitKey The conduit key used to create the new conduit.\\r\\n     */\\r\\n    event NewConduit(address conduit, bytes32 conduitKey);\\r\\n\\r\\n    /**\\r\\n     * @dev Emit an event whenever conduit ownership is transferred.\\r\\n     *\\r\\n     * @param conduit       The conduit for which ownership has been\\r\\n     *                      transferred.\\r\\n     * @param previousOwner The previous owner of the conduit.\\r\\n     * @param newOwner      The new owner of the conduit.\\r\\n     */\\r\\n    event OwnershipTransferred(\\r\\n        address indexed conduit,\\r\\n        address indexed previousOwner,\\r\\n        address indexed newOwner\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Emit an event whenever a conduit owner registers a new potential\\r\\n     *      owner for that conduit.\\r\\n     *\\r\\n     * @param newPotentialOwner The new potential owner of the conduit.\\r\\n     */\\r\\n    event PotentialOwnerUpdated(address indexed newPotentialOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Revert with an error when attempting to create a new conduit using a\\r\\n     *      conduit key where the first twenty bytes of the key do not match the\\r\\n     *      address of the caller.\\r\\n     */\\r\\n    error InvalidCreator();\\r\\n\\r\\n    /**\\r\\n     * @dev Revert with an error when attempting to create a new conduit when no\\r\\n     *      initial owner address is supplied.\\r\\n     */\\r\\n    error InvalidInitialOwner();\\r\\n\\r\\n    /**\\r\\n     * @dev Revert with an error when attempting to set a new potential owner\\r\\n     *      that is already set.\\r\\n     */\\r\\n    error NewPotentialOwnerAlreadySet(\\r\\n        address conduit,\\r\\n        address newPotentialOwner\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Revert with an error when attempting to cancel ownership transfer\\r\\n     *      when no new potential owner is currently set.\\r\\n     */\\r\\n    error NoPotentialOwnerCurrentlySet(address conduit);\\r\\n\\r\\n    /**\\r\\n     * @dev Revert with an error when attempting to interact with a conduit that\\r\\n     *      does not yet exist.\\r\\n     */\\r\\n    error NoConduit();\\r\\n\\r\\n    /**\\r\\n     * @dev Revert with an error when attempting to create a conduit that\\r\\n     *      already exists.\\r\\n     */\\r\\n    error ConduitAlreadyExists(address conduit);\\r\\n\\r\\n    /**\\r\\n     * @dev Revert with an error when attempting to update channels or transfer\\r\\n     *      ownership of a conduit when the caller is not the owner of the\\r\\n     *      conduit in question.\\r\\n     */\\r\\n    error CallerIsNotOwner(address conduit);\\r\\n\\r\\n    /**\\r\\n     * @dev Revert with an error when attempting to register a new potential\\r\\n     *      owner and supplying the null address.\\r\\n     */\\r\\n    error NewPotentialOwnerIsZeroAddress(address conduit);\\r\\n\\r\\n    /**\\r\\n     * @dev Revert with an error when attempting to claim ownership of a conduit\\r\\n     *      with a caller that is not the current potential owner for the\\r\\n     *      conduit in question.\\r\\n     */\\r\\n    error CallerIsNotNewPotentialOwner(address conduit);\\r\\n\\r\\n    /**\\r\\n     * @dev Revert with an error when attempting to retrieve a channel using an\\r\\n     *      index that is out of range.\\r\\n     */\\r\\n    error ChannelOutOfRange(address conduit);\\r\\n\\r\\n    /**\\r\\n     * @notice Deploy a new conduit using a supplied conduit key and assigning\\r\\n     *         an initial owner for the deployed conduit. Note that the first\\r\\n     *         twenty bytes of the supplied conduit key must match the caller\\r\\n     *         and that a new conduit cannot be created if one has already been\\r\\n     *         deployed using the same conduit key.\\r\\n     *\\r\\n     * @param conduitKey   The conduit key used to deploy the conduit. Note that\\r\\n     *                     the first twenty bytes of the conduit key must match\\r\\n     *                     the caller of this contract.\\r\\n     * @param initialOwner The initial owner to set for the new conduit.\\r\\n     *\\r\\n     * @return conduit The address of the newly deployed conduit.\\r\\n     */\\r\\n    function createConduit(bytes32 conduitKey, address initialOwner)\\r\\n        external\\r\\n        returns (address conduit);\\r\\n\\r\\n    /**\\r\\n     * @notice Open or close a channel on a given conduit, thereby allowing the\\r\\n     *         specified account to execute transfers against that conduit.\\r\\n     *         Extreme care must be taken when updating channels, as malicious\\r\\n     *         or vulnerable channels can transfer any ERC20, ERC721 and ERC1155\\r\\n     *         tokens where the token holder has granted the conduit approval.\\r\\n     *         Only the owner of the conduit in question may call this function.\\r\\n     *\\r\\n     * @param conduit The conduit for which to open or close the channel.\\r\\n     * @param channel The channel to open or close on the conduit.\\r\\n     * @param isOpen  A boolean indicating whether to open or close the channel.\\r\\n     */\\r\\n    function updateChannel(\\r\\n        address conduit,\\r\\n        address channel,\\r\\n        bool isOpen\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Initiate conduit ownership transfer by assigning a new potential\\r\\n     *         owner for the given conduit. Once set, the new potential owner\\r\\n     *         may call `acceptOwnership` to claim ownership of the conduit.\\r\\n     *         Only the owner of the conduit in question may call this function.\\r\\n     *\\r\\n     * @param conduit The conduit for which to initiate ownership transfer.\\r\\n     * @param newPotentialOwner The new potential owner of the conduit.\\r\\n     */\\r\\n    function transferOwnership(address conduit, address newPotentialOwner)\\r\\n        external;\\r\\n\\r\\n    /**\\r\\n     * @notice Clear the currently set potential owner, if any, from a conduit.\\r\\n     *         Only the owner of the conduit in question may call this function.\\r\\n     *\\r\\n     * @param conduit The conduit for which to cancel ownership transfer.\\r\\n     */\\r\\n    function cancelOwnershipTransfer(address conduit) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Accept ownership of a supplied conduit. Only accounts that the\\r\\n     *         current owner has set as the new potential owner may call this\\r\\n     *         function.\\r\\n     *\\r\\n     * @param conduit The conduit for which to accept ownership.\\r\\n     */\\r\\n    function acceptOwnership(address conduit) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Retrieve the current owner of a deployed conduit.\\r\\n     *\\r\\n     * @param conduit The conduit for which to retrieve the associated owner.\\r\\n     *\\r\\n     * @return owner The owner of the supplied conduit.\\r\\n     */\\r\\n    function ownerOf(address conduit) external view returns (address owner);\\r\\n\\r\\n    /**\\r\\n     * @notice Retrieve the conduit key for a deployed conduit via reverse\\r\\n     *         lookup.\\r\\n     *\\r\\n     * @param conduit The conduit for which to retrieve the associated conduit\\r\\n     *                key.\\r\\n     *\\r\\n     * @return conduitKey The conduit key used to deploy the supplied conduit.\\r\\n     */\\r\\n    function getKey(address conduit) external view returns (bytes32 conduitKey);\\r\\n\\r\\n    /**\\r\\n     * @notice Derive the conduit associated with a given conduit key and\\r\\n     *         determine whether that conduit exists (i.e. whether it has been\\r\\n     *         deployed).\\r\\n     *\\r\\n     * @param conduitKey The conduit key used to derive the conduit.\\r\\n     *\\r\\n     * @return conduit The derived address of the conduit.\\r\\n     * @return exists  A boolean indicating whether the derived conduit has been\\r\\n     *                 deployed or not.\\r\\n     */\\r\\n    function getConduit(bytes32 conduitKey)\\r\\n        external\\r\\n        view\\r\\n        returns (address conduit, bool exists);\\r\\n\\r\\n    /**\\r\\n     * @notice Retrieve the potential owner, if any, for a given conduit. The\\r\\n     *         current owner may set a new potential owner via\\r\\n     *         `transferOwnership` and that owner may then accept ownership of\\r\\n     *         the conduit in question via `acceptOwnership`.\\r\\n     *\\r\\n     * @param conduit The conduit for which to retrieve the potential owner.\\r\\n     *\\r\\n     * @return potentialOwner The potential owner, if any, for the conduit.\\r\\n     */\\r\\n    function getPotentialOwner(address conduit)\\r\\n        external\\r\\n        view\\r\\n        returns (address potentialOwner);\\r\\n\\r\\n    /**\\r\\n     * @notice Retrieve the status (either open or closed) of a given channel on\\r\\n     *         a conduit.\\r\\n     *\\r\\n     * @param conduit The conduit for which to retrieve the channel status.\\r\\n     * @param channel The channel for which to retrieve the status.\\r\\n     *\\r\\n     * @return isOpen The status of the channel on the given conduit.\\r\\n     */\\r\\n    function getChannelStatus(address conduit, address channel)\\r\\n        external\\r\\n        view\\r\\n        returns (bool isOpen);\\r\\n\\r\\n    /**\\r\\n     * @notice Retrieve the total number of open channels for a given conduit.\\r\\n     *\\r\\n     * @param conduit The conduit for which to retrieve the total channel count.\\r\\n     *\\r\\n     * @return totalChannels The total number of open channels for the conduit.\\r\\n     */\\r\\n    function getTotalChannels(address conduit)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256 totalChannels);\\r\\n\\r\\n    /**\\r\\n     * @notice Retrieve an open channel at a specific index for a given conduit.\\r\\n     *         Note that the index of a channel can change as a result of other\\r\\n     *         channels being closed on the conduit.\\r\\n     *\\r\\n     * @param conduit      The conduit for which to retrieve the open channel.\\r\\n     * @param channelIndex The index of the channel in question.\\r\\n     *\\r\\n     * @return channel The open channel, if any, at the specified channel index.\\r\\n     */\\r\\n    function getChannel(address conduit, uint256 channelIndex)\\r\\n        external\\r\\n        view\\r\\n        returns (address channel);\\r\\n\\r\\n    /**\\r\\n     * @notice Retrieve all open channels for a given conduit. Note that calling\\r\\n     *         this function for a conduit with many channels will revert with\\r\\n     *         an out-of-gas error.\\r\\n     *\\r\\n     * @param conduit The conduit for which to retrieve open channels.\\r\\n     *\\r\\n     * @return channels An array of open channels on the given conduit.\\r\\n     */\\r\\n    function getChannels(address conduit)\\r\\n        external\\r\\n        view\\r\\n        returns (address[] memory channels);\\r\\n\\r\\n    /**\\r\\n     * @dev Retrieve the conduit creation code and runtime code hashes.\\r\\n     */\\r\\n    function getConduitCodeHashes()\\r\\n        external\\r\\n        view\\r\\n        returns (bytes32 creationCodeHash, bytes32 runtimeCodeHash);\\r\\n}\\r\\n\",\"keccak256\":\"0xcd162169e9ffce306588b56b17fe4eb4085e53a5eeb6e0ec3f415b37074703b5\",\"license\":\"MIT\"},\"contracts/interfaces/ConduitInterface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.7;\\r\\n\\r\\n// prettier-ignore\\r\\nimport {\\r\\n    ConduitTransfer,\\r\\n    ConduitBatch1155Transfer\\r\\n} from \\\"../conduit/lib/ConduitStructs.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title ConduitInterface\\r\\n * @author 0age\\r\\n * @notice ConduitInterface contains all external function interfaces, events,\\r\\n *         and errors for conduit contracts.\\r\\n */\\r\\ninterface ConduitInterface {\\r\\n    /**\\r\\n     * @dev Revert with an error when attempting to execute transfers using a\\r\\n     *      caller that does not have an open channel.\\r\\n     */\\r\\n    error ChannelClosed(address channel);\\r\\n\\r\\n    /**\\r\\n     * @dev Revert with an error when attempting to update a channel to the\\r\\n     *      current status of that channel.\\r\\n     */\\r\\n    error ChannelStatusAlreadySet(address channel, bool isOpen);\\r\\n\\r\\n    /**\\r\\n     * @dev Revert with an error when attempting to execute a transfer for an\\r\\n     *      item that does not have an ERC20/721/1155 item type.\\r\\n     */\\r\\n    error InvalidItemType();\\r\\n\\r\\n    /**\\r\\n     * @dev Revert with an error when attempting to update the status of a\\r\\n     *      channel from a caller that is not the conduit controller.\\r\\n     */\\r\\n    error InvalidController();\\r\\n\\r\\n    /**\\r\\n     * @dev Emit an event whenever a channel is opened or closed.\\r\\n     *\\r\\n     * @param channel The channel that has been updated.\\r\\n     * @param open    A boolean indicating whether the conduit is open or not.\\r\\n     */\\r\\n    event ChannelUpdated(address indexed channel, bool open);\\r\\n\\r\\n    /**\\r\\n     * @notice Execute a sequence of ERC20/721/1155 transfers. Only a caller\\r\\n     *         with an open channel can call this function.\\r\\n     *\\r\\n     * @param transfers The ERC20/721/1155 transfers to perform.\\r\\n     *\\r\\n     * @return magicValue A magic value indicating that the transfers were\\r\\n     *                    performed successfully.\\r\\n     */\\r\\n    function execute(ConduitTransfer[] calldata transfers)\\r\\n        external\\r\\n        returns (bytes4 magicValue);\\r\\n\\r\\n    /**\\r\\n     * @notice Execute a sequence of batch 1155 transfers. Only a caller with an\\r\\n     *         open channel can call this function.\\r\\n     *\\r\\n     * @param batch1155Transfers The 1155 batch transfers to perform.\\r\\n     *\\r\\n     * @return magicValue A magic value indicating that the transfers were\\r\\n     *                    performed successfully.\\r\\n     */\\r\\n    function executeBatch1155(\\r\\n        ConduitBatch1155Transfer[] calldata batch1155Transfers\\r\\n    ) external returns (bytes4 magicValue);\\r\\n\\r\\n    /**\\r\\n     * @notice Execute a sequence of transfers, both single and batch 1155. Only\\r\\n     *         a caller with an open channel can call this function.\\r\\n     *\\r\\n     * @param standardTransfers  The ERC20/721/1155 transfers to perform.\\r\\n     * @param batch1155Transfers The 1155 batch transfers to perform.\\r\\n     *\\r\\n     * @return magicValue A magic value indicating that the transfers were\\r\\n     *                    performed successfully.\\r\\n     */\\r\\n    function executeWithBatch1155(\\r\\n        ConduitTransfer[] calldata standardTransfers,\\r\\n        ConduitBatch1155Transfer[] calldata batch1155Transfers\\r\\n    ) external returns (bytes4 magicValue);\\r\\n\\r\\n    /**\\r\\n     * @notice Open or close a given channel. Only callable by the controller.\\r\\n     *\\r\\n     * @param channel The channel to open or close.\\r\\n     * @param isOpen  The status of the channel (either open or closed).\\r\\n     */\\r\\n    function updateChannel(address channel, bool isOpen) external;\\r\\n}\\r\\n\",\"keccak256\":\"0xdba5fc99ba27fa778af68358efda9bacab1c8dff3403c5d5f34ebe767898b191\",\"license\":\"MIT\"},\"contracts/interfaces/ConsiderationEventsAndErrors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.7;\\r\\n\\r\\nimport { SpentItem, ReceivedItem } from \\\"../lib/ConsiderationStructs.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title ConsiderationEventsAndErrors\\r\\n * @author 0age\\r\\n * @notice ConsiderationEventsAndErrors contains all events and errors.\\r\\n */\\r\\ninterface ConsiderationEventsAndErrors {\\r\\n    /**\\r\\n     * @dev Emit an event whenever an order is successfully fulfilled.\\r\\n     *\\r\\n     * @param orderHash     The hash of the fulfilled order.\\r\\n     * @param offerer       The offerer of the fulfilled order.\\r\\n     * @param zone          The zone of the fulfilled order.\\r\\n     * @param recipient     The recipient of each spent item on the fulfilled\\r\\n     *                      order, or the null address if there is no specific\\r\\n     *                      fulfiller (i.e. the order is part of a group of\\r\\n     *                      orders). Defaults to the caller unless explicitly\\r\\n     *                      specified otherwise by the fulfiller.\\r\\n     * @param offer         The offer items spent as part of the order.\\r\\n     * @param consideration The consideration items received as part of the\\r\\n     *                      order along with the recipients of each item.\\r\\n     */\\r\\n    event OrderFulfilled(\\r\\n        bytes32 orderHash,\\r\\n        address indexed offerer,\\r\\n        address indexed zone,\\r\\n        address recipient,\\r\\n        SpentItem[] offer,\\r\\n        ReceivedItem[] consideration\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Emit an event whenever an order is successfully cancelled.\\r\\n     *\\r\\n     * @param orderHash The hash of the cancelled order.\\r\\n     * @param offerer   The offerer of the cancelled order.\\r\\n     * @param zone      The zone of the cancelled order.\\r\\n     */\\r\\n    event OrderCancelled(\\r\\n        bytes32 orderHash,\\r\\n        address indexed offerer,\\r\\n        address indexed zone\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Emit an event whenever an order is explicitly validated. Note that\\r\\n     *      this event will not be emitted on partial fills even though they do\\r\\n     *      validate the order as part of partial fulfillment.\\r\\n     *\\r\\n     * @param orderHash The hash of the validated order.\\r\\n     * @param offerer   The offerer of the validated order.\\r\\n     * @param zone      The zone of the validated order.\\r\\n     */\\r\\n    event OrderValidated(\\r\\n        bytes32 orderHash,\\r\\n        address indexed offerer,\\r\\n        address indexed zone\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Emit an event whenever a counter for a given offerer is incremented.\\r\\n     *\\r\\n     * @param newCounter The new counter for the offerer.\\r\\n     * @param offerer  The offerer in question.\\r\\n     */\\r\\n    event CounterIncremented(uint256 newCounter, address indexed offerer);\\r\\n\\r\\n    /**\\r\\n     * @dev Revert with an error when attempting to fill an order that has\\r\\n     *      already been fully filled.\\r\\n     *\\r\\n     * @param orderHash The order hash on which a fill was attempted.\\r\\n     */\\r\\n    error OrderAlreadyFilled(bytes32 orderHash);\\r\\n\\r\\n    /**\\r\\n     * @dev Revert with an error when attempting to fill an order outside the\\r\\n     *      specified start time and end time.\\r\\n     */\\r\\n    error InvalidTime();\\r\\n\\r\\n    /**\\r\\n     * @dev Revert with an error when attempting to fill an order referencing an\\r\\n     *      invalid conduit (i.e. one that has not been deployed).\\r\\n     */\\r\\n    error InvalidConduit(bytes32 conduitKey, address conduit);\\r\\n\\r\\n    /**\\r\\n     * @dev Revert with an error when an order is supplied for fulfillment with\\r\\n     *      a consideration array that is shorter than the original array.\\r\\n     */\\r\\n    error MissingOriginalConsiderationItems();\\r\\n\\r\\n    /**\\r\\n     * @dev Revert with an error when a call to a conduit fails with revert data\\r\\n     *      that is too expensive to return.\\r\\n     */\\r\\n    error InvalidCallToConduit(address conduit);\\r\\n\\r\\n    /**\\r\\n     * @dev Revert with an error if a consideration amount has not been fully\\r\\n     *      zeroed out after applying all fulfillments.\\r\\n     *\\r\\n     * @param orderIndex         The index of the order with the consideration\\r\\n     *                           item with a shortfall.\\r\\n     * @param considerationIndex The index of the consideration item on the\\r\\n     *                           order.\\r\\n     * @param shortfallAmount    The unfulfilled consideration amount.\\r\\n     */\\r\\n    error ConsiderationNotMet(\\r\\n        uint256 orderIndex,\\r\\n        uint256 considerationIndex,\\r\\n        uint256 shortfallAmount\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Revert with an error when insufficient ether is supplied as part of\\r\\n     *      msg.value when fulfilling orders.\\r\\n     */\\r\\n    error InsufficientEtherSupplied();\\r\\n\\r\\n    /**\\r\\n     * @dev Revert with an error when an ether transfer reverts.\\r\\n     */\\r\\n    error EtherTransferGenericFailure(address account, uint256 amount);\\r\\n\\r\\n    /**\\r\\n     * @dev Revert with an error when a partial fill is attempted on an order\\r\\n     *      that does not specify partial fill support in its order type.\\r\\n     */\\r\\n    error PartialFillsNotEnabledForOrder();\\r\\n\\r\\n    /**\\r\\n     * @dev Revert with an error when attempting to fill an order that has been\\r\\n     *      cancelled.\\r\\n     *\\r\\n     * @param orderHash The hash of the cancelled order.\\r\\n     */\\r\\n    error OrderIsCancelled(bytes32 orderHash);\\r\\n\\r\\n    /**\\r\\n     * @dev Revert with an error when attempting to fill a basic order that has\\r\\n     *      been partially filled.\\r\\n     *\\r\\n     * @param orderHash The hash of the partially used order.\\r\\n     */\\r\\n    error OrderPartiallyFilled(bytes32 orderHash);\\r\\n\\r\\n    /**\\r\\n     * @dev Revert with an error when attempting to cancel an order as a caller\\r\\n     *      other than the indicated offerer or zone.\\r\\n     */\\r\\n    error InvalidCanceller();\\r\\n\\r\\n    /**\\r\\n     * @dev Revert with an error when supplying a fraction with a value of zero\\r\\n     *      for the numerator or denominator, or one where the numerator exceeds\\r\\n     *      the denominator.\\r\\n     */\\r\\n    error BadFraction();\\r\\n\\r\\n    /**\\r\\n     * @dev Revert with an error when a caller attempts to supply callvalue to a\\r\\n     *      non-payable basic order route or does not supply any callvalue to a\\r\\n     *      payable basic order route.\\r\\n     */\\r\\n    error InvalidMsgValue(uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Revert with an error when attempting to fill a basic order using\\r\\n     *      calldata not produced by default ABI encoding.\\r\\n     */\\r\\n    error InvalidBasicOrderParameterEncoding();\\r\\n\\r\\n    /**\\r\\n     * @dev Revert with an error when attempting to fulfill any number of\\r\\n     *      available orders when none are fulfillable.\\r\\n     */\\r\\n    error NoSpecifiedOrdersAvailable();\\r\\n\\r\\n    /**\\r\\n     * @dev Revert with an error when attempting to fulfill an order with an\\r\\n     *      offer for ETH outside of matching orders.\\r\\n     */\\r\\n    error InvalidNativeOfferItem();\\r\\n}\\r\\n\",\"keccak256\":\"0xefdcdefa8343cd3070f57ed4e669ebb5d2fe78f146dad05f98d0167d11222e36\",\"license\":\"MIT\"},\"contracts/interfaces/ConsiderationInterface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.7;\\r\\n\\r\\n// prettier-ignore\\r\\nimport {\\r\\n    BasicOrderParameters,\\r\\n    OrderComponents,\\r\\n    Fulfillment,\\r\\n    FulfillmentComponent,\\r\\n    Execution,\\r\\n    Order,\\r\\n    AdvancedOrder,\\r\\n    OrderStatus,\\r\\n    CriteriaResolver\\r\\n} from \\\"../lib/ConsiderationStructs.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title ConsiderationInterface\\r\\n * @author 0age\\r\\n * @custom:version 1.1\\r\\n * @notice Consideration is a generalized ETH/ERC20/ERC721/ERC1155 marketplace.\\r\\n *         It minimizes external calls to the greatest extent possible and\\r\\n *         provides lightweight methods for common routes as well as more\\r\\n *         flexible methods for composing advanced orders.\\r\\n *\\r\\n * @dev ConsiderationInterface contains all external function interfaces for\\r\\n *      Consideration.\\r\\n */\\r\\ninterface ConsiderationInterface {\\r\\n    /**\\r\\n     * @notice Fulfill an order offering an ERC721 token by supplying Ether (or\\r\\n     *         the native token for the given chain) as consideration for the\\r\\n     *         order. An arbitrary number of \\\"additional recipients\\\" may also be\\r\\n     *         supplied which will each receive native tokens from the fulfiller\\r\\n     *         as consideration.\\r\\n     *\\r\\n     * @param parameters Additional information on the fulfilled order. Note\\r\\n     *                   that the offerer must first approve this contract (or\\r\\n     *                   their preferred conduit if indicated by the order) for\\r\\n     *                   their offered ERC721 token to be transferred.\\r\\n     *\\r\\n     * @return fulfilled A boolean indicating whether the order has been\\r\\n     *                   successfully fulfilled.\\r\\n     */\\r\\n    function fulfillBasicOrder(BasicOrderParameters calldata parameters)\\r\\n        external\\r\\n        payable\\r\\n        returns (bool fulfilled);\\r\\n\\r\\n    /**\\r\\n     * @notice Fulfill an order with an arbitrary number of items for offer and\\r\\n     *         consideration. Note that this function does not support\\r\\n     *         criteria-based orders or partial filling of orders (though\\r\\n     *         filling the remainder of a partially-filled order is supported).\\r\\n     *\\r\\n     * @param order               The order to fulfill. Note that both the\\r\\n     *                            offerer and the fulfiller must first approve\\r\\n     *                            this contract (or the corresponding conduit if\\r\\n     *                            indicated) to transfer any relevant tokens on\\r\\n     *                            their behalf and that contracts must implement\\r\\n     *                            `onERC1155Received` to receive ERC1155 tokens\\r\\n     *                            as consideration.\\r\\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\\r\\n     *                            any, to source the fulfiller's token approvals\\r\\n     *                            from. The zero hash signifies that no conduit\\r\\n     *                            should be used, with direct approvals set on\\r\\n     *                            Consideration.\\r\\n     *\\r\\n     * @return fulfilled A boolean indicating whether the order has been\\r\\n     *                   successfully fulfilled.\\r\\n     */\\r\\n    function fulfillOrder(Order calldata order, bytes32 fulfillerConduitKey)\\r\\n        external\\r\\n        payable\\r\\n        returns (bool fulfilled);\\r\\n\\r\\n    /**\\r\\n     * @notice Fill an order, fully or partially, with an arbitrary number of\\r\\n     *         items for offer and consideration alongside criteria resolvers\\r\\n     *         containing specific token identifiers and associated proofs.\\r\\n     *\\r\\n     * @param advancedOrder       The order to fulfill along with the fraction\\r\\n     *                            of the order to attempt to fill. Note that\\r\\n     *                            both the offerer and the fulfiller must first\\r\\n     *                            approve this contract (or their preferred\\r\\n     *                            conduit if indicated by the order) to transfer\\r\\n     *                            any relevant tokens on their behalf and that\\r\\n     *                            contracts must implement `onERC1155Received`\\r\\n     *                            to receive ERC1155 tokens as consideration.\\r\\n     *                            Also note that all offer and consideration\\r\\n     *                            components must have no remainder after\\r\\n     *                            multiplication of the respective amount with\\r\\n     *                            the supplied fraction for the partial fill to\\r\\n     *                            be considered valid.\\r\\n     * @param criteriaResolvers   An array where each element contains a\\r\\n     *                            reference to a specific offer or\\r\\n     *                            consideration, a token identifier, and a proof\\r\\n     *                            that the supplied token identifier is\\r\\n     *                            contained in the merkle root held by the item\\r\\n     *                            in question's criteria element. Note that an\\r\\n     *                            empty criteria indicates that any\\r\\n     *                            (transferable) token identifier on the token\\r\\n     *                            in question is valid and that no associated\\r\\n     *                            proof needs to be supplied.\\r\\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\\r\\n     *                            any, to source the fulfiller's token approvals\\r\\n     *                            from. The zero hash signifies that no conduit\\r\\n     *                            should be used, with direct approvals set on\\r\\n     *                            Consideration.\\r\\n     * @param recipient           The intended recipient for all received items,\\r\\n     *                            with `address(0)` indicating that the caller\\r\\n     *                            should receive the items.\\r\\n     *\\r\\n     * @return fulfilled A boolean indicating whether the order has been\\r\\n     *                   successfully fulfilled.\\r\\n     */\\r\\n    function fulfillAdvancedOrder(\\r\\n        AdvancedOrder calldata advancedOrder,\\r\\n        CriteriaResolver[] calldata criteriaResolvers,\\r\\n        bytes32 fulfillerConduitKey,\\r\\n        address recipient\\r\\n    ) external payable returns (bool fulfilled);\\r\\n\\r\\n    /**\\r\\n     * @notice Attempt to fill a group of orders, each with an arbitrary number\\r\\n     *         of items for offer and consideration. Any order that is not\\r\\n     *         currently active, has already been fully filled, or has been\\r\\n     *         cancelled will be omitted. Remaining offer and consideration\\r\\n     *         items will then be aggregated where possible as indicated by the\\r\\n     *         supplied offer and consideration component arrays and aggregated\\r\\n     *         items will be transferred to the fulfiller or to each intended\\r\\n     *         recipient, respectively. Note that a failing item transfer or an\\r\\n     *         issue with order formatting will cause the entire batch to fail.\\r\\n     *         Note that this function does not support criteria-based orders or\\r\\n     *         partial filling of orders (though filling the remainder of a\\r\\n     *         partially-filled order is supported).\\r\\n     *\\r\\n     * @param orders                    The orders to fulfill. Note that both\\r\\n     *                                  the offerer and the fulfiller must first\\r\\n     *                                  approve this contract (or the\\r\\n     *                                  corresponding conduit if indicated) to\\r\\n     *                                  transfer any relevant tokens on their\\r\\n     *                                  behalf and that contracts must implement\\r\\n     *                                  `onERC1155Received` to receive ERC1155\\r\\n     *                                  tokens as consideration.\\r\\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\\r\\n     *                                  indicating which offer items to attempt\\r\\n     *                                  to aggregate when preparing executions.\\r\\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\\r\\n     *                                  indicating which consideration items to\\r\\n     *                                  attempt to aggregate when preparing\\r\\n     *                                  executions.\\r\\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\\r\\n     *                                  if any, to source the fulfiller's token\\r\\n     *                                  approvals from. The zero hash signifies\\r\\n     *                                  that no conduit should be used, with\\r\\n     *                                  direct approvals set on this contract.\\r\\n     * @param maximumFulfilled          The maximum number of orders to fulfill.\\r\\n     *\\r\\n     * @return availableOrders An array of booleans indicating if each order\\r\\n     *                         with an index corresponding to the index of the\\r\\n     *                         returned boolean was fulfillable or not.\\r\\n     * @return executions      An array of elements indicating the sequence of\\r\\n     *                         transfers performed as part of matching the given\\r\\n     *                         orders.\\r\\n     */\\r\\n    function fulfillAvailableOrders(\\r\\n        Order[] calldata orders,\\r\\n        FulfillmentComponent[][] calldata offerFulfillments,\\r\\n        FulfillmentComponent[][] calldata considerationFulfillments,\\r\\n        bytes32 fulfillerConduitKey,\\r\\n        uint256 maximumFulfilled\\r\\n    )\\r\\n        external\\r\\n        payable\\r\\n        returns (bool[] memory availableOrders, Execution[] memory executions);\\r\\n\\r\\n    /**\\r\\n     * @notice Attempt to fill a group of orders, fully or partially, with an\\r\\n     *         arbitrary number of items for offer and consideration per order\\r\\n     *         alongside criteria resolvers containing specific token\\r\\n     *         identifiers and associated proofs. Any order that is not\\r\\n     *         currently active, has already been fully filled, or has been\\r\\n     *         cancelled will be omitted. Remaining offer and consideration\\r\\n     *         items will then be aggregated where possible as indicated by the\\r\\n     *         supplied offer and consideration component arrays and aggregated\\r\\n     *         items will be transferred to the fulfiller or to each intended\\r\\n     *         recipient, respectively. Note that a failing item transfer or an\\r\\n     *         issue with order formatting will cause the entire batch to fail.\\r\\n     *\\r\\n     * @param advancedOrders            The orders to fulfill along with the\\r\\n     *                                  fraction of those orders to attempt to\\r\\n     *                                  fill. Note that both the offerer and the\\r\\n     *                                  fulfiller must first approve this\\r\\n     *                                  contract (or their preferred conduit if\\r\\n     *                                  indicated by the order) to transfer any\\r\\n     *                                  relevant tokens on their behalf and that\\r\\n     *                                  contracts must implement\\r\\n     *                                  `onERC1155Received` to enable receipt of\\r\\n     *                                  ERC1155 tokens as consideration. Also\\r\\n     *                                  note that all offer and consideration\\r\\n     *                                  components must have no remainder after\\r\\n     *                                  multiplication of the respective amount\\r\\n     *                                  with the supplied fraction for an\\r\\n     *                                  order's partial fill amount to be\\r\\n     *                                  considered valid.\\r\\n     * @param criteriaResolvers         An array where each element contains a\\r\\n     *                                  reference to a specific offer or\\r\\n     *                                  consideration, a token identifier, and a\\r\\n     *                                  proof that the supplied token identifier\\r\\n     *                                  is contained in the merkle root held by\\r\\n     *                                  the item in question's criteria element.\\r\\n     *                                  Note that an empty criteria indicates\\r\\n     *                                  that any (transferable) token\\r\\n     *                                  identifier on the token in question is\\r\\n     *                                  valid and that no associated proof needs\\r\\n     *                                  to be supplied.\\r\\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\\r\\n     *                                  indicating which offer items to attempt\\r\\n     *                                  to aggregate when preparing executions.\\r\\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\\r\\n     *                                  indicating which consideration items to\\r\\n     *                                  attempt to aggregate when preparing\\r\\n     *                                  executions.\\r\\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\\r\\n     *                                  if any, to source the fulfiller's token\\r\\n     *                                  approvals from. The zero hash signifies\\r\\n     *                                  that no conduit should be used, with\\r\\n     *                                  direct approvals set on this contract.\\r\\n     * @param recipient                 The intended recipient for all received\\r\\n     *                                  items, with `address(0)` indicating that\\r\\n     *                                  the caller should receive the items.\\r\\n     * @param maximumFulfilled          The maximum number of orders to fulfill.\\r\\n     *\\r\\n     * @return availableOrders An array of booleans indicating if each order\\r\\n     *                         with an index corresponding to the index of the\\r\\n     *                         returned boolean was fulfillable or not.\\r\\n     * @return executions      An array of elements indicating the sequence of\\r\\n     *                         transfers performed as part of matching the given\\r\\n     *                         orders.\\r\\n     */\\r\\n    function fulfillAvailableAdvancedOrders(\\r\\n        AdvancedOrder[] calldata advancedOrders,\\r\\n        CriteriaResolver[] calldata criteriaResolvers,\\r\\n        FulfillmentComponent[][] calldata offerFulfillments,\\r\\n        FulfillmentComponent[][] calldata considerationFulfillments,\\r\\n        bytes32 fulfillerConduitKey,\\r\\n        address recipient,\\r\\n        uint256 maximumFulfilled\\r\\n    )\\r\\n        external\\r\\n        payable\\r\\n        returns (bool[] memory availableOrders, Execution[] memory executions);\\r\\n\\r\\n    /**\\r\\n     * @notice Match an arbitrary number of orders, each with an arbitrary\\r\\n     *         number of items for offer and consideration along with as set of\\r\\n     *         fulfillments allocating offer components to consideration\\r\\n     *         components. Note that this function does not support\\r\\n     *         criteria-based or partial filling of orders (though filling the\\r\\n     *         remainder of a partially-filled order is supported).\\r\\n     *\\r\\n     * @param orders       The orders to match. Note that both the offerer and\\r\\n     *                     fulfiller on each order must first approve this\\r\\n     *                     contract (or their conduit if indicated by the order)\\r\\n     *                     to transfer any relevant tokens on their behalf and\\r\\n     *                     each consideration recipient must implement\\r\\n     *                     `onERC1155Received` to enable ERC1155 token receipt.\\r\\n     * @param fulfillments An array of elements allocating offer components to\\r\\n     *                     consideration components. Note that each\\r\\n     *                     consideration component must be fully met for the\\r\\n     *                     match operation to be valid.\\r\\n     *\\r\\n     * @return executions An array of elements indicating the sequence of\\r\\n     *                    transfers performed as part of matching the given\\r\\n     *                    orders.\\r\\n     */\\r\\n    function matchOrders(\\r\\n        Order[] calldata orders,\\r\\n        Fulfillment[] calldata fulfillments\\r\\n    ) external payable returns (Execution[] memory executions);\\r\\n\\r\\n    /**\\r\\n     * @notice Match an arbitrary number of full or partial orders, each with an\\r\\n     *         arbitrary number of items for offer and consideration, supplying\\r\\n     *         criteria resolvers containing specific token identifiers and\\r\\n     *         associated proofs as well as fulfillments allocating offer\\r\\n     *         components to consideration components.\\r\\n     *\\r\\n     * @param orders            The advanced orders to match. Note that both the\\r\\n     *                          offerer and fulfiller on each order must first\\r\\n     *                          approve this contract (or a preferred conduit if\\r\\n     *                          indicated by the order) to transfer any relevant\\r\\n     *                          tokens on their behalf and each consideration\\r\\n     *                          recipient must implement `onERC1155Received` in\\r\\n     *                          order to receive ERC1155 tokens. Also note that\\r\\n     *                          the offer and consideration components for each\\r\\n     *                          order must have no remainder after multiplying\\r\\n     *                          the respective amount with the supplied fraction\\r\\n     *                          in order for the group of partial fills to be\\r\\n     *                          considered valid.\\r\\n     * @param criteriaResolvers An array where each element contains a reference\\r\\n     *                          to a specific order as well as that order's\\r\\n     *                          offer or consideration, a token identifier, and\\r\\n     *                          a proof that the supplied token identifier is\\r\\n     *                          contained in the order's merkle root. Note that\\r\\n     *                          an empty root indicates that any (transferable)\\r\\n     *                          token identifier is valid and that no associated\\r\\n     *                          proof needs to be supplied.\\r\\n     * @param fulfillments      An array of elements allocating offer components\\r\\n     *                          to consideration components. Note that each\\r\\n     *                          consideration component must be fully met in\\r\\n     *                          order for the match operation to be valid.\\r\\n     *\\r\\n     * @return executions An array of elements indicating the sequence of\\r\\n     *                    transfers performed as part of matching the given\\r\\n     *                    orders.\\r\\n     */\\r\\n    function matchAdvancedOrders(\\r\\n        AdvancedOrder[] calldata orders,\\r\\n        CriteriaResolver[] calldata criteriaResolvers,\\r\\n        Fulfillment[] calldata fulfillments\\r\\n    ) external payable returns (Execution[] memory executions);\\r\\n\\r\\n    /**\\r\\n     * @notice Cancel an arbitrary number of orders. Note that only the offerer\\r\\n     *         or the zone of a given order may cancel it. Callers should ensure\\r\\n     *         that the intended order was cancelled by calling `getOrderStatus`\\r\\n     *         and confirming that `isCancelled` returns `true`.\\r\\n     *\\r\\n     * @param orders The orders to cancel.\\r\\n     *\\r\\n     * @return cancelled A boolean indicating whether the supplied orders have\\r\\n     *                   been successfully cancelled.\\r\\n     */\\r\\n    function cancel(OrderComponents[] calldata orders)\\r\\n        external\\r\\n        returns (bool cancelled);\\r\\n\\r\\n    /**\\r\\n     * @notice Validate an arbitrary number of orders, thereby registering their\\r\\n     *         signatures as valid and allowing the fulfiller to skip signature\\r\\n     *         verification on fulfillment. Note that validated orders may still\\r\\n     *         be unfulfillable due to invalid item amounts or other factors;\\r\\n     *         callers should determine whether validated orders are fulfillable\\r\\n     *         by simulating the fulfillment call prior to execution. Also note\\r\\n     *         that anyone can validate a signed order, but only the offerer can\\r\\n     *         validate an order without supplying a signature.\\r\\n     *\\r\\n     * @param orders The orders to validate.\\r\\n     *\\r\\n     * @return validated A boolean indicating whether the supplied orders have\\r\\n     *                   been successfully validated.\\r\\n     */\\r\\n    function validate(Order[] calldata orders)\\r\\n        external\\r\\n        returns (bool validated);\\r\\n\\r\\n    /**\\r\\n     * @notice Cancel all orders from a given offerer with a given zone in bulk\\r\\n     *         by incrementing a counter. Note that only the offerer may\\r\\n     *         increment the counter.\\r\\n     *\\r\\n     * @return newCounter The new counter.\\r\\n     */\\r\\n    function incrementCounter() external returns (uint256 newCounter);\\r\\n\\r\\n    /**\\r\\n     * @notice Retrieve the order hash for a given order.\\r\\n     *\\r\\n     * @param order The components of the order.\\r\\n     *\\r\\n     * @return orderHash The order hash.\\r\\n     */\\r\\n    function getOrderHash(OrderComponents calldata order)\\r\\n        external\\r\\n        view\\r\\n        returns (bytes32 orderHash);\\r\\n\\r\\n    /**\\r\\n     * @notice Retrieve the status of a given order by hash, including whether\\r\\n     *         the order has been cancelled or validated and the fraction of the\\r\\n     *         order that has been filled.\\r\\n     *\\r\\n     * @param orderHash The order hash in question.\\r\\n     *\\r\\n     * @return isValidated A boolean indicating whether the order in question\\r\\n     *                     has been validated (i.e. previously approved or\\r\\n     *                     partially filled).\\r\\n     * @return isCancelled A boolean indicating whether the order in question\\r\\n     *                     has been cancelled.\\r\\n     * @return totalFilled The total portion of the order that has been filled\\r\\n     *                     (i.e. the \\\"numerator\\\").\\r\\n     * @return totalSize   The total size of the order that is either filled or\\r\\n     *                     unfilled (i.e. the \\\"denominator\\\").\\r\\n     */\\r\\n    function getOrderStatus(bytes32 orderHash)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            bool isValidated,\\r\\n            bool isCancelled,\\r\\n            uint256 totalFilled,\\r\\n            uint256 totalSize\\r\\n        );\\r\\n\\r\\n    /**\\r\\n     * @notice Retrieve the current counter for a given offerer.\\r\\n     *\\r\\n     * @param offerer The offerer in question.\\r\\n     *\\r\\n     * @return counter The current counter.\\r\\n     */\\r\\n    function getCounter(address offerer)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256 counter);\\r\\n\\r\\n    /**\\r\\n     * @notice Retrieve configuration information for this contract.\\r\\n     *\\r\\n     * @return version           The contract version.\\r\\n     * @return domainSeparator   The domain separator for this contract.\\r\\n     * @return conduitController The conduit Controller set for this contract.\\r\\n     */\\r\\n    function information()\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            string memory version,\\r\\n            bytes32 domainSeparator,\\r\\n            address conduitController\\r\\n        );\\r\\n\\r\\n    /**\\r\\n     * @notice Retrieve the name of this contract.\\r\\n     *\\r\\n     * @return contractName The name of this contract.\\r\\n     */\\r\\n    function name() external view returns (string memory contractName);\\r\\n}\\r\\n\",\"keccak256\":\"0x531f3bc1f87d974cd14cea828a1462ccfb5ccbbc54e685d5f85d884c5251ec77\",\"license\":\"MIT\"},\"contracts/interfaces/CriteriaResolutionErrors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.7;\\r\\n\\r\\n/**\\r\\n * @title CriteriaResolutionErrors\\r\\n * @author 0age\\r\\n * @notice CriteriaResolutionErrors contains all errors related to criteria\\r\\n *         resolution.\\r\\n */\\r\\ninterface CriteriaResolutionErrors {\\r\\n    /**\\r\\n     * @dev Revert with an error when providing a criteria resolver that refers\\r\\n     *      to an order that has not been supplied.\\r\\n     */\\r\\n    error OrderCriteriaResolverOutOfRange();\\r\\n\\r\\n    /**\\r\\n     * @dev Revert with an error if an offer item still has unresolved criteria\\r\\n     *      after applying all criteria resolvers.\\r\\n     */\\r\\n    error UnresolvedOfferCriteria();\\r\\n\\r\\n    /**\\r\\n     * @dev Revert with an error if a consideration item still has unresolved\\r\\n     *      criteria after applying all criteria resolvers.\\r\\n     */\\r\\n    error UnresolvedConsiderationCriteria();\\r\\n\\r\\n    /**\\r\\n     * @dev Revert with an error when providing a criteria resolver that refers\\r\\n     *      to an order with an offer item that has not been supplied.\\r\\n     */\\r\\n    error OfferCriteriaResolverOutOfRange();\\r\\n\\r\\n    /**\\r\\n     * @dev Revert with an error when providing a criteria resolver that refers\\r\\n     *      to an order with a consideration item that has not been supplied.\\r\\n     */\\r\\n    error ConsiderationCriteriaResolverOutOfRange();\\r\\n\\r\\n    /**\\r\\n     * @dev Revert with an error when providing a criteria resolver that refers\\r\\n     *      to an order with an item that does not expect a criteria to be\\r\\n     *      resolved.\\r\\n     */\\r\\n    error CriteriaNotEnabledForItem();\\r\\n\\r\\n    /**\\r\\n     * @dev Revert with an error when providing a criteria resolver that\\r\\n     *      contains an invalid proof with respect to the given item and\\r\\n     *      chosen identifier.\\r\\n     */\\r\\n    error InvalidProof();\\r\\n}\\r\\n\",\"keccak256\":\"0x50049204e386d9d26afd09d77c78decbc3662106cfce1e4aeb9c809a4b1ff82d\",\"license\":\"MIT\"},\"contracts/interfaces/EIP1271Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.7;\\r\\n\\r\\ninterface EIP1271Interface {\\r\\n    function isValidSignature(bytes32 digest, bytes calldata signature)\\r\\n        external\\r\\n        view\\r\\n        returns (bytes4);\\r\\n}\\r\\n\",\"keccak256\":\"0x716099c36a4640ad037a292ba6595fe2b031c9fad7ad1c1089c3882cf29bb0f7\",\"license\":\"MIT\"},\"contracts/interfaces/FulfillmentApplicationErrors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.7;\\r\\n\\r\\nimport { Side } from \\\"../lib/ConsiderationEnums.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title FulfillmentApplicationErrors\\r\\n * @author 0age\\r\\n * @notice FulfillmentApplicationErrors contains errors related to fulfillment\\r\\n *         application and aggregation.\\r\\n */\\r\\ninterface FulfillmentApplicationErrors {\\r\\n    /**\\r\\n     * @dev Revert with an error when a fulfillment is provided that does not\\r\\n     *      declare at least one component as part of a call to fulfill\\r\\n     *      available orders.\\r\\n     */\\r\\n    error MissingFulfillmentComponentOnAggregation(Side side);\\r\\n\\r\\n    /**\\r\\n     * @dev Revert with an error when a fulfillment is provided that does not\\r\\n     *      declare at least one offer component and at least one consideration\\r\\n     *      component.\\r\\n     */\\r\\n    error OfferAndConsiderationRequiredOnFulfillment();\\r\\n\\r\\n    /**\\r\\n     * @dev Revert with an error when the initial offer item named by a\\r\\n     *      fulfillment component does not match the type, token, identifier,\\r\\n     *      or conduit preference of the initial consideration item.\\r\\n     */\\r\\n    error MismatchedFulfillmentOfferAndConsiderationComponents();\\r\\n\\r\\n    /**\\r\\n     * @dev Revert with an error when an order or item index are out of range\\r\\n     *      or a fulfillment component does not match the type, token,\\r\\n     *      identifier, or conduit preference of the initial consideration item.\\r\\n     */\\r\\n    error InvalidFulfillmentComponentData();\\r\\n}\\r\\n\",\"keccak256\":\"0x30edaef1f7738ed7ac8b14465452836f539a085eacb2e433701920e64064c7cf\",\"license\":\"MIT\"},\"contracts/interfaces/ReentrancyErrors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.7;\\r\\n\\r\\n/**\\r\\n * @title ReentrancyErrors\\r\\n * @author 0age\\r\\n * @notice ReentrancyErrors contains errors related to reentrancy.\\r\\n */\\r\\ninterface ReentrancyErrors {\\r\\n    /**\\r\\n     * @dev Revert with an error when a caller attempts to reenter a protected\\r\\n     *      function.\\r\\n     */\\r\\n    error NoReentrantCalls();\\r\\n}\\r\\n\",\"keccak256\":\"0x34a50389d43b6182221e2043e5db73a96b9793176023362f575740ba13f794f4\",\"license\":\"MIT\"},\"contracts/interfaces/SignatureVerificationErrors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.7;\\r\\n\\r\\n/**\\r\\n * @title SignatureVerificationErrors\\r\\n * @author 0age\\r\\n * @notice SignatureVerificationErrors contains all errors related to signature\\r\\n *         verification.\\r\\n */\\r\\ninterface SignatureVerificationErrors {\\r\\n    /**\\r\\n     * @dev Revert with an error when a signature that does not contain a v\\r\\n     *      value of 27 or 28 has been supplied.\\r\\n     *\\r\\n     * @param v The invalid v value.\\r\\n     */\\r\\n    error BadSignatureV(uint8 v);\\r\\n\\r\\n    /**\\r\\n     * @dev Revert with an error when the signer recovered by the supplied\\r\\n     *      signature does not match the offerer or an allowed EIP-1271 signer\\r\\n     *      as specified by the offerer in the event they are a contract.\\r\\n     */\\r\\n    error InvalidSigner();\\r\\n\\r\\n    /**\\r\\n     * @dev Revert with an error when a signer cannot be recovered from the\\r\\n     *      supplied signature.\\r\\n     */\\r\\n    error InvalidSignature();\\r\\n\\r\\n    /**\\r\\n     * @dev Revert with an error when an EIP-1271 call to an account fails.\\r\\n     */\\r\\n    error BadContractSignature();\\r\\n}\\r\\n\",\"keccak256\":\"0x8f01078f8c5ff84976a3f9ef93d2b1204b0049255d28fc529829f60f7813c6b4\",\"license\":\"MIT\"},\"contracts/interfaces/TokenTransferrerErrors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.7;\\r\\n\\r\\n/**\\r\\n * @title TokenTransferrerErrors\\r\\n */\\r\\ninterface TokenTransferrerErrors {\\r\\n    /**\\r\\n     * @dev Revert with an error when an ERC721 transfer with amount other than\\r\\n     *      one is attempted.\\r\\n     */\\r\\n    error InvalidERC721TransferAmount();\\r\\n\\r\\n    /**\\r\\n     * @dev Revert with an error when attempting to fulfill an order where an\\r\\n     *      item has an amount of zero.\\r\\n     */\\r\\n    error MissingItemAmount();\\r\\n\\r\\n    /**\\r\\n     * @dev Revert with an error when attempting to fulfill an order where an\\r\\n     *      item has unused parameters. This includes both the token and the\\r\\n     *      identifier parameters for native transfers as well as the identifier\\r\\n     *      parameter for ERC20 transfers. Note that the conduit does not\\r\\n     *      perform this check, leaving it up to the calling channel to enforce\\r\\n     *      when desired.\\r\\n     */\\r\\n    error UnusedItemParameters();\\r\\n\\r\\n    /**\\r\\n     * @dev Revert with an error when an ERC20, ERC721, or ERC1155 token\\r\\n     *      transfer reverts.\\r\\n     *\\r\\n     * @param token      The token for which the transfer was attempted.\\r\\n     * @param from       The source of the attempted transfer.\\r\\n     * @param to         The recipient of the attempted transfer.\\r\\n     * @param identifier The identifier for the attempted transfer.\\r\\n     * @param amount     The amount for the attempted transfer.\\r\\n     */\\r\\n    error TokenTransferGenericFailure(\\r\\n        address token,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 identifier,\\r\\n        uint256 amount\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Revert with an error when a batch ERC1155 token transfer reverts.\\r\\n     *\\r\\n     * @param token       The token for which the transfer was attempted.\\r\\n     * @param from        The source of the attempted transfer.\\r\\n     * @param to          The recipient of the attempted transfer.\\r\\n     * @param identifiers The identifiers for the attempted transfer.\\r\\n     * @param amounts     The amounts for the attempted transfer.\\r\\n     */\\r\\n    error ERC1155BatchTransferGenericFailure(\\r\\n        address token,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256[] identifiers,\\r\\n        uint256[] amounts\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Revert with an error when an ERC20 token transfer returns a falsey\\r\\n     *      value.\\r\\n     *\\r\\n     * @param token      The token for which the ERC20 transfer was attempted.\\r\\n     * @param from       The source of the attempted ERC20 transfer.\\r\\n     * @param to         The recipient of the attempted ERC20 transfer.\\r\\n     * @param amount     The amount for the attempted ERC20 transfer.\\r\\n     */\\r\\n    error BadReturnValueFromERC20OnTransfer(\\r\\n        address token,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Revert with an error when an account being called as an assumed\\r\\n     *      contract does not have code and returns no data.\\r\\n     *\\r\\n     * @param account The account that should contain code.\\r\\n     */\\r\\n    error NoContract(address account);\\r\\n\\r\\n    /**\\r\\n     * @dev Revert with an error when attempting to execute an 1155 batch\\r\\n     *      transfer using calldata not produced by default ABI encoding or with\\r\\n     *      different lengths for ids and amounts arrays.\\r\\n     */\\r\\n    error Invalid1155BatchTransferEncoding();\\r\\n}\\r\\n\",\"keccak256\":\"0xa1d6d753c1129e2fd1c342ddb653d37c75d1e1c54a51d37ef5999af465889576\",\"license\":\"MIT\"},\"contracts/interfaces/ZoneInteractionErrors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.7;\\r\\n\\r\\n/**\\r\\n * @title ZoneInteractionErrors\\r\\n * @author 0age\\r\\n * @notice ZoneInteractionErrors contains errors related to zone interaction.\\r\\n */\\r\\ninterface ZoneInteractionErrors {\\r\\n    /**\\r\\n     * @dev Revert with an error when attempting to fill an order that specifies\\r\\n     *      a restricted submitter as its order type when not submitted by\\r\\n     *      either the offerer or the order's zone or approved as valid by the\\r\\n     *      zone in question via a staticcall to `isValidOrder`.\\r\\n     *\\r\\n     * @param orderHash The order hash for the invalid restricted order.\\r\\n     */\\r\\n    error InvalidRestrictedOrder(bytes32 orderHash);\\r\\n}\\r\\n\",\"keccak256\":\"0xe79e1de9ab67e073fd3e56767824cf57c5246b030aae9340a3d93167703f3fcb\",\"license\":\"MIT\"},\"contracts/interfaces/ZoneInterface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.7;\\r\\n\\r\\n// prettier-ignore\\r\\nimport {\\r\\n    AdvancedOrder,\\r\\n    CriteriaResolver\\r\\n} from \\\"../lib/ConsiderationStructs.sol\\\";\\r\\n\\r\\ninterface ZoneInterface {\\r\\n    // Called by Consideration whenever extraData is not provided by the caller.\\r\\n    function isValidOrder(\\r\\n        bytes32 orderHash,\\r\\n        address caller,\\r\\n        address offerer,\\r\\n        bytes32 zoneHash\\r\\n    ) external view returns (bytes4 validOrderMagicValue);\\r\\n\\r\\n    // Called by Consideration whenever any extraData is provided by the caller.\\r\\n    function isValidOrderIncludingExtraData(\\r\\n        bytes32 orderHash,\\r\\n        address caller,\\r\\n        AdvancedOrder calldata order,\\r\\n        bytes32[] calldata priorOrderHashes,\\r\\n        CriteriaResolver[] calldata criteriaResolvers\\r\\n    ) external view returns (bytes4 validOrderMagicValue);\\r\\n}\\r\\n\",\"keccak256\":\"0x6610c29ece4e92a36a09a8ca9f1e1a1d9c2883b6e06f67c18e024afa9e01d881\",\"license\":\"MIT\"},\"contracts/lib/AmountDeriver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.13;\\r\\n\\r\\n// prettier-ignore\\r\\nimport {\\r\\n    AmountDerivationErrors\\r\\n} from \\\"../interfaces/AmountDerivationErrors.sol\\\";\\r\\n\\r\\nimport \\\"./ConsiderationConstants.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title AmountDeriver\\r\\n * @author 0age\\r\\n * @notice AmountDeriver contains view and pure functions related to deriving\\r\\n *         item amounts based on partial fill quantity and on linear\\r\\n *         interpolation based on current time when the start amount and end\\r\\n *         amount differ.\\r\\n */\\r\\ncontract AmountDeriver is AmountDerivationErrors {\\r\\n\\r\\n    /**\\r\\n     * @dev Internal view function to derive the current amount of a given item\\r\\n     *      based on the current price, the starting price, and the ending\\r\\n     *      price. If the start and end prices differ, the current price will be\\r\\n     *      interpolated on a linear basis. Note that this function expects that\\r\\n     *      the startTime parameter of orderParameters is not greater than the\\r\\n     *      current block timestamp and that the endTime parameter is greater\\r\\n     *      than the current block timestamp. If this condition is not upheld,\\r\\n     *      duration / elapsed / remaining variables will underflow.\\r\\n     *\\r\\n     * @param startAmount The starting amount of the item.\\r\\n     * @param endAmount   The ending amount of the item.\\r\\n     * @param startTime   The starting time of the order.\\r\\n     * @param endTime     The end time of the order.\\r\\n     * @param roundUp     A boolean indicating whether the resultant amount\\r\\n     *                    should be rounded up or down.\\r\\n     *\\r\\n     * @return amount The current amount.\\r\\n     */\\r\\n    function _locateCurrentAmount(\\r\\n        uint256 startAmount,\\r\\n        uint256 endAmount,\\r\\n        uint256 startTime,\\r\\n        uint256 endTime,\\r\\n        bool roundUp\\r\\n    ) internal view returns (uint256 amount) {\\r\\n        // Only modify end amount if it doesn't already equal start amount.\\r\\n        if (startAmount != endAmount) {\\r\\n            // Declare variables to derive in the subsequent unchecked scope.\\r\\n            uint256 duration;\\r\\n            uint256 elapsed;\\r\\n            uint256 remaining;\\r\\n\\r\\n            // Skip underflow checks as startTime <= block.timestamp < endTime.\\r\\n            unchecked {\\r\\n                // Derive the duration for the order and place it on the stack.\\r\\n                duration = endTime - startTime;\\r\\n\\r\\n                // Derive time elapsed since the order started & place on stack.\\r\\n                elapsed = block.timestamp - startTime;\\r\\n\\r\\n                // Derive time remaining until order expires and place on stack.\\r\\n                remaining = duration - elapsed;\\r\\n            }\\r\\n\\r\\n            // Aggregate new amounts weighted by time with rounding factor.\\r\\n            uint256 totalBeforeDivision = ((startAmount * remaining) +\\r\\n                (endAmount * elapsed));\\r\\n\\r\\n            // Use assembly to combine operations and skip divide-by-zero check.\\r\\n            assembly {\\r\\n                // Multiply by iszero(iszero(totalBeforeDivision)) to ensure\\r\\n                // amount is set to zero if totalBeforeDivision is zero,\\r\\n                // as intermediate overflow can occur if it is zero.\\r\\n                amount := mul(\\r\\n                    iszero(iszero(totalBeforeDivision)),\\r\\n                    // Subtract 1 from the numerator and add 1 to the result if\\r\\n                    // roundUp is true to get the proper rounding direction.\\r\\n                    // Division is performed with no zero check as duration\\r\\n                    // cannot be zero as long as startTime < endTime.\\r\\n                    add(\\r\\n                        div(sub(totalBeforeDivision, roundUp), duration),\\r\\n                        roundUp\\r\\n                    )\\r\\n                )\\r\\n            }\\r\\n\\r\\n            // Return the current amount.\\r\\n            return amount;\\r\\n        }\\r\\n\\r\\n        // Return the original amount as startAmount == endAmount.\\r\\n        return endAmount;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal pure function to return a fraction of a given value and to\\r\\n     *      ensure the resultant value does not have any fractional component.\\r\\n     *      Note that this function assumes that zero will never be supplied as\\r\\n     *      the denominator parameter; invalid / undefined behavior will result\\r\\n     *      should a denominator of zero be provided.\\r\\n     *\\r\\n     * @param numerator   A value indicating the portion of the order that\\r\\n     *                    should be filled.\\r\\n     * @param denominator A value indicating the total size of the order. Note\\r\\n     *                    that this value cannot be equal to zero.\\r\\n     * @param value       The value for which to compute the fraction.\\r\\n     *\\r\\n     * @return newValue The value after applying the fraction.\\r\\n     */\\r\\n    function _getFraction(\\r\\n        uint256 numerator,\\r\\n        uint256 denominator,\\r\\n        uint256 value\\r\\n    ) internal pure returns (uint256 newValue) {\\r\\n        // Return value early in cases where the fraction resolves to 1.\\r\\n        if (numerator == denominator) {\\r\\n            return value;\\r\\n        }\\r\\n\\r\\n        // Ensure fraction can be applied to the value with no remainder. Note\\r\\n        // that the denominator cannot be zero.\\r\\n        assembly {\\r\\n            // Ensure new value contains no remainder via mulmod operator.\\r\\n            // Credit to @hrkrshnn + @axic for proposing this optimal solution.\\r\\n            if mulmod(value, numerator, denominator) {\\r\\n                mstore(0, InexactFraction_error_signature)\\r\\n                revert(0, InexactFraction_error_len)\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Multiply the numerator by the value and ensure no overflow occurs.\\r\\n        uint256 valueTimesNumerator = value * numerator;\\r\\n\\r\\n        // Divide and check for remainder. Note that denominator cannot be zero.\\r\\n        assembly {\\r\\n            // Perform division without zero check.\\r\\n            newValue := div(valueTimesNumerator, denominator)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal view function to apply a fraction to a consideration\\r\\n     * or offer item.\\r\\n     *\\r\\n     * @param startAmount     The starting amount of the item.\\r\\n     * @param endAmount       The ending amount of the item.\\r\\n     * @param numerator       A value indicating the portion of the order that\\r\\n     *                        should be filled.\\r\\n     * @param denominator     A value indicating the total size of the order.\\r\\n     * @param startTime       The starting time of the order.\\r\\n     * @param endTime         The end time of the order.\\r\\n     * @param roundUp         A boolean indicating whether the resultant\\r\\n     *                        amount should be rounded up or down.\\r\\n     *\\r\\n     * @return amount The received item to transfer with the final amount.\\r\\n     */\\r\\n    function _applyFraction(\\r\\n        uint256 startAmount,\\r\\n        uint256 endAmount,\\r\\n        uint256 numerator,\\r\\n        uint256 denominator,\\r\\n        uint256 startTime,\\r\\n        uint256 endTime,\\r\\n        bool roundUp\\r\\n    ) internal view returns (uint256 amount) {\\r\\n        // If start amount equals end amount, apply fraction to end amount.\\r\\n        if (startAmount == endAmount) {\\r\\n            // Apply fraction to end amount.\\r\\n            amount = _getFraction(numerator, denominator, endAmount);\\r\\n        } else {\\r\\n            // Otherwise, apply fraction to both and interpolated final amount.\\r\\n            amount = _locateCurrentAmount(\\r\\n                _getFraction(numerator, denominator, startAmount),\\r\\n                _getFraction(numerator, denominator, endAmount),\\r\\n                startTime,\\r\\n                endTime,\\r\\n                roundUp\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x37ab0810e3d319960e52fab4812d2985a22c11450824e29647b29522071a1377\",\"license\":\"MIT\"},\"contracts/lib/Assertions.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.13;\\r\\n\\r\\nimport { OrderParameters } from \\\"./ConsiderationStructs.sol\\\";\\r\\n\\r\\nimport { GettersAndDerivers } from \\\"./GettersAndDerivers.sol\\\";\\r\\n\\r\\n// prettier-ignore\\r\\nimport {\\r\\n    TokenTransferrerErrors\\r\\n} from \\\"../interfaces/TokenTransferrerErrors.sol\\\";\\r\\n\\r\\nimport { CounterManager } from \\\"./CounterManager.sol\\\";\\r\\n\\r\\nimport \\\"./ConsiderationConstants.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Assertions\\r\\n * @author 0age\\r\\n * @notice Assertions contains logic for making various assertions that do not\\r\\n *         fit neatly within a dedicated semantic scope.\\r\\n */\\r\\ncontract Assertions is\\r\\n    GettersAndDerivers,\\r\\n    CounterManager,\\r\\n    TokenTransferrerErrors\\r\\n{\\r\\n    /**\\r\\n     * @dev Derive and set hashes, reference chainId, and associated domain\\r\\n     *      separator during deployment.\\r\\n     *\\r\\n     * @param conduitController A contract that deploys conduits, or proxies\\r\\n     *                          that may optionally be used to transfer approved\\r\\n     *                          ERC20/721/1155 tokens.\\r\\n     */\\r\\n    constructor(address conduitController)\\r\\n        GettersAndDerivers(conduitController)\\r\\n    {}\\r\\n\\r\\n    /**\\r\\n     * @dev Internal view function to ensure that the supplied consideration\\r\\n     *      array length on a given set of order parameters is not less than the\\r\\n     *      original consideration array length for that order and to retrieve\\r\\n     *      the current counter for a given order's offerer and zone and use it\\r\\n     *      to derive the order hash.\\r\\n     *\\r\\n     * @param orderParameters The parameters of the order to hash.\\r\\n     *\\r\\n     * @return The hash.\\r\\n     */\\r\\n    function _assertConsiderationLengthAndGetOrderHash(\\r\\n        OrderParameters memory orderParameters\\r\\n    ) internal view returns (bytes32) {\\r\\n        // Ensure supplied consideration array length is not less than original.\\r\\n        _assertConsiderationLengthIsNotLessThanOriginalConsiderationLength(\\r\\n            orderParameters.consideration.length,\\r\\n            orderParameters.totalOriginalConsiderationItems\\r\\n        );\\r\\n\\r\\n        // Derive and return order hash using current counter for the offerer.\\r\\n        return\\r\\n            _deriveOrderHash(\\r\\n                orderParameters,\\r\\n                _getCounter(orderParameters.offerer)\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal pure function to ensure that the supplied consideration\\r\\n     *      array length for an order to be fulfilled is not less than the\\r\\n     *      original consideration array length for that order.\\r\\n     *\\r\\n     * @param suppliedConsiderationItemTotal The number of consideration items\\r\\n     *                                       supplied when fulfilling the order.\\r\\n     * @param originalConsiderationItemTotal The number of consideration items\\r\\n     *                                       supplied on initial order creation.\\r\\n     */\\r\\n    function _assertConsiderationLengthIsNotLessThanOriginalConsiderationLength(\\r\\n        uint256 suppliedConsiderationItemTotal,\\r\\n        uint256 originalConsiderationItemTotal\\r\\n    ) internal pure {\\r\\n        // Ensure supplied consideration array length is not less than original.\\r\\n        if (suppliedConsiderationItemTotal < originalConsiderationItemTotal) {\\r\\n            revert MissingOriginalConsiderationItems();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal pure function to ensure that a given item amount is not\\r\\n     *      zero.\\r\\n     *\\r\\n     * @param amount The amount to check.\\r\\n     */\\r\\n    function _assertNonZeroAmount(uint256 amount) internal pure {\\r\\n        // Revert if the supplied amount is equal to zero.\\r\\n        if (amount == 0) {\\r\\n            revert MissingItemAmount();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal pure function to validate calldata offsets for dynamic\\r\\n     *      types in BasicOrderParameters and other parameters. This ensures\\r\\n     *      that functions using the calldata object normally will be using the\\r\\n     *      same data as the assembly functions and that values that are bound\\r\\n     *      to a given range are within that range. Note that no parameters are\\r\\n     *      supplied as all basic order functions use the same calldata\\r\\n     *      encoding.\\r\\n     */\\r\\n    function _assertValidBasicOrderParameters() internal pure {\\r\\n        // Declare a boolean designating basic order parameter offset validity.\\r\\n        bool validOffsets;\\r\\n\\r\\n        // Utilize assembly in order to read offset data directly from calldata.\\r\\n        assembly {\\r\\n            /*\\r\\n             * Checks:\\r\\n             * 1. Order parameters struct offset == 0x20\\r\\n             * 2. Additional recipients arr offset == 0x240\\r\\n             * 3. Signature offset == 0x260 + (recipients.length * 0x40)\\r\\n             * 4. BasicOrderType between 0 and 23 (i.e. < 24)\\r\\n             */\\r\\n            validOffsets := and(\\r\\n                // Order parameters at calldata 0x04 must have offset of 0x20.\\r\\n                eq(\\r\\n                    calldataload(BasicOrder_parameters_cdPtr),\\r\\n                    BasicOrder_parameters_ptr\\r\\n                ),\\r\\n                // Additional recipients at cd 0x224 must have offset of 0x240.\\r\\n                eq(\\r\\n                    calldataload(BasicOrder_additionalRecipients_head_cdPtr),\\r\\n                    BasicOrder_additionalRecipients_head_ptr\\r\\n                )\\r\\n            )\\r\\n\\r\\n            validOffsets := and(\\r\\n                validOffsets,\\r\\n                eq(\\r\\n                    // Load signature offset from calldata 0x244.\\r\\n                    calldataload(BasicOrder_signature_cdPtr),\\r\\n                    // Derive expected offset as start of recipients + len * 64.\\r\\n                    add(\\r\\n                        BasicOrder_signature_ptr,\\r\\n                        mul(\\r\\n                            // Additional recipients length at calldata 0x264.\\r\\n                            calldataload(\\r\\n                                BasicOrder_additionalRecipients_length_cdPtr\\r\\n                            ),\\r\\n                            // Each additional recipient has a length of 0x40.\\r\\n                            AdditionalRecipients_size\\r\\n                        )\\r\\n                    )\\r\\n                )\\r\\n            )\\r\\n\\r\\n            validOffsets := and(\\r\\n                validOffsets,\\r\\n                lt(\\r\\n                    // BasicOrderType parameter at calldata offset 0x124.\\r\\n                    calldataload(BasicOrder_basicOrderType_cdPtr),\\r\\n                    // Value should be less than 24.\\r\\n                    BasicOrder_basicOrderType_range\\r\\n                )\\r\\n            )\\r\\n        }\\r\\n\\r\\n        // Revert with an error if basic order parameter offsets are invalid.\\r\\n        if (!validOffsets) {\\r\\n            revert InvalidBasicOrderParameterEncoding();\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xaaed85da7082fa2ce05adcea731ca3db890f1a6d7da9dde41b0aadcc8393d895\",\"license\":\"MIT\"},\"contracts/lib/BasicOrderFulfiller.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.13;\\r\\n\\r\\nimport { ConduitInterface } from \\\"../interfaces/ConduitInterface.sol\\\";\\r\\n\\r\\n// prettier-ignore\\r\\nimport {\\r\\n    OrderType,\\r\\n    ItemType,\\r\\n    BasicOrderRouteType\\r\\n} from \\\"./ConsiderationEnums.sol\\\";\\r\\n\\r\\n// prettier-ignore\\r\\nimport {\\r\\n    AdditionalRecipient,\\r\\n    BasicOrderParameters,\\r\\n    OfferItem,\\r\\n    ConsiderationItem,\\r\\n    SpentItem,\\r\\n    ReceivedItem\\r\\n} from \\\"./ConsiderationStructs.sol\\\";\\r\\n\\r\\nimport { OrderValidator } from \\\"./OrderValidator.sol\\\";\\r\\n\\r\\nimport \\\"./ConsiderationConstants.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title BasicOrderFulfiller\\r\\n * @author 0age\\r\\n * @notice BasicOrderFulfiller contains functionality for fulfilling \\\"basic\\\"\\r\\n *         orders with minimal overhead. See documentation for details on what\\r\\n *         qualifies as a basic order.\\r\\n */\\r\\ncontract BasicOrderFulfiller is OrderValidator {\\r\\n    /**\\r\\n     * @dev Derive and set hashes, reference chainId, and associated domain\\r\\n     *      separator during deployment.\\r\\n     *\\r\\n     * @param conduitController A contract that deploys conduits, or proxies\\r\\n     *                          that may optionally be used to transfer approved\\r\\n     *                          ERC20/721/1155 tokens.\\r\\n     */\\r\\n    constructor(address conduitController) OrderValidator(conduitController) {}\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to fulfill an order offering an ERC20, ERC721, or\\r\\n     *      ERC1155 item by supplying Ether (or other native tokens), ERC20\\r\\n     *      tokens, an ERC721 item, or an ERC1155 item as consideration. Six\\r\\n     *      permutations are supported: Native token to ERC721, Native token to\\r\\n     *      ERC1155, ERC20 to ERC721, ERC20 to ERC1155, ERC721 to ERC20, and\\r\\n     *      ERC1155 to ERC20 (with native tokens supplied as msg.value). For an\\r\\n     *      order to be eligible for fulfillment via this method, it must\\r\\n     *      contain a single offer item (though that item may have a greater\\r\\n     *      amount if the item is not an ERC721). An arbitrary number of\\r\\n     *      \\\"additional recipients\\\" may also be supplied which will each receive\\r\\n     *      native tokens or ERC20 items from the fulfiller as consideration.\\r\\n     *      Refer to the documentation for a more comprehensive summary of how\\r\\n     *      to utilize this method and what orders are compatible with it.\\r\\n     *\\r\\n     * @param parameters Additional information on the fulfilled order. Note\\r\\n     *                   that the offerer and the fulfiller must first approve\\r\\n     *                   this contract (or their chosen conduit if indicated)\\r\\n     *                   before any tokens can be transferred. Also note that\\r\\n     *                   contract recipients of ERC1155 consideration items must\\r\\n     *                   implement `onERC1155Received` in order to receive those\\r\\n     *                   items.\\r\\n     *\\r\\n     * @return A boolean indicating whether the order has been fulfilled.\\r\\n     */\\r\\n    function _validateAndFulfillBasicOrder(\\r\\n        BasicOrderParameters calldata parameters\\r\\n    ) internal returns (bool) {\\r\\n        // Declare enums for order type & route to extract from basicOrderType.\\r\\n        BasicOrderRouteType route;\\r\\n        OrderType orderType;\\r\\n\\r\\n        // Declare additional recipient item type to derive from the route type.\\r\\n        ItemType additionalRecipientsItemType;\\r\\n\\r\\n        // Utilize assembly to extract the order type and the basic order route.\\r\\n        assembly {\\r\\n            // Read basicOrderType from calldata.\\r\\n            let basicOrderType := calldataload(BasicOrder_basicOrderType_cdPtr)\\r\\n\\r\\n            // Mask all but 2 least-significant bits to derive the order type.\\r\\n            orderType := and(basicOrderType, 3)\\r\\n\\r\\n            // Divide basicOrderType by four to derive the route.\\r\\n            route := shr(2, basicOrderType)\\r\\n\\r\\n            // If route > 1 additionalRecipient items are ERC20 (1) else Eth (0)\\r\\n            additionalRecipientsItemType := gt(route, 1)\\r\\n        }\\r\\n\\r\\n        {\\r\\n            // Declare temporary variable for enforcing payable status.\\r\\n            bool correctPayableStatus;\\r\\n\\r\\n            // Utilize assembly to compare the route to the callvalue.\\r\\n            assembly {\\r\\n                // route 0 and 1 are payable, otherwise route is not payable.\\r\\n                correctPayableStatus := eq(\\r\\n                    additionalRecipientsItemType,\\r\\n                    iszero(callvalue())\\r\\n                )\\r\\n            }\\r\\n\\r\\n            // Revert if msg.value has not been supplied as part of payable\\r\\n            // routes or has been supplied as part of non-payable routes.\\r\\n            if (!correctPayableStatus) {\\r\\n                revert InvalidMsgValue(msg.value);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Declare more arguments that will be derived from route and calldata.\\r\\n        address additionalRecipientsToken;\\r\\n        ItemType offeredItemType;\\r\\n        bool offerTypeIsAdditionalRecipientsType;\\r\\n\\r\\n        // Declare scope for received item type to manage stack pressure.\\r\\n        {\\r\\n            ItemType receivedItemType;\\r\\n\\r\\n            // Utilize assembly to retrieve function arguments and cast types.\\r\\n            assembly {\\r\\n                // Check if offered item type == additional recipient item type.\\r\\n                offerTypeIsAdditionalRecipientsType := gt(route, 3)\\r\\n\\r\\n                // If route > 3 additionalRecipientsToken is at 0xc4 else 0x24.\\r\\n                additionalRecipientsToken := calldataload(\\r\\n                    add(\\r\\n                        BasicOrder_considerationToken_cdPtr,\\r\\n                        mul(\\r\\n                            offerTypeIsAdditionalRecipientsType,\\r\\n                            BasicOrder_common_params_size\\r\\n                        )\\r\\n                    )\\r\\n                )\\r\\n\\r\\n                // If route > 2, receivedItemType is route - 2. If route is 2,\\r\\n                // the receivedItemType is ERC20 (1). Otherwise, it is Eth (0).\\r\\n                receivedItemType := add(\\r\\n                    mul(sub(route, 2), gt(route, 2)),\\r\\n                    eq(route, 2)\\r\\n                )\\r\\n\\r\\n                // If route > 3, offeredItemType is ERC20 (1). Route is 2 or 3,\\r\\n                // offeredItemType = route. Route is 0 or 1, it is route + 2.\\r\\n                offeredItemType := sub(\\r\\n                    add(route, mul(iszero(additionalRecipientsItemType), 2)),\\r\\n                    mul(\\r\\n                        offerTypeIsAdditionalRecipientsType,\\r\\n                        add(receivedItemType, 1)\\r\\n                    )\\r\\n                )\\r\\n            }\\r\\n\\r\\n            // Derive & validate order using parameters and update order status.\\r\\n            _prepareBasicFulfillmentFromCalldata(\\r\\n                parameters,\\r\\n                orderType,\\r\\n                receivedItemType,\\r\\n                additionalRecipientsItemType,\\r\\n                additionalRecipientsToken,\\r\\n                offeredItemType\\r\\n            );\\r\\n        }\\r\\n\\r\\n        // Declare conduitKey argument used by transfer functions.\\r\\n        bytes32 conduitKey;\\r\\n\\r\\n        // Utilize assembly to derive conduit (if relevant) based on route.\\r\\n        assembly {\\r\\n            // use offerer conduit for routes 0-3, fulfiller conduit otherwise.\\r\\n            conduitKey := calldataload(\\r\\n                add(\\r\\n                    BasicOrder_offererConduit_cdPtr,\\r\\n                    mul(offerTypeIsAdditionalRecipientsType, OneWord)\\r\\n                )\\r\\n            )\\r\\n        }\\r\\n\\r\\n        // Transfer tokens based on the route.\\r\\n        if (additionalRecipientsItemType == ItemType.NATIVE) {\\r\\n            // Ensure neither the token nor the identifier parameters are set.\\r\\n            if (\\r\\n                (uint160(parameters.considerationToken) |\\r\\n                    parameters.considerationIdentifier) != 0\\r\\n            ) {\\r\\n                revert UnusedItemParameters();\\r\\n            }\\r\\n\\r\\n            // Transfer the ERC721 or ERC1155 item, bypassing the accumulator.\\r\\n            _transferIndividual721Or1155Item(\\r\\n                offeredItemType,\\r\\n                parameters.offerToken,\\r\\n                parameters.offerer,\\r\\n                msg.sender,\\r\\n                parameters.offerIdentifier,\\r\\n                parameters.offerAmount,\\r\\n                conduitKey\\r\\n            );\\r\\n\\r\\n            // Transfer native to recipients, return excess to caller & wrap up.\\r\\n            _transferEthAndFinalize(\\r\\n                parameters.considerationAmount,\\r\\n                parameters.offerer,\\r\\n                parameters.additionalRecipients\\r\\n            );\\r\\n        } else {\\r\\n            // Initialize an accumulator array. From this point forward, no new\\r\\n            // memory regions can be safely allocated until the accumulator is\\r\\n            // no longer being utilized, as the accumulator operates in an\\r\\n            // open-ended fashion from this memory pointer; existing memory may\\r\\n            // still be accessed and modified, however.\\r\\n            bytes memory accumulator = new bytes(AccumulatorDisarmed);\\r\\n\\r\\n            // Choose transfer method for ERC721 or ERC1155 item based on route.\\r\\n            if (route == BasicOrderRouteType.ERC20_TO_ERC721) {\\r\\n                // Transfer ERC721 to caller using offerer's conduit preference.\\r\\n                _transferERC721(\\r\\n                    parameters.offerToken,\\r\\n                    parameters.offerer,\\r\\n                    msg.sender,\\r\\n                    parameters.offerIdentifier,\\r\\n                    parameters.offerAmount,\\r\\n                    conduitKey,\\r\\n                    accumulator\\r\\n                );\\r\\n            } else if (route == BasicOrderRouteType.ERC20_TO_ERC1155) {\\r\\n                // Transfer ERC1155 to caller with offerer's conduit preference.\\r\\n                _transferERC1155(\\r\\n                    parameters.offerToken,\\r\\n                    parameters.offerer,\\r\\n                    msg.sender,\\r\\n                    parameters.offerIdentifier,\\r\\n                    parameters.offerAmount,\\r\\n                    conduitKey,\\r\\n                    accumulator\\r\\n                );\\r\\n            } else if (route == BasicOrderRouteType.ERC721_TO_ERC20) {\\r\\n                // Transfer ERC721 to offerer using caller's conduit preference.\\r\\n                _transferERC721(\\r\\n                    parameters.considerationToken,\\r\\n                    msg.sender,\\r\\n                    parameters.offerer,\\r\\n                    parameters.considerationIdentifier,\\r\\n                    parameters.considerationAmount,\\r\\n                    conduitKey,\\r\\n                    accumulator\\r\\n                );\\r\\n            } else {\\r\\n                // route == BasicOrderRouteType.ERC1155_TO_ERC20\\r\\n\\r\\n                // Transfer ERC1155 to offerer with caller's conduit preference.\\r\\n                _transferERC1155(\\r\\n                    parameters.considerationToken,\\r\\n                    msg.sender,\\r\\n                    parameters.offerer,\\r\\n                    parameters.considerationIdentifier,\\r\\n                    parameters.considerationAmount,\\r\\n                    conduitKey,\\r\\n                    accumulator\\r\\n                );\\r\\n            }\\r\\n\\r\\n            // Transfer ERC20 tokens to all recipients and wrap up.\\r\\n            _transferERC20AndFinalize(\\r\\n                parameters.offerer,\\r\\n                parameters,\\r\\n                offerTypeIsAdditionalRecipientsType,\\r\\n                accumulator\\r\\n            );\\r\\n\\r\\n            // Trigger any remaining accumulated transfers via call to conduit.\\r\\n            _triggerIfArmed(accumulator);\\r\\n        }\\r\\n\\r\\n        // Clear the reentrancy guard.\\r\\n        _clearReentrancyGuard();\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to prepare fulfillment of a basic order with\\r\\n     *      manual calldata and memory access. This calculates the order hash,\\r\\n     *      emits an OrderFulfilled event, and asserts basic order validity.\\r\\n     *      Note that calldata offsets must be validated as this function\\r\\n     *      accesses constant calldata pointers for dynamic types that match\\r\\n     *      default ABI encoding, but valid ABI encoding can use arbitrary\\r\\n     *      offsets. Checking that the offsets were produced by default encoding\\r\\n     *      will ensure that other functions using Solidity's calldata accessors\\r\\n     *      (which calculate pointers from the stored offsets) are reading the\\r\\n     *      same data as the order hash is derived from. Also note that This\\r\\n     *      function accesses memory directly. It does not clear the expanded\\r\\n     *      memory regions used, nor does it update the free memory pointer, so\\r\\n     *      other direct memory access must not assume that unused memory is\\r\\n     *      empty.\\r\\n     *\\r\\n     * @param parameters                   The parameters of the basic order.\\r\\n     * @param orderType                    The order type.\\r\\n     * @param receivedItemType             The item type of the initial\\r\\n     *                                     consideration item on the order.\\r\\n     * @param additionalRecipientsItemType The item type of any additional\\r\\n     *                                     consideration item on the order.\\r\\n     * @param additionalRecipientsToken    The ERC20 token contract address (if\\r\\n     *                                     applicable) for any additional\\r\\n     *                                     consideration item on the order.\\r\\n     * @param offeredItemType              The item type of the offered item on\\r\\n     *                                     the order.\\r\\n     */\\r\\n    function _prepareBasicFulfillmentFromCalldata(\\r\\n        BasicOrderParameters calldata parameters,\\r\\n        OrderType orderType,\\r\\n        ItemType receivedItemType,\\r\\n        ItemType additionalRecipientsItemType,\\r\\n        address additionalRecipientsToken,\\r\\n        ItemType offeredItemType\\r\\n    ) internal {\\r\\n        // Ensure this function cannot be triggered during a reentrant call.\\r\\n        _setReentrancyGuard();\\r\\n\\r\\n        // Ensure current timestamp falls between order start time and end time.\\r\\n        _verifyTime(parameters.startTime, parameters.endTime, true);\\r\\n\\r\\n        // Verify that calldata offsets for all dynamic types were produced by\\r\\n        // default encoding. This ensures that the constants we use for calldata\\r\\n        // pointers to dynamic types are the same as those calculated by\\r\\n        // Solidity using their offsets. Also verify that the basic order type\\r\\n        // is within range.\\r\\n        _assertValidBasicOrderParameters();\\r\\n\\r\\n        // Ensure supplied consideration array length is not less than original.\\r\\n        _assertConsiderationLengthIsNotLessThanOriginalConsiderationLength(\\r\\n            parameters.additionalRecipients.length,\\r\\n            parameters.totalOriginalAdditionalRecipients\\r\\n        );\\r\\n\\r\\n        // Declare stack element for the order hash.\\r\\n        bytes32 orderHash;\\r\\n\\r\\n        {\\r\\n            /**\\r\\n             * First, handle consideration items. Memory Layout:\\r\\n             *  0x60: final hash of the array of consideration item hashes\\r\\n             *  0x80-0x160: reused space for EIP712 hashing of each item\\r\\n             *   - 0x80: ConsiderationItem EIP-712 typehash (constant)\\r\\n             *   - 0xa0: itemType\\r\\n             *   - 0xc0: token\\r\\n             *   - 0xe0: identifier\\r\\n             *   - 0x100: startAmount\\r\\n             *   - 0x120: endAmount\\r\\n             *   - 0x140: recipient\\r\\n             *  0x160-END_ARR: array of consideration item hashes\\r\\n             *   - 0x160: primary consideration item EIP712 hash\\r\\n             *   - 0x180-END_ARR: additional recipient item EIP712 hashes\\r\\n             *  END_ARR: beginning of data for OrderFulfilled event\\r\\n             *   - END_ARR + 0x120: length of ReceivedItem array\\r\\n             *   - END_ARR + 0x140: beginning of data for first ReceivedItem\\r\\n             * (Note: END_ARR = 0x180 + RECIPIENTS_LENGTH * 0x20)\\r\\n             */\\r\\n\\r\\n            // Load consideration item typehash from runtime and place on stack.\\r\\n            bytes32 typeHash = _CONSIDERATION_ITEM_TYPEHASH;\\r\\n\\r\\n            // Utilize assembly to enable reuse of memory regions and use\\r\\n            // constant pointers when possible.\\r\\n            assembly {\\r\\n                /*\\r\\n                 * 1. Calculate the EIP712 ConsiderationItem hash for the\\r\\n                 * primary consideration item of the basic order.\\r\\n                 */\\r\\n\\r\\n                // Write ConsiderationItem type hash and item type to memory.\\r\\n                mstore(BasicOrder_considerationItem_typeHash_ptr, typeHash)\\r\\n                mstore(\\r\\n                    BasicOrder_considerationItem_itemType_ptr,\\r\\n                    receivedItemType\\r\\n                )\\r\\n\\r\\n                // Copy calldata region with (token, identifier, amount) from\\r\\n                // BasicOrderParameters to ConsiderationItem. The\\r\\n                // considerationAmount is written to startAmount and endAmount\\r\\n                // as basic orders do not have dynamic amounts.\\r\\n                calldatacopy(\\r\\n                    BasicOrder_considerationItem_token_ptr,\\r\\n                    BasicOrder_considerationToken_cdPtr,\\r\\n                    ThreeWords\\r\\n                )\\r\\n\\r\\n                // Copy calldata region with considerationAmount and offerer\\r\\n                // from BasicOrderParameters to endAmount and recipient in\\r\\n                // ConsiderationItem.\\r\\n                calldatacopy(\\r\\n                    BasicOrder_considerationItem_endAmount_ptr,\\r\\n                    BasicOrder_considerationAmount_cdPtr,\\r\\n                    TwoWords\\r\\n                )\\r\\n\\r\\n                // Calculate EIP712 ConsiderationItem hash and store it in the\\r\\n                // array of EIP712 consideration hashes.\\r\\n                mstore(\\r\\n                    BasicOrder_considerationHashesArray_ptr,\\r\\n                    keccak256(\\r\\n                        BasicOrder_considerationItem_typeHash_ptr,\\r\\n                        EIP712_ConsiderationItem_size\\r\\n                    )\\r\\n                )\\r\\n\\r\\n                /*\\r\\n                 * 2. Write a ReceivedItem struct for the primary consideration\\r\\n                 * item to the consideration array in OrderFulfilled.\\r\\n                 */\\r\\n\\r\\n                // Get the length of the additional recipients array.\\r\\n                let totalAdditionalRecipients := calldataload(\\r\\n                    BasicOrder_additionalRecipients_length_cdPtr\\r\\n                )\\r\\n\\r\\n                // Calculate pointer to length of OrderFulfilled consideration\\r\\n                // array.\\r\\n                let eventConsiderationArrPtr := add(\\r\\n                    OrderFulfilled_consideration_length_baseOffset,\\r\\n                    mul(totalAdditionalRecipients, OneWord)\\r\\n                )\\r\\n\\r\\n                // Set the length of the consideration array to the number of\\r\\n                // additional recipients, plus one for the primary consideration\\r\\n                // item.\\r\\n                mstore(\\r\\n                    eventConsiderationArrPtr,\\r\\n                    add(\\r\\n                        calldataload(\\r\\n                            BasicOrder_additionalRecipients_length_cdPtr\\r\\n                        ),\\r\\n                        1\\r\\n                    )\\r\\n                )\\r\\n\\r\\n                // Overwrite the consideration array pointer so it points to the\\r\\n                // body of the first element\\r\\n                eventConsiderationArrPtr := add(\\r\\n                    eventConsiderationArrPtr,\\r\\n                    OneWord\\r\\n                )\\r\\n\\r\\n                // Set itemType at start of the ReceivedItem memory region.\\r\\n                mstore(eventConsiderationArrPtr, receivedItemType)\\r\\n\\r\\n                // Copy calldata region (token, identifier, amount & recipient)\\r\\n                // from BasicOrderParameters to ReceivedItem memory.\\r\\n                calldatacopy(\\r\\n                    add(eventConsiderationArrPtr, Common_token_offset),\\r\\n                    BasicOrder_considerationToken_cdPtr,\\r\\n                    FourWords\\r\\n                )\\r\\n\\r\\n                /*\\r\\n                 * 3. Calculate EIP712 ConsiderationItem hashes for original\\r\\n                 * additional recipients and add a ReceivedItem for each to the\\r\\n                 * consideration array in the OrderFulfilled event. The original\\r\\n                 * additional recipients are all the considerations signed by\\r\\n                 * the offerer aside from the primary consideration of the\\r\\n                 * order. Uses memory region from 0x80-0x160 as a buffer for\\r\\n                 * calculating EIP712 ConsiderationItem hashes.\\r\\n                 */\\r\\n\\r\\n                // Put pointer to consideration hashes array on the stack.\\r\\n                // This will be updated as each additional recipient is hashed\\r\\n                let\\r\\n                    considerationHashesPtr\\r\\n                := BasicOrder_considerationHashesArray_ptr\\r\\n\\r\\n                // Write item type, token, & identifier for additional recipient\\r\\n                // to memory region for hashing EIP712 ConsiderationItem; these\\r\\n                // values will be reused for each recipient.\\r\\n                mstore(\\r\\n                    BasicOrder_considerationItem_itemType_ptr,\\r\\n                    additionalRecipientsItemType\\r\\n                )\\r\\n                mstore(\\r\\n                    BasicOrder_considerationItem_token_ptr,\\r\\n                    additionalRecipientsToken\\r\\n                )\\r\\n                mstore(BasicOrder_considerationItem_identifier_ptr, 0)\\r\\n\\r\\n                // Read length of the additionalRecipients array from calldata\\r\\n                // and iterate.\\r\\n                totalAdditionalRecipients := calldataload(\\r\\n                    BasicOrder_totalOriginalAdditionalRecipients_cdPtr\\r\\n                )\\r\\n                let i := 0\\r\\n                // prettier-ignore\\r\\n                for {} lt(i, totalAdditionalRecipients) {\\r\\n                    i := add(i, 1)\\r\\n                } {\\r\\n                    /*\\r\\n                     * Calculate EIP712 ConsiderationItem hash for recipient.\\r\\n                     */\\r\\n\\r\\n                    // Retrieve calldata pointer for additional recipient.\\r\\n                    let additionalRecipientCdPtr := add(\\r\\n                        BasicOrder_additionalRecipients_data_cdPtr,\\r\\n                        mul(AdditionalRecipients_size, i)\\r\\n                    )\\r\\n\\r\\n                    // Copy startAmount from calldata to the ConsiderationItem\\r\\n                    // struct.\\r\\n                    calldatacopy(\\r\\n                        BasicOrder_considerationItem_startAmount_ptr,\\r\\n                        additionalRecipientCdPtr,\\r\\n                        OneWord\\r\\n                    )\\r\\n\\r\\n                    // Copy endAmount and recipient from calldata to the\\r\\n                    // ConsiderationItem struct.\\r\\n                    calldatacopy(\\r\\n                        BasicOrder_considerationItem_endAmount_ptr,\\r\\n                        additionalRecipientCdPtr,\\r\\n                        AdditionalRecipients_size\\r\\n                    )\\r\\n\\r\\n                    // Add 1 word to the pointer as part of each loop to reduce\\r\\n                    // operations needed to get local offset into the array.\\r\\n                    considerationHashesPtr := add(\\r\\n                        considerationHashesPtr,\\r\\n                        OneWord\\r\\n                    )\\r\\n\\r\\n                    // Calculate EIP712 ConsiderationItem hash and store it in\\r\\n                    // the array of consideration hashes.\\r\\n                    mstore(\\r\\n                        considerationHashesPtr,\\r\\n                        keccak256(\\r\\n                            BasicOrder_considerationItem_typeHash_ptr,\\r\\n                            EIP712_ConsiderationItem_size\\r\\n                        )\\r\\n                    )\\r\\n\\r\\n                    /*\\r\\n                     * Write ReceivedItem to OrderFulfilled data.\\r\\n                     */\\r\\n\\r\\n                    // At this point, eventConsiderationArrPtr points to the\\r\\n                    // beginning of the ReceivedItem struct of the previous\\r\\n                    // element in the array. Increase it by the size of the\\r\\n                    // struct to arrive at the pointer for the current element.\\r\\n                    eventConsiderationArrPtr := add(\\r\\n                        eventConsiderationArrPtr,\\r\\n                        ReceivedItem_size\\r\\n                    )\\r\\n\\r\\n                    // Write itemType to the ReceivedItem struct.\\r\\n                    mstore(\\r\\n                        eventConsiderationArrPtr,\\r\\n                        additionalRecipientsItemType\\r\\n                    )\\r\\n\\r\\n                    // Write token to the next word of the ReceivedItem struct.\\r\\n                    mstore(\\r\\n                        add(eventConsiderationArrPtr, OneWord),\\r\\n                        additionalRecipientsToken\\r\\n                    )\\r\\n\\r\\n                    // Copy endAmount & recipient words to ReceivedItem struct.\\r\\n                    calldatacopy(\\r\\n                        add(\\r\\n                            eventConsiderationArrPtr,\\r\\n                            ReceivedItem_amount_offset\\r\\n                        ),\\r\\n                        additionalRecipientCdPtr,\\r\\n                        TwoWords\\r\\n                    )\\r\\n                }\\r\\n\\r\\n                /*\\r\\n                 * 4. Hash packed array of ConsiderationItem EIP712 hashes:\\r\\n                 *   `keccak256(abi.encodePacked(receivedItemHashes))`\\r\\n                 * Note that it is set at 0x60 \\u2014 all other memory begins at\\r\\n                 * 0x80. 0x60 is the \\\"zero slot\\\" and will be restored at the end\\r\\n                 * of the assembly section and before required by the compiler.\\r\\n                 */\\r\\n                mstore(\\r\\n                    receivedItemsHash_ptr,\\r\\n                    keccak256(\\r\\n                        BasicOrder_considerationHashesArray_ptr,\\r\\n                        mul(add(totalAdditionalRecipients, 1), OneWord)\\r\\n                    )\\r\\n                )\\r\\n\\r\\n                /*\\r\\n                 * 5. Add a ReceivedItem for each tip to the consideration array\\r\\n                 * in the OrderFulfilled event. The tips are all the\\r\\n                 * consideration items that were not signed by the offerer and\\r\\n                 * were provided by the fulfiller.\\r\\n                 */\\r\\n\\r\\n                // Overwrite length to length of the additionalRecipients array.\\r\\n                totalAdditionalRecipients := calldataload(\\r\\n                    BasicOrder_additionalRecipients_length_cdPtr\\r\\n                )\\r\\n                // prettier-ignore\\r\\n                for {} lt(i, totalAdditionalRecipients) {\\r\\n                    i := add(i, 1)\\r\\n                } {\\r\\n                    // Retrieve calldata pointer for additional recipient.\\r\\n                    let additionalRecipientCdPtr := add(\\r\\n                        BasicOrder_additionalRecipients_data_cdPtr,\\r\\n                        mul(AdditionalRecipients_size, i)\\r\\n                    )\\r\\n\\r\\n                    // At this point, eventConsiderationArrPtr points to the\\r\\n                    // beginning of the ReceivedItem struct of the previous\\r\\n                    // element in the array. Increase it by the size of the\\r\\n                    // struct to arrive at the pointer for the current element.\\r\\n                    eventConsiderationArrPtr := add(\\r\\n                        eventConsiderationArrPtr,\\r\\n                        ReceivedItem_size\\r\\n                    )\\r\\n\\r\\n                    // Write itemType to the ReceivedItem struct.\\r\\n                    mstore(\\r\\n                        eventConsiderationArrPtr,\\r\\n                        additionalRecipientsItemType\\r\\n                    )\\r\\n\\r\\n                    // Write token to the next word of the ReceivedItem struct.\\r\\n                    mstore(\\r\\n                        add(eventConsiderationArrPtr, OneWord),\\r\\n                        additionalRecipientsToken\\r\\n                    )\\r\\n\\r\\n                    // Copy endAmount & recipient words to ReceivedItem struct.\\r\\n                    calldatacopy(\\r\\n                        add(\\r\\n                            eventConsiderationArrPtr,\\r\\n                            ReceivedItem_amount_offset\\r\\n                        ),\\r\\n                        additionalRecipientCdPtr,\\r\\n                        TwoWords\\r\\n                    )\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        {\\r\\n            /**\\r\\n             * Next, handle offered items. Memory Layout:\\r\\n             *  EIP712 data for OfferItem\\r\\n             *   - 0x80:  OfferItem EIP-712 typehash (constant)\\r\\n             *   - 0xa0:  itemType\\r\\n             *   - 0xc0:  token\\r\\n             *   - 0xe0:  identifier (reused for offeredItemsHash)\\r\\n             *   - 0x100: startAmount\\r\\n             *   - 0x120: endAmount\\r\\n             */\\r\\n\\r\\n            // Place offer item typehash on the stack.\\r\\n            bytes32 typeHash = _OFFER_ITEM_TYPEHASH;\\r\\n\\r\\n            // Utilize assembly to enable reuse of memory regions when possible.\\r\\n            assembly {\\r\\n                /*\\r\\n                 * 1. Calculate OfferItem EIP712 hash\\r\\n                 */\\r\\n\\r\\n                // Write the OfferItem typeHash to memory.\\r\\n                mstore(BasicOrder_offerItem_typeHash_ptr, typeHash)\\r\\n\\r\\n                // Write the OfferItem item type to memory.\\r\\n                mstore(BasicOrder_offerItem_itemType_ptr, offeredItemType)\\r\\n\\r\\n                // Copy calldata region with (offerToken, offerIdentifier,\\r\\n                // offerAmount) from OrderParameters to (token, identifier,\\r\\n                // startAmount) in OfferItem struct. The offerAmount is written\\r\\n                // to startAmount and endAmount as basic orders do not have\\r\\n                // dynamic amounts.\\r\\n                calldatacopy(\\r\\n                    BasicOrder_offerItem_token_ptr,\\r\\n                    BasicOrder_offerToken_cdPtr,\\r\\n                    ThreeWords\\r\\n                )\\r\\n\\r\\n                // Copy offerAmount from calldata to endAmount in OfferItem\\r\\n                // struct.\\r\\n                calldatacopy(\\r\\n                    BasicOrder_offerItem_endAmount_ptr,\\r\\n                    BasicOrder_offerAmount_cdPtr,\\r\\n                    OneWord\\r\\n                )\\r\\n\\r\\n                // Compute EIP712 OfferItem hash, write result to scratch space:\\r\\n                //   `keccak256(abi.encode(offeredItem))`\\r\\n                mstore(\\r\\n                    0,\\r\\n                    keccak256(\\r\\n                        BasicOrder_offerItem_typeHash_ptr,\\r\\n                        EIP712_OfferItem_size\\r\\n                    )\\r\\n                )\\r\\n\\r\\n                /*\\r\\n                 * 2. Calculate hash of array of EIP712 hashes and write the\\r\\n                 * result to the corresponding OfferItem struct:\\r\\n                 *   `keccak256(abi.encodePacked(offerItemHashes))`\\r\\n                 */\\r\\n                mstore(BasicOrder_order_offerHashes_ptr, keccak256(0, OneWord))\\r\\n\\r\\n                /*\\r\\n                 * 3. Write SpentItem to offer array in OrderFulfilled event.\\r\\n                 */\\r\\n                let eventConsiderationArrPtr := add(\\r\\n                    OrderFulfilled_offer_length_baseOffset,\\r\\n                    mul(\\r\\n                        calldataload(\\r\\n                            BasicOrder_additionalRecipients_length_cdPtr\\r\\n                        ),\\r\\n                        OneWord\\r\\n                    )\\r\\n                )\\r\\n\\r\\n                // Set a length of 1 for the offer array.\\r\\n                mstore(eventConsiderationArrPtr, 1)\\r\\n\\r\\n                // Write itemType to the SpentItem struct.\\r\\n                mstore(add(eventConsiderationArrPtr, OneWord), offeredItemType)\\r\\n\\r\\n                // Copy calldata region with (offerToken, offerIdentifier,\\r\\n                // offerAmount) from OrderParameters to (token, identifier,\\r\\n                // amount) in SpentItem struct.\\r\\n                calldatacopy(\\r\\n                    add(eventConsiderationArrPtr, AdditionalRecipients_size),\\r\\n                    BasicOrder_offerToken_cdPtr,\\r\\n                    ThreeWords\\r\\n                )\\r\\n            }\\r\\n        }\\r\\n\\r\\n        {\\r\\n            /**\\r\\n             * Once consideration items and offer items have been handled,\\r\\n             * derive the final order hash. Memory Layout:\\r\\n             *  0x80-0x1c0: EIP712 data for order\\r\\n             *   - 0x80:   Order EIP-712 typehash (constant)\\r\\n             *   - 0xa0:   orderParameters.offerer\\r\\n             *   - 0xc0:   orderParameters.zone\\r\\n             *   - 0xe0:   keccak256(abi.encodePacked(offerHashes))\\r\\n             *   - 0x100:  keccak256(abi.encodePacked(considerationHashes))\\r\\n             *   - 0x120:  orderParameters.basicOrderType (% 4 = orderType)\\r\\n             *   - 0x140:  orderParameters.startTime\\r\\n             *   - 0x160:  orderParameters.endTime\\r\\n             *   - 0x180:  orderParameters.zoneHash\\r\\n             *   - 0x1a0:  orderParameters.salt\\r\\n             *   - 0x1c0:  orderParameters.conduitKey\\r\\n             *   - 0x1e0:  _counters[orderParameters.offerer] (from storage)\\r\\n             */\\r\\n\\r\\n            // Read the offerer from calldata and place on the stack.\\r\\n            address offerer;\\r\\n            assembly {\\r\\n                offerer := calldataload(BasicOrder_offerer_cdPtr)\\r\\n            }\\r\\n\\r\\n            // Read offerer's current counter from storage and place on stack.\\r\\n            uint256 counter = _getCounter(offerer);\\r\\n\\r\\n            // Load order typehash from runtime code and place on stack.\\r\\n            bytes32 typeHash = _ORDER_TYPEHASH;\\r\\n\\r\\n            assembly {\\r\\n                // Set the OrderItem typeHash in memory.\\r\\n                mstore(BasicOrder_order_typeHash_ptr, typeHash)\\r\\n\\r\\n                // Copy offerer and zone from OrderParameters in calldata to the\\r\\n                // Order struct.\\r\\n                calldatacopy(\\r\\n                    BasicOrder_order_offerer_ptr,\\r\\n                    BasicOrder_offerer_cdPtr,\\r\\n                    TwoWords\\r\\n                )\\r\\n\\r\\n                // Copy receivedItemsHash from zero slot to the Order struct.\\r\\n                mstore(\\r\\n                    BasicOrder_order_considerationHashes_ptr,\\r\\n                    mload(receivedItemsHash_ptr)\\r\\n                )\\r\\n\\r\\n                // Write the supplied orderType to the Order struct.\\r\\n                mstore(BasicOrder_order_orderType_ptr, orderType)\\r\\n\\r\\n                // Copy startTime, endTime, zoneHash, salt & conduit from\\r\\n                // calldata to the Order struct.\\r\\n                calldatacopy(\\r\\n                    BasicOrder_order_startTime_ptr,\\r\\n                    BasicOrder_startTime_cdPtr,\\r\\n                    FiveWords\\r\\n                )\\r\\n\\r\\n                // Write offerer's counter, retrieved from storage, to struct.\\r\\n                mstore(BasicOrder_order_counter_ptr, counter)\\r\\n\\r\\n                // Compute the EIP712 Order hash.\\r\\n                orderHash := keccak256(\\r\\n                    BasicOrder_order_typeHash_ptr,\\r\\n                    EIP712_Order_size\\r\\n                )\\r\\n            }\\r\\n        }\\r\\n\\r\\n        assembly {\\r\\n            /**\\r\\n             * After the order hash has been derived, emit OrderFulfilled event:\\r\\n             *   event OrderFulfilled(\\r\\n             *     bytes32 orderHash,\\r\\n             *     address indexed offerer,\\r\\n             *     address indexed zone,\\r\\n             *     address fulfiller,\\r\\n             *     SpentItem[] offer,\\r\\n             *       > (itemType, token, id, amount)\\r\\n             *     ReceivedItem[] consideration\\r\\n             *       > (itemType, token, id, amount, recipient)\\r\\n             *   )\\r\\n             * topic0 - OrderFulfilled event signature\\r\\n             * topic1 - offerer\\r\\n             * topic2 - zone\\r\\n             * data:\\r\\n             *  - 0x00: orderHash\\r\\n             *  - 0x20: fulfiller\\r\\n             *  - 0x40: offer arr ptr (0x80)\\r\\n             *  - 0x60: consideration arr ptr (0x120)\\r\\n             *  - 0x80: offer arr len (1)\\r\\n             *  - 0xa0: offer.itemType\\r\\n             *  - 0xc0: offer.token\\r\\n             *  - 0xe0: offer.identifier\\r\\n             *  - 0x100: offer.amount\\r\\n             *  - 0x120: 1 + recipients.length\\r\\n             *  - 0x140: recipient 0\\r\\n             */\\r\\n\\r\\n            // Derive pointer to start of OrderFulfilled event data\\r\\n            let eventDataPtr := add(\\r\\n                OrderFulfilled_baseOffset,\\r\\n                mul(\\r\\n                    calldataload(BasicOrder_additionalRecipients_length_cdPtr),\\r\\n                    OneWord\\r\\n                )\\r\\n            )\\r\\n\\r\\n            // Write the order hash to the head of the event's data region.\\r\\n            mstore(eventDataPtr, orderHash)\\r\\n\\r\\n            // Write the fulfiller (i.e. the caller) next for receiver argument.\\r\\n            mstore(add(eventDataPtr, OrderFulfilled_fulfiller_offset), caller())\\r\\n\\r\\n            // Write the SpentItem and ReceivedItem array offsets (constants).\\r\\n            mstore(\\r\\n                // SpentItem array offset\\r\\n                add(eventDataPtr, OrderFulfilled_offer_head_offset),\\r\\n                OrderFulfilled_offer_body_offset\\r\\n            )\\r\\n            mstore(\\r\\n                // ReceivedItem array offset\\r\\n                add(eventDataPtr, OrderFulfilled_consideration_head_offset),\\r\\n                OrderFulfilled_consideration_body_offset\\r\\n            )\\r\\n\\r\\n            // Derive total data size including SpentItem and ReceivedItem data.\\r\\n            // SpentItem portion is already included in the baseSize constant,\\r\\n            // as there can only be one element in the array.\\r\\n            let dataSize := add(\\r\\n                OrderFulfilled_baseSize,\\r\\n                mul(\\r\\n                    calldataload(BasicOrder_additionalRecipients_length_cdPtr),\\r\\n                    ReceivedItem_size\\r\\n                )\\r\\n            )\\r\\n\\r\\n            // Emit OrderFulfilled log with three topics (the event signature\\r\\n            // as well as the two indexed arguments, the offerer and the zone).\\r\\n            log3(\\r\\n                // Supply the pointer for event data in memory.\\r\\n                eventDataPtr,\\r\\n                // Supply the size of event data in memory.\\r\\n                dataSize,\\r\\n                // Supply the OrderFulfilled event signature.\\r\\n                OrderFulfilled_selector,\\r\\n                // Supply the first topic (the offerer).\\r\\n                calldataload(BasicOrder_offerer_cdPtr),\\r\\n                // Supply the second topic (the zone).\\r\\n                calldataload(BasicOrder_zone_cdPtr)\\r\\n            )\\r\\n\\r\\n            // Restore the zero slot.\\r\\n            mstore(ZeroSlot, 0)\\r\\n        }\\r\\n\\r\\n        // Determine whether order is restricted and, if so, that it is valid.\\r\\n        _assertRestrictedBasicOrderValidity(\\r\\n            orderHash,\\r\\n            parameters.zoneHash,\\r\\n            orderType,\\r\\n            parameters.offerer,\\r\\n            parameters.zone\\r\\n        );\\r\\n\\r\\n        // Verify and update the status of the derived order.\\r\\n        _validateBasicOrderAndUpdateStatus(\\r\\n            orderHash,\\r\\n            parameters.offerer,\\r\\n            parameters.signature\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to transfer Ether (or other native tokens) to a\\r\\n     *      given recipient as part of basic order fulfillment. Note that\\r\\n     *      conduits are not utilized for native tokens as the transferred\\r\\n     *      amount must be provided as msg.value.\\r\\n     *\\r\\n     * @param amount               The amount to transfer.\\r\\n     * @param to                   The recipient of the native token transfer.\\r\\n     * @param additionalRecipients The additional recipients of the order.\\r\\n     */\\r\\n    function _transferEthAndFinalize(\\r\\n        uint256 amount,\\r\\n        address payable to,\\r\\n        AdditionalRecipient[] calldata additionalRecipients\\r\\n    ) internal {\\r\\n        // Put ether value supplied by the caller on the stack.\\r\\n        uint256 etherRemaining = msg.value;\\r\\n\\r\\n        // Retrieve total number of additional recipients and place on stack.\\r\\n        uint256 totalAdditionalRecipients = additionalRecipients.length;\\r\\n\\r\\n        // Skip overflow check as for loop is indexed starting at zero.\\r\\n        unchecked {\\r\\n            // Iterate over each additional recipient.\\r\\n            for (uint256 i = 0; i < totalAdditionalRecipients; ++i) {\\r\\n                // Retrieve the additional recipient.\\r\\n                AdditionalRecipient calldata additionalRecipient = (\\r\\n                    additionalRecipients[i]\\r\\n                );\\r\\n\\r\\n                // Read ether amount to transfer to recipient & place on stack.\\r\\n                uint256 additionalRecipientAmount = additionalRecipient.amount;\\r\\n\\r\\n                // Ensure that sufficient Ether is available.\\r\\n                if (additionalRecipientAmount > etherRemaining) {\\r\\n                    revert InsufficientEtherSupplied();\\r\\n                }\\r\\n\\r\\n                // Transfer Ether to the additional recipient.\\r\\n                _transferEth(\\r\\n                    additionalRecipient.recipient,\\r\\n                    additionalRecipientAmount\\r\\n                );\\r\\n\\r\\n                // Reduce ether value available. Skip underflow check as\\r\\n                // subtracted value is confirmed above as less than remaining.\\r\\n                etherRemaining -= additionalRecipientAmount;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Ensure that sufficient Ether is still available.\\r\\n        if (amount > etherRemaining) {\\r\\n            revert InsufficientEtherSupplied();\\r\\n        }\\r\\n\\r\\n        // Transfer Ether to the offerer.\\r\\n        _transferEth(to, amount);\\r\\n\\r\\n        // If any Ether remains after transfers, return it to the caller.\\r\\n        if (etherRemaining > amount) {\\r\\n            // Skip underflow check as etherRemaining > amount.\\r\\n            unchecked {\\r\\n                // Transfer remaining Ether to the caller.\\r\\n                _transferEth(payable(msg.sender), etherRemaining - amount);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to transfer ERC20 tokens to a given recipient as\\r\\n     *      part of basic order fulfillment.\\r\\n     *\\r\\n     * @param offerer     The offerer of the fulfiller order.\\r\\n     * @param parameters  The basic order parameters.\\r\\n     * @param fromOfferer A boolean indicating whether to decrement amount from\\r\\n     *                    the offered amount.\\r\\n     * @param accumulator An open-ended array that collects transfers to execute\\r\\n     *                    against a given conduit in a single call.\\r\\n     */\\r\\n    function _transferERC20AndFinalize(\\r\\n        address offerer,\\r\\n        BasicOrderParameters calldata parameters,\\r\\n        bool fromOfferer,\\r\\n        bytes memory accumulator\\r\\n    ) internal {\\r\\n        // Declare from and to variables determined by fromOfferer value.\\r\\n        address from;\\r\\n        address to;\\r\\n\\r\\n        // Declare token and amount variables determined by fromOfferer value.\\r\\n        address token;\\r\\n        uint256 amount;\\r\\n\\r\\n        // Declare and check identifier variable within an isolated scope.\\r\\n        {\\r\\n            // Declare identifier variable determined by fromOfferer value.\\r\\n            uint256 identifier;\\r\\n\\r\\n            // Set ERC20 token transfer variables based on fromOfferer boolean.\\r\\n            if (fromOfferer) {\\r\\n                // Use offerer as from value and msg.sender as to value.\\r\\n                from = offerer;\\r\\n                to = msg.sender;\\r\\n\\r\\n                // Use offer token and related values if token is from offerer.\\r\\n                token = parameters.offerToken;\\r\\n                identifier = parameters.offerIdentifier;\\r\\n                amount = parameters.offerAmount;\\r\\n            } else {\\r\\n                // Use msg.sender as from value and offerer as to value.\\r\\n                from = msg.sender;\\r\\n                to = offerer;\\r\\n\\r\\n                // Otherwise, use consideration token and related values.\\r\\n                token = parameters.considerationToken;\\r\\n                identifier = parameters.considerationIdentifier;\\r\\n                amount = parameters.considerationAmount;\\r\\n            }\\r\\n\\r\\n            // Ensure that no identifier is supplied.\\r\\n            if (identifier != 0) {\\r\\n                revert UnusedItemParameters();\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Determine the appropriate conduit to utilize.\\r\\n        bytes32 conduitKey;\\r\\n\\r\\n        // Utilize assembly to derive conduit (if relevant) based on route.\\r\\n        assembly {\\r\\n            // Use offerer conduit if fromOfferer, fulfiller conduit otherwise.\\r\\n            conduitKey := calldataload(\\r\\n                sub(\\r\\n                    BasicOrder_fulfillerConduit_cdPtr,\\r\\n                    mul(fromOfferer, OneWord)\\r\\n                )\\r\\n            )\\r\\n        }\\r\\n\\r\\n        // Retrieve total number of additional recipients and place on stack.\\r\\n        uint256 totalAdditionalRecipients = (\\r\\n            parameters.additionalRecipients.length\\r\\n        );\\r\\n\\r\\n        // Iterate over each additional recipient.\\r\\n        for (uint256 i = 0; i < totalAdditionalRecipients; ) {\\r\\n            // Retrieve the additional recipient.\\r\\n            AdditionalRecipient calldata additionalRecipient = (\\r\\n                parameters.additionalRecipients[i]\\r\\n            );\\r\\n\\r\\n            uint256 additionalRecipientAmount = additionalRecipient.amount;\\r\\n\\r\\n            // Decrement the amount to transfer to fulfiller if indicated.\\r\\n            if (fromOfferer) {\\r\\n                amount -= additionalRecipientAmount;\\r\\n            }\\r\\n\\r\\n            // Transfer ERC20 tokens to additional recipient given approval.\\r\\n            _transferERC20(\\r\\n                token,\\r\\n                from,\\r\\n                additionalRecipient.recipient,\\r\\n                additionalRecipientAmount,\\r\\n                conduitKey,\\r\\n                accumulator\\r\\n            );\\r\\n\\r\\n            // Skip overflow check as for loop is indexed starting at zero.\\r\\n            unchecked {\\r\\n                ++i;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Transfer ERC20 token amount (from account must have proper approval).\\r\\n        _transferERC20(token, from, to, amount, conduitKey, accumulator);\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xdfa2f437ec6866532e8ee2ec1ddd0be50adb5c01e22989f291324099832de804\",\"license\":\"MIT\"},\"contracts/lib/Consideration.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.13;\\r\\n\\r\\n// prettier-ignore\\r\\nimport {\\r\\n    ConsiderationInterface\\r\\n} from \\\"../interfaces/ConsiderationInterface.sol\\\";\\r\\n\\r\\n// prettier-ignore\\r\\nimport {\\r\\n    OrderComponents,\\r\\n    BasicOrderParameters,\\r\\n    OrderParameters,\\r\\n    Order,\\r\\n    AdvancedOrder,\\r\\n    OrderStatus,\\r\\n    CriteriaResolver,\\r\\n    Fulfillment,\\r\\n    FulfillmentComponent,\\r\\n    Execution\\r\\n} from \\\"./ConsiderationStructs.sol\\\";\\r\\n\\r\\nimport { OrderCombiner } from \\\"./OrderCombiner.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Consideration\\r\\n * @author 0age\\r\\n * @custom:coauthor d1ll0n\\r\\n * @custom:coauthor transmissions11\\r\\n * @custom:version 1.1\\r\\n * @notice Consideration is a generalized ETH/ERC20/ERC721/ERC1155 marketplace.\\r\\n *         It minimizes external calls to the greatest extent possible and\\r\\n *         provides lightweight methods for common routes as well as more\\r\\n *         flexible methods for composing advanced orders or groups of orders.\\r\\n *         Each order contains an arbitrary number of items that may be spent\\r\\n *         (the \\\"offer\\\") along with an arbitrary number of items that must be\\r\\n *         received back by the indicated recipients (the \\\"consideration\\\").\\r\\n */\\r\\ncontract Consideration is ConsiderationInterface, OrderCombiner {\\r\\n    /**\\r\\n     * @notice Derive and set hashes, reference chainId, and associated domain\\r\\n     *         separator during deployment.\\r\\n     *\\r\\n     * @param conduitController A contract that deploys conduits, or proxies\\r\\n     *                          that may optionally be used to transfer approved\\r\\n     *                          ERC20/721/1155 tokens.\\r\\n     */\\r\\n    constructor(address conduitController) OrderCombiner(conduitController) {}\\r\\n\\r\\n    /**\\r\\n     * @notice Fulfill an order offering an ERC20, ERC721, or ERC1155 item by\\r\\n     *         supplying Ether (or other native tokens), ERC20 tokens, an ERC721\\r\\n     *         item, or an ERC1155 item as consideration. Six permutations are\\r\\n     *         supported: Native token to ERC721, Native token to ERC1155, ERC20\\r\\n     *         to ERC721, ERC20 to ERC1155, ERC721 to ERC20, and ERC1155 to\\r\\n     *         ERC20 (with native tokens supplied as msg.value). For an order to\\r\\n     *         be eligible for fulfillment via this method, it must contain a\\r\\n     *         single offer item (though that item may have a greater amount if\\r\\n     *         the item is not an ERC721). An arbitrary number of \\\"additional\\r\\n     *         recipients\\\" may also be supplied which will each receive native\\r\\n     *         tokens or ERC20 items from the fulfiller as consideration. Refer\\r\\n     *         to the documentation for a more comprehensive summary of how to\\r\\n     *         utilize this method and what orders are compatible with it.\\r\\n     *\\r\\n     * @param parameters Additional information on the fulfilled order. Note\\r\\n     *                   that the offerer and the fulfiller must first approve\\r\\n     *                   this contract (or their chosen conduit if indicated)\\r\\n     *                   before any tokens can be transferred. Also note that\\r\\n     *                   contract recipients of ERC1155 consideration items must\\r\\n     *                   implement `onERC1155Received` in order to receive those\\r\\n     *                   items.\\r\\n     *\\r\\n     * @return fulfilled A boolean indicating whether the order has been\\r\\n     *                   successfully fulfilled.\\r\\n     */\\r\\n    function fulfillBasicOrder(BasicOrderParameters calldata parameters)\\r\\n        external\\r\\n        payable\\r\\n        override\\r\\n        returns (bool fulfilled)\\r\\n    {\\r\\n        // Validate and fulfill the basic order.\\r\\n        fulfilled = _validateAndFulfillBasicOrder(parameters);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Fulfill an order with an arbitrary number of items for offer and\\r\\n     *         consideration. Note that this function does not support\\r\\n     *         criteria-based orders or partial filling of orders (though\\r\\n     *         filling the remainder of a partially-filled order is supported).\\r\\n     *\\r\\n     * @param order               The order to fulfill. Note that both the\\r\\n     *                            offerer and the fulfiller must first approve\\r\\n     *                            this contract (or the corresponding conduit if\\r\\n     *                            indicated) to transfer any relevant tokens on\\r\\n     *                            their behalf and that contracts must implement\\r\\n     *                            `onERC1155Received` to receive ERC1155 tokens\\r\\n     *                            as consideration.\\r\\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\\r\\n     *                            any, to source the fulfiller's token approvals\\r\\n     *                            from. The zero hash signifies that no conduit\\r\\n     *                            should be used (and direct approvals set on\\r\\n     *                            Consideration).\\r\\n     *\\r\\n     * @return fulfilled A boolean indicating whether the order has been\\r\\n     *                   successfully fulfilled.\\r\\n     */\\r\\n    function fulfillOrder(Order calldata order, bytes32 fulfillerConduitKey)\\r\\n        external\\r\\n        payable\\r\\n        override\\r\\n        returns (bool fulfilled)\\r\\n    {\\r\\n        // Convert order to \\\"advanced\\\" order, then validate and fulfill it.\\r\\n        fulfilled = _validateAndFulfillAdvancedOrder(\\r\\n            _convertOrderToAdvanced(order),\\r\\n            new CriteriaResolver[](0), // No criteria resolvers supplied.\\r\\n            fulfillerConduitKey,\\r\\n            msg.sender\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Fill an order, fully or partially, with an arbitrary number of\\r\\n     *         items for offer and consideration alongside criteria resolvers\\r\\n     *         containing specific token identifiers and associated proofs.\\r\\n     *\\r\\n     * @param advancedOrder       The order to fulfill along with the fraction\\r\\n     *                            of the order to attempt to fill. Note that\\r\\n     *                            both the offerer and the fulfiller must first\\r\\n     *                            approve this contract (or their conduit if\\r\\n     *                            indicated by the order) to transfer any\\r\\n     *                            relevant tokens on their behalf and that\\r\\n     *                            contracts must implement `onERC1155Received`\\r\\n     *                            to receive ERC1155 tokens as consideration.\\r\\n     *                            Also note that all offer and consideration\\r\\n     *                            components must have no remainder after\\r\\n     *                            multiplication of the respective amount with\\r\\n     *                            the supplied fraction for the partial fill to\\r\\n     *                            be considered valid.\\r\\n     * @param criteriaResolvers   An array where each element contains a\\r\\n     *                            reference to a specific offer or\\r\\n     *                            consideration, a token identifier, and a proof\\r\\n     *                            that the supplied token identifier is\\r\\n     *                            contained in the merkle root held by the item\\r\\n     *                            in question's criteria element. Note that an\\r\\n     *                            empty criteria indicates that any\\r\\n     *                            (transferable) token identifier on the token\\r\\n     *                            in question is valid and that no associated\\r\\n     *                            proof needs to be supplied.\\r\\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\\r\\n     *                            any, to source the fulfiller's token approvals\\r\\n     *                            from. The zero hash signifies that no conduit\\r\\n     *                            should be used (and direct approvals set on\\r\\n     *                            Consideration).\\r\\n     * @param recipient           The intended recipient for all received items,\\r\\n     *                            with `address(0)` indicating that the caller\\r\\n     *                            should receive the items.\\r\\n     *\\r\\n     * @return fulfilled A boolean indicating whether the order has been\\r\\n     *                   successfully fulfilled.\\r\\n     */\\r\\n    function fulfillAdvancedOrder(\\r\\n        AdvancedOrder calldata advancedOrder,\\r\\n        CriteriaResolver[] calldata criteriaResolvers,\\r\\n        bytes32 fulfillerConduitKey,\\r\\n        address recipient\\r\\n    ) external payable override returns (bool fulfilled) {\\r\\n        // Validate and fulfill the order.\\r\\n        fulfilled = _validateAndFulfillAdvancedOrder(\\r\\n            advancedOrder,\\r\\n            criteriaResolvers,\\r\\n            fulfillerConduitKey,\\r\\n            recipient == address(0) ? msg.sender : recipient\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Attempt to fill a group of orders, each with an arbitrary number\\r\\n     *         of items for offer and consideration. Any order that is not\\r\\n     *         currently active, has already been fully filled, or has been\\r\\n     *         cancelled will be omitted. Remaining offer and consideration\\r\\n     *         items will then be aggregated where possible as indicated by the\\r\\n     *         supplied offer and consideration component arrays and aggregated\\r\\n     *         items will be transferred to the fulfiller or to each intended\\r\\n     *         recipient, respectively. Note that a failing item transfer or an\\r\\n     *         issue with order formatting will cause the entire batch to fail.\\r\\n     *         Note that this function does not support criteria-based orders or\\r\\n     *         partial filling of orders (though filling the remainder of a\\r\\n     *         partially-filled order is supported).\\r\\n     *\\r\\n     * @param orders                    The orders to fulfill. Note that both\\r\\n     *                                  the offerer and the fulfiller must first\\r\\n     *                                  approve this contract (or the\\r\\n     *                                  corresponding conduit if indicated) to\\r\\n     *                                  transfer any relevant tokens on their\\r\\n     *                                  behalf and that contracts must implement\\r\\n     *                                  `onERC1155Received` to receive ERC1155\\r\\n     *                                  tokens as consideration.\\r\\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\\r\\n     *                                  indicating which offer items to attempt\\r\\n     *                                  to aggregate when preparing executions.\\r\\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\\r\\n     *                                  indicating which consideration items to\\r\\n     *                                  attempt to aggregate when preparing\\r\\n     *                                  executions.\\r\\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\\r\\n     *                                  if any, to source the fulfiller's token\\r\\n     *                                  approvals from. The zero hash signifies\\r\\n     *                                  that no conduit should be used (and\\r\\n     *                                  direct approvals set on Consideration).\\r\\n     * @param maximumFulfilled          The maximum number of orders to fulfill.\\r\\n     *\\r\\n     * @return availableOrders An array of booleans indicating if each order\\r\\n     *                         with an index corresponding to the index of the\\r\\n     *                         returned boolean was fulfillable or not.\\r\\n     * @return executions      An array of elements indicating the sequence of\\r\\n     *                         transfers performed as part of matching the given\\r\\n     *                         orders.\\r\\n     */\\r\\n    function fulfillAvailableOrders(\\r\\n        Order[] calldata orders,\\r\\n        FulfillmentComponent[][] calldata offerFulfillments,\\r\\n        FulfillmentComponent[][] calldata considerationFulfillments,\\r\\n        bytes32 fulfillerConduitKey,\\r\\n        uint256 maximumFulfilled\\r\\n    )\\r\\n        external\\r\\n        payable\\r\\n        override\\r\\n        returns (bool[] memory availableOrders, Execution[] memory executions)\\r\\n    {\\r\\n        // Convert orders to \\\"advanced\\\" orders and fulfill all available orders.\\r\\n        return\\r\\n            _fulfillAvailableAdvancedOrders(\\r\\n                _convertOrdersToAdvanced(orders), // Convert to advanced orders.\\r\\n                new CriteriaResolver[](0), // No criteria resolvers supplied.\\r\\n                offerFulfillments,\\r\\n                considerationFulfillments,\\r\\n                fulfillerConduitKey,\\r\\n                msg.sender,\\r\\n                maximumFulfilled\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Attempt to fill a group of orders, fully or partially, with an\\r\\n     *         arbitrary number of items for offer and consideration per order\\r\\n     *         alongside criteria resolvers containing specific token\\r\\n     *         identifiers and associated proofs. Any order that is not\\r\\n     *         currently active, has already been fully filled, or has been\\r\\n     *         cancelled will be omitted. Remaining offer and consideration\\r\\n     *         items will then be aggregated where possible as indicated by the\\r\\n     *         supplied offer and consideration component arrays and aggregated\\r\\n     *         items will be transferred to the fulfiller or to each intended\\r\\n     *         recipient, respectively. Note that a failing item transfer or an\\r\\n     *         issue with order formatting will cause the entire batch to fail.\\r\\n     *\\r\\n     * @param advancedOrders            The orders to fulfill along with the\\r\\n     *                                  fraction of those orders to attempt to\\r\\n     *                                  fill. Note that both the offerer and the\\r\\n     *                                  fulfiller must first approve this\\r\\n     *                                  contract (or their conduit if indicated\\r\\n     *                                  by the order) to transfer any relevant\\r\\n     *                                  tokens on their behalf and that\\r\\n     *                                  contracts must implement\\r\\n     *                                  `onERC1155Received` in order to receive\\r\\n     *                                  ERC1155 tokens as consideration. Also\\r\\n     *                                  note that all offer and consideration\\r\\n     *                                  components must have no remainder after\\r\\n     *                                  multiplication of the respective amount\\r\\n     *                                  with the supplied fraction for an\\r\\n     *                                  order's partial fill amount to be\\r\\n     *                                  considered valid.\\r\\n     * @param criteriaResolvers         An array where each element contains a\\r\\n     *                                  reference to a specific offer or\\r\\n     *                                  consideration, a token identifier, and a\\r\\n     *                                  proof that the supplied token identifier\\r\\n     *                                  is contained in the merkle root held by\\r\\n     *                                  the item in question's criteria element.\\r\\n     *                                  Note that an empty criteria indicates\\r\\n     *                                  that any (transferable) token\\r\\n     *                                  identifier on the token in question is\\r\\n     *                                  valid and that no associated proof needs\\r\\n     *                                  to be supplied.\\r\\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\\r\\n     *                                  indicating which offer items to attempt\\r\\n     *                                  to aggregate when preparing executions.\\r\\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\\r\\n     *                                  indicating which consideration items to\\r\\n     *                                  attempt to aggregate when preparing\\r\\n     *                                  executions.\\r\\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\\r\\n     *                                  if any, to source the fulfiller's token\\r\\n     *                                  approvals from. The zero hash signifies\\r\\n     *                                  that no conduit should be used (and\\r\\n     *                                  direct approvals set on Consideration).\\r\\n     * @param recipient                 The intended recipient for all received\\r\\n     *                                  items, with `address(0)` indicating that\\r\\n     *                                  the caller should receive the items.\\r\\n     * @param maximumFulfilled          The maximum number of orders to fulfill.\\r\\n     *\\r\\n     * @return availableOrders An array of booleans indicating if each order\\r\\n     *                         with an index corresponding to the index of the\\r\\n     *                         returned boolean was fulfillable or not.\\r\\n     * @return executions      An array of elements indicating the sequence of\\r\\n     *                         transfers performed as part of matching the given\\r\\n     *                         orders.\\r\\n     */\\r\\n    function fulfillAvailableAdvancedOrders(\\r\\n        AdvancedOrder[] memory advancedOrders,\\r\\n        CriteriaResolver[] calldata criteriaResolvers,\\r\\n        FulfillmentComponent[][] calldata offerFulfillments,\\r\\n        FulfillmentComponent[][] calldata considerationFulfillments,\\r\\n        bytes32 fulfillerConduitKey,\\r\\n        address recipient,\\r\\n        uint256 maximumFulfilled\\r\\n    )\\r\\n        external\\r\\n        payable\\r\\n        override\\r\\n        returns (bool[] memory availableOrders, Execution[] memory executions)\\r\\n    {\\r\\n        // Fulfill all available orders.\\r\\n        return\\r\\n            _fulfillAvailableAdvancedOrders(\\r\\n                advancedOrders,\\r\\n                criteriaResolvers,\\r\\n                offerFulfillments,\\r\\n                considerationFulfillments,\\r\\n                fulfillerConduitKey,\\r\\n                recipient == address(0) ? msg.sender : recipient,\\r\\n                maximumFulfilled\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Match an arbitrary number of orders, each with an arbitrary\\r\\n     *         number of items for offer and consideration along with a set of\\r\\n     *         fulfillments allocating offer components to consideration\\r\\n     *         components. Note that this function does not support\\r\\n     *         criteria-based or partial filling of orders (though filling the\\r\\n     *         remainder of a partially-filled order is supported).\\r\\n     *\\r\\n     * @param orders            The orders to match. Note that both the offerer\\r\\n     *                          and fulfiller on each order must first approve\\r\\n     *                          this contract (or their conduit if indicated by\\r\\n     *                          the order) to transfer any relevant tokens on\\r\\n     *                          their behalf and each consideration recipient\\r\\n     *                          must implement `onERC1155Received` in order to\\r\\n     *                          receive ERC1155 tokens.\\r\\n     * @param fulfillments      An array of elements allocating offer components\\r\\n     *                          to consideration components. Note that each\\r\\n     *                          consideration component must be fully met in\\r\\n     *                          order for the match operation to be valid.\\r\\n     *\\r\\n     * @return executions An array of elements indicating the sequence of\\r\\n     *                    transfers performed as part of matching the given\\r\\n     *                    orders.\\r\\n     */\\r\\n    function matchOrders(\\r\\n        Order[] calldata orders,\\r\\n        Fulfillment[] calldata fulfillments\\r\\n    ) external payable override returns (Execution[] memory executions) {\\r\\n        // Convert to advanced, validate, and match orders using fulfillments.\\r\\n        return\\r\\n            _matchAdvancedOrders(\\r\\n                _convertOrdersToAdvanced(orders),\\r\\n                new CriteriaResolver[](0), // No criteria resolvers supplied.\\r\\n                fulfillments\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Match an arbitrary number of full or partial orders, each with an\\r\\n     *         arbitrary number of items for offer and consideration, supplying\\r\\n     *         criteria resolvers containing specific token identifiers and\\r\\n     *         associated proofs as well as fulfillments allocating offer\\r\\n     *         components to consideration components.\\r\\n     *\\r\\n     * @param advancedOrders    The advanced orders to match. Note that both the\\r\\n     *                          offerer and fulfiller on each order must first\\r\\n     *                          approve this contract (or their conduit if\\r\\n     *                          indicated by the order) to transfer any relevant\\r\\n     *                          tokens on their behalf and each consideration\\r\\n     *                          recipient must implement `onERC1155Received` in\\r\\n     *                          order to receive ERC1155 tokens. Also note that\\r\\n     *                          the offer and consideration components for each\\r\\n     *                          order must have no remainder after multiplying\\r\\n     *                          the respective amount with the supplied fraction\\r\\n     *                          in order for the group of partial fills to be\\r\\n     *                          considered valid.\\r\\n     * @param criteriaResolvers An array where each element contains a reference\\r\\n     *                          to a specific order as well as that order's\\r\\n     *                          offer or consideration, a token identifier, and\\r\\n     *                          a proof that the supplied token identifier is\\r\\n     *                          contained in the order's merkle root. Note that\\r\\n     *                          an empty root indicates that any (transferable)\\r\\n     *                          token identifier is valid and that no associated\\r\\n     *                          proof needs to be supplied.\\r\\n     * @param fulfillments      An array of elements allocating offer components\\r\\n     *                          to consideration components. Note that each\\r\\n     *                          consideration component must be fully met in\\r\\n     *                          order for the match operation to be valid.\\r\\n     *\\r\\n     * @return executions An array of elements indicating the sequence of\\r\\n     *                    transfers performed as part of matching the given\\r\\n     *                    orders.\\r\\n     */\\r\\n    function matchAdvancedOrders(\\r\\n        AdvancedOrder[] memory advancedOrders,\\r\\n        CriteriaResolver[] calldata criteriaResolvers,\\r\\n        Fulfillment[] calldata fulfillments\\r\\n    ) external payable override returns (Execution[] memory executions) {\\r\\n        // Validate and match the advanced orders using supplied fulfillments.\\r\\n        return\\r\\n            _matchAdvancedOrders(\\r\\n                advancedOrders,\\r\\n                criteriaResolvers,\\r\\n                fulfillments\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Cancel an arbitrary number of orders. Note that only the offerer\\r\\n     *         or the zone of a given order may cancel it. Callers should ensure\\r\\n     *         that the intended order was cancelled by calling `getOrderStatus`\\r\\n     *         and confirming that `isCancelled` returns `true`.\\r\\n     *\\r\\n     * @param orders The orders to cancel.\\r\\n     *\\r\\n     * @return cancelled A boolean indicating whether the supplied orders have\\r\\n     *                   been successfully cancelled.\\r\\n     */\\r\\n    function cancel(OrderComponents[] calldata orders)\\r\\n        external\\r\\n        override\\r\\n        returns (bool cancelled)\\r\\n    {\\r\\n        // Cancel the orders.\\r\\n        cancelled = _cancel(orders);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Validate an arbitrary number of orders, thereby registering their\\r\\n     *         signatures as valid and allowing the fulfiller to skip signature\\r\\n     *         verification on fulfillment. Note that validated orders may still\\r\\n     *         be unfulfillable due to invalid item amounts or other factors;\\r\\n     *         callers should determine whether validated orders are fulfillable\\r\\n     *         by simulating the fulfillment call prior to execution. Also note\\r\\n     *         that anyone can validate a signed order, but only the offerer can\\r\\n     *         validate an order without supplying a signature.\\r\\n     *\\r\\n     * @param orders The orders to validate.\\r\\n     *\\r\\n     * @return validated A boolean indicating whether the supplied orders have\\r\\n     *                   been successfully validated.\\r\\n     */\\r\\n    function validate(Order[] calldata orders)\\r\\n        external\\r\\n        override\\r\\n        returns (bool validated)\\r\\n    {\\r\\n        // Validate the orders.\\r\\n        validated = _validate(orders);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Cancel all orders from a given offerer with a given zone in bulk\\r\\n     *         by incrementing a counter. Note that only the offerer may\\r\\n     *         increment the counter.\\r\\n     *\\r\\n     * @return newCounter The new counter.\\r\\n     */\\r\\n    function incrementCounter() external override returns (uint256 newCounter) {\\r\\n        // Increment current counter for the supplied offerer.\\r\\n        newCounter = _incrementCounter();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Retrieve the order hash for a given order.\\r\\n     *\\r\\n     * @param order The components of the order.\\r\\n     *\\r\\n     * @return orderHash The order hash.\\r\\n     */\\r\\n    function getOrderHash(OrderComponents calldata order)\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (bytes32 orderHash)\\r\\n    {\\r\\n        // Derive order hash by supplying order parameters along with counter.\\r\\n        orderHash = _deriveOrderHash(\\r\\n            OrderParameters(\\r\\n                order.offerer,\\r\\n                order.zone,\\r\\n                order.offer,\\r\\n                order.consideration,\\r\\n                order.orderType,\\r\\n                order.startTime,\\r\\n                order.endTime,\\r\\n                order.zoneHash,\\r\\n                order.salt,\\r\\n                order.conduitKey,\\r\\n                order.consideration.length\\r\\n            ),\\r\\n            order.counter\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Retrieve the status of a given order by hash, including whether\\r\\n     *         the order has been cancelled or validated and the fraction of the\\r\\n     *         order that has been filled.\\r\\n     *\\r\\n     * @param orderHash The order hash in question.\\r\\n     *\\r\\n     * @return isValidated A boolean indicating whether the order in question\\r\\n     *                     has been validated (i.e. previously approved or\\r\\n     *                     partially filled).\\r\\n     * @return isCancelled A boolean indicating whether the order in question\\r\\n     *                     has been cancelled.\\r\\n     * @return totalFilled The total portion of the order that has been filled\\r\\n     *                     (i.e. the \\\"numerator\\\").\\r\\n     * @return totalSize   The total size of the order that is either filled or\\r\\n     *                     unfilled (i.e. the \\\"denominator\\\").\\r\\n     */\\r\\n    function getOrderStatus(bytes32 orderHash)\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (\\r\\n            bool isValidated,\\r\\n            bool isCancelled,\\r\\n            uint256 totalFilled,\\r\\n            uint256 totalSize\\r\\n        )\\r\\n    {\\r\\n        // Retrieve the order status using the order hash.\\r\\n        return _getOrderStatus(orderHash);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Retrieve the current counter for a given offerer.\\r\\n     *\\r\\n     * @param offerer The offerer in question.\\r\\n     *\\r\\n     * @return counter The current counter.\\r\\n     */\\r\\n    function getCounter(address offerer)\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (uint256 counter)\\r\\n    {\\r\\n        // Return the counter for the supplied offerer.\\r\\n        counter = _getCounter(offerer);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Retrieve configuration information for this contract.\\r\\n     *\\r\\n     * @return version           The contract version.\\r\\n     * @return domainSeparator   The domain separator for this contract.\\r\\n     * @return conduitController The conduit Controller set for this contract.\\r\\n     */\\r\\n    function information()\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (\\r\\n            string memory version,\\r\\n            bytes32 domainSeparator,\\r\\n            address conduitController\\r\\n        )\\r\\n    {\\r\\n        // Return the information for this contract.\\r\\n        return _information();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Retrieve the name of this contract.\\r\\n     *\\r\\n     * @return contractName The name of this contract.\\r\\n     */\\r\\n    function name()\\r\\n        external\\r\\n        pure\\r\\n        override\\r\\n        returns (string memory contractName)\\r\\n    {\\r\\n        // Return the name of the contract.\\r\\n        contractName = _name();\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xce486c4920e1e0ce78abf49904cac7701cd3fe27a804a041d8f446c38ccfe1f2\",\"license\":\"MIT\"},\"contracts/lib/ConsiderationBase.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.13;\\r\\n\\r\\n// prettier-ignore\\r\\nimport {\\r\\n    ConduitControllerInterface\\r\\n} from \\\"../interfaces/ConduitControllerInterface.sol\\\";\\r\\n\\r\\n// prettier-ignore\\r\\nimport {\\r\\n    ConsiderationEventsAndErrors\\r\\n} from \\\"../interfaces/ConsiderationEventsAndErrors.sol\\\";\\r\\n\\r\\nimport \\\"./ConsiderationConstants.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title ConsiderationBase\\r\\n * @author 0age\\r\\n * @notice ConsiderationBase contains immutable constants and constructor logic.\\r\\n */\\r\\ncontract ConsiderationBase is ConsiderationEventsAndErrors {\\r\\n    // Precompute hashes, original chainId, and domain separator on deployment.\\r\\n    bytes32 internal immutable _NAME_HASH;\\r\\n    bytes32 internal immutable _VERSION_HASH;\\r\\n    bytes32 internal immutable _EIP_712_DOMAIN_TYPEHASH;\\r\\n    bytes32 internal immutable _OFFER_ITEM_TYPEHASH;\\r\\n    bytes32 internal immutable _CONSIDERATION_ITEM_TYPEHASH;\\r\\n    bytes32 internal immutable _ORDER_TYPEHASH;\\r\\n    uint256 internal immutable _CHAIN_ID;\\r\\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\\r\\n\\r\\n    // Allow for interaction with the conduit controller.\\r\\n    ConduitControllerInterface internal immutable _CONDUIT_CONTROLLER;\\r\\n\\r\\n    // Cache the conduit creation code hash used by the conduit controller.\\r\\n    bytes32 internal immutable _CONDUIT_CREATION_CODE_HASH;\\r\\n\\r\\n    /**\\r\\n     * @dev Derive and set hashes, reference chainId, and associated domain\\r\\n     *      separator during deployment.\\r\\n     *\\r\\n     * @param conduitController A contract that deploys conduits, or proxies\\r\\n     *                          that may optionally be used to transfer approved\\r\\n     *                          ERC20/721/1155 tokens.\\r\\n     */\\r\\n    constructor(address conduitController) {\\r\\n        // Derive name and version hashes alongside required EIP-712 typehashes.\\r\\n        (\\r\\n            _NAME_HASH,\\r\\n            _VERSION_HASH,\\r\\n            _EIP_712_DOMAIN_TYPEHASH,\\r\\n            _OFFER_ITEM_TYPEHASH,\\r\\n            _CONSIDERATION_ITEM_TYPEHASH,\\r\\n            _ORDER_TYPEHASH\\r\\n        ) = _deriveTypehashes();\\r\\n\\r\\n        // Store the current chainId and derive the current domain separator.\\r\\n        _CHAIN_ID = block.chainid;\\r\\n        _DOMAIN_SEPARATOR = _deriveDomainSeparator();\\r\\n\\r\\n        // Set the supplied conduit controller.\\r\\n        _CONDUIT_CONTROLLER = ConduitControllerInterface(conduitController);\\r\\n\\r\\n        // Retrieve the conduit creation code hash from the supplied controller.\\r\\n        (_CONDUIT_CREATION_CODE_HASH, ) = (\\r\\n            _CONDUIT_CONTROLLER.getConduitCodeHashes()\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal view function to derive the EIP-712 domain separator.\\r\\n     *\\r\\n     * @return The derived domain separator.\\r\\n     */\\r\\n    function _deriveDomainSeparator() internal view returns (bytes32) {\\r\\n        // prettier-ignore\\r\\n        return keccak256(\\r\\n            abi.encode(\\r\\n                _EIP_712_DOMAIN_TYPEHASH,\\r\\n                _NAME_HASH,\\r\\n                _VERSION_HASH,\\r\\n                block.chainid,\\r\\n                address(this)\\r\\n            )\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal pure function to retrieve the default name of this\\r\\n     *      contract and return.\\r\\n     *\\r\\n     * @return The name of this contract.\\r\\n     */\\r\\n    function _name() internal pure virtual returns (string memory) {\\r\\n        // Return the name of the contract.\\r\\n        assembly {\\r\\n            // First element is the offset for the returned string. Offset the\\r\\n            // value in memory by one word so that the free memory pointer will\\r\\n            // be overwritten by the next write.\\r\\n            mstore(OneWord, OneWord)\\r\\n\\r\\n            // Name is right padded, so it touches the length which is left\\r\\n            // padded. This enables writing both values at once. The free memory\\r\\n            // pointer will be overwritten in the process.\\r\\n            mstore(NameLengthPtr, NameWithLength)\\r\\n\\r\\n            // Standard ABI encoding pads returned data to the nearest word. Use\\r\\n            // the already empty zero slot memory region for this purpose and\\r\\n            // return the final name string, offset by the original single word.\\r\\n            return(OneWord, ThreeWords)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal pure function to retrieve the default name of this contract\\r\\n     *      as a string that can be used internally.\\r\\n     *\\r\\n     * @return The name of this contract.\\r\\n     */\\r\\n    function _nameString() internal pure virtual returns (string memory) {\\r\\n        // Return the name of the contract.\\r\\n        return \\\"Consideration\\\";\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal pure function to derive required EIP-712 typehashes and\\r\\n     *      other hashes during contract creation.\\r\\n     *\\r\\n     * @return nameHash                  The hash of the name of the contract.\\r\\n     * @return versionHash               The hash of the version string of the\\r\\n     *                                   contract.\\r\\n     * @return eip712DomainTypehash      The primary EIP-712 domain typehash.\\r\\n     * @return offerItemTypehash         The EIP-712 typehash for OfferItem\\r\\n     *                                   types.\\r\\n     * @return considerationItemTypehash The EIP-712 typehash for\\r\\n     *                                   ConsiderationItem types.\\r\\n     * @return orderTypehash             The EIP-712 typehash for Order types.\\r\\n     */\\r\\n    function _deriveTypehashes()\\r\\n        internal\\r\\n        pure\\r\\n        returns (\\r\\n            bytes32 nameHash,\\r\\n            bytes32 versionHash,\\r\\n            bytes32 eip712DomainTypehash,\\r\\n            bytes32 offerItemTypehash,\\r\\n            bytes32 considerationItemTypehash,\\r\\n            bytes32 orderTypehash\\r\\n        )\\r\\n    {\\r\\n        // Derive hash of the name of the contract.\\r\\n        nameHash = keccak256(bytes(_nameString()));\\r\\n\\r\\n        // Derive hash of the version string of the contract.\\r\\n        versionHash = keccak256(bytes(\\\"1.1\\\"));\\r\\n\\r\\n        // Construct the OfferItem type string.\\r\\n        // prettier-ignore\\r\\n        bytes memory offerItemTypeString = abi.encodePacked(\\r\\n            \\\"OfferItem(\\\",\\r\\n                \\\"uint8 itemType,\\\",\\r\\n                \\\"address token,\\\",\\r\\n                \\\"uint256 identifierOrCriteria,\\\",\\r\\n                \\\"uint256 startAmount,\\\",\\r\\n                \\\"uint256 endAmount\\\",\\r\\n            \\\")\\\"\\r\\n        );\\r\\n\\r\\n        // Construct the ConsiderationItem type string.\\r\\n        // prettier-ignore\\r\\n        bytes memory considerationItemTypeString = abi.encodePacked(\\r\\n            \\\"ConsiderationItem(\\\",\\r\\n                \\\"uint8 itemType,\\\",\\r\\n                \\\"address token,\\\",\\r\\n                \\\"uint256 identifierOrCriteria,\\\",\\r\\n                \\\"uint256 startAmount,\\\",\\r\\n                \\\"uint256 endAmount,\\\",\\r\\n                \\\"address recipient\\\",\\r\\n            \\\")\\\"\\r\\n        );\\r\\n\\r\\n        // Construct the OrderComponents type string, not including the above.\\r\\n        // prettier-ignore\\r\\n        bytes memory orderComponentsPartialTypeString = abi.encodePacked(\\r\\n            \\\"OrderComponents(\\\",\\r\\n                \\\"address offerer,\\\",\\r\\n                \\\"address zone,\\\",\\r\\n                \\\"OfferItem[] offer,\\\",\\r\\n                \\\"ConsiderationItem[] consideration,\\\",\\r\\n                \\\"uint8 orderType,\\\",\\r\\n                \\\"uint256 startTime,\\\",\\r\\n                \\\"uint256 endTime,\\\",\\r\\n                \\\"bytes32 zoneHash,\\\",\\r\\n                \\\"uint256 salt,\\\",\\r\\n                \\\"bytes32 conduitKey,\\\",\\r\\n                \\\"uint256 counter\\\",\\r\\n            \\\")\\\"\\r\\n        );\\r\\n\\r\\n        // Construct the primary EIP-712 domain type string.\\r\\n        // prettier-ignore\\r\\n        eip712DomainTypehash = keccak256(\\r\\n            abi.encodePacked(\\r\\n                \\\"EIP712Domain(\\\",\\r\\n                    \\\"string name,\\\",\\r\\n                    \\\"string version,\\\",\\r\\n                    \\\"uint256 chainId,\\\",\\r\\n                    \\\"address verifyingContract\\\",\\r\\n                \\\")\\\"\\r\\n            )\\r\\n        );\\r\\n\\r\\n        // Derive the OfferItem type hash using the corresponding type string.\\r\\n        offerItemTypehash = keccak256(offerItemTypeString);\\r\\n\\r\\n        // Derive ConsiderationItem type hash using corresponding type string.\\r\\n        considerationItemTypehash = keccak256(considerationItemTypeString);\\r\\n\\r\\n        // Derive OrderItem type hash via combination of relevant type strings.\\r\\n        orderTypehash = keccak256(\\r\\n            abi.encodePacked(\\r\\n                orderComponentsPartialTypeString,\\r\\n                considerationItemTypeString,\\r\\n                offerItemTypeString\\r\\n            )\\r\\n        );\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xdf3339edb71d83f5b0b83b0cf9bc4a001d65d0bc24577b2173e468de42c64d82\",\"license\":\"MIT\"},\"contracts/lib/ConsiderationConstants.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.7;\\r\\n\\r\\n/*\\r\\n * -------------------------- Disambiguation & Other Notes ---------------------\\r\\n *    - The term \\\"head\\\" is used as it is in the documentation for ABI encoding,\\r\\n *      but only in reference to dynamic types, i.e. it always refers to the\\r\\n *      offset or pointer to the body of a dynamic type. In calldata, the head\\r\\n *      is always an offset (relative to the parent object), while in memory,\\r\\n *      the head is always the pointer to the body. More information found here:\\r\\n *      https://docs.soliditylang.org/en/v0.8.14/abi-spec.html#argument-encoding\\r\\n *        - Note that the length of an array is separate from and precedes the\\r\\n *          head of the array.\\r\\n *\\r\\n *    - The term \\\"body\\\" is used in place of the term \\\"head\\\" used in the ABI\\r\\n *      documentation. It refers to the start of the data for a dynamic type,\\r\\n *      e.g. the first word of a struct or the first word of the first element\\r\\n *      in an array.\\r\\n *\\r\\n *    - The term \\\"pointer\\\" is used to describe the absolute position of a value\\r\\n *      and never an offset relative to another value.\\r\\n *        - The suffix \\\"_ptr\\\" refers to a memory pointer.\\r\\n *        - The suffix \\\"_cdPtr\\\" refers to a calldata pointer.\\r\\n *\\r\\n *    - The term \\\"offset\\\" is used to describe the position of a value relative\\r\\n *      to some parent value. For example, OrderParameters_conduit_offset is the\\r\\n *      offset to the \\\"conduit\\\" value in the OrderParameters struct relative to\\r\\n *      the start of the body.\\r\\n *        - Note: Offsets are used to derive pointers.\\r\\n *\\r\\n *    - Some structs have pointers defined for all of their fields in this file.\\r\\n *      Lines which are commented out are fields that are not used in the\\r\\n *      codebase but have been left in for readability.\\r\\n */\\r\\n\\r\\n// Declare constants for name, version, and reentrancy sentinel values.\\r\\n\\r\\n// Name is right padded, so it touches the length which is left padded. This\\r\\n// enables writing both values at once. Length goes at byte 95 in memory, and\\r\\n// name fills bytes 96-109, so both values can be written left-padded to 77.\\r\\nuint256 constant NameLengthPtr = 77;\\r\\nuint256 constant NameWithLength = 0x0d436F6E73696465726174696F6E;\\r\\n\\r\\nuint256 constant Version = 0x312e31;\\r\\nuint256 constant Version_length = 3;\\r\\nuint256 constant Version_shift = 0xe8;\\r\\n\\r\\nuint256 constant _NOT_ENTERED = 1;\\r\\nuint256 constant _ENTERED = 2;\\r\\n\\r\\n// Common Offsets\\r\\n// Offsets for identically positioned fields shared by:\\r\\n// OfferItem, ConsiderationItem, SpentItem, ReceivedItem\\r\\n\\r\\nuint256 constant Common_token_offset = 0x20;\\r\\nuint256 constant Common_identifier_offset = 0x40;\\r\\nuint256 constant Common_amount_offset = 0x60;\\r\\n\\r\\nuint256 constant ReceivedItem_size = 0xa0;\\r\\nuint256 constant ReceivedItem_amount_offset = 0x60;\\r\\nuint256 constant ReceivedItem_recipient_offset = 0x80;\\r\\n\\r\\nuint256 constant ReceivedItem_CommonParams_size = 0x60;\\r\\n\\r\\nuint256 constant ConsiderationItem_recipient_offset = 0xa0;\\r\\n// Store the same constant in an abbreviated format for a line length fix.\\r\\nuint256 constant ConsiderItem_recipient_offset = 0xa0;\\r\\n\\r\\nuint256 constant Execution_offerer_offset = 0x20;\\r\\nuint256 constant Execution_conduit_offset = 0x40;\\r\\n\\r\\nuint256 constant InvalidFulfillmentComponentData_error_signature = (\\r\\n    0x7fda727900000000000000000000000000000000000000000000000000000000\\r\\n);\\r\\nuint256 constant InvalidFulfillmentComponentData_error_len = 0x04;\\r\\n\\r\\nuint256 constant Panic_error_signature = (\\r\\n    0x4e487b7100000000000000000000000000000000000000000000000000000000\\r\\n);\\r\\nuint256 constant Panic_error_offset = 0x04;\\r\\nuint256 constant Panic_error_length = 0x24;\\r\\nuint256 constant Panic_arithmetic = 0x11;\\r\\n\\r\\nuint256 constant MissingItemAmount_error_signature = (\\r\\n    0x91b3e51400000000000000000000000000000000000000000000000000000000\\r\\n);\\r\\nuint256 constant MissingItemAmount_error_len = 0x04;\\r\\n\\r\\nuint256 constant OrderParameters_offer_head_offset = 0x40;\\r\\nuint256 constant OrderParameters_consideration_head_offset = 0x60;\\r\\nuint256 constant OrderParameters_conduit_offset = 0x120;\\r\\nuint256 constant OrderParameters_counter_offset = 0x140;\\r\\n\\r\\nuint256 constant Fulfillment_itemIndex_offset = 0x20;\\r\\n\\r\\nuint256 constant AdvancedOrder_numerator_offset = 0x20;\\r\\n\\r\\nuint256 constant AlmostOneWord = 0x1f;\\r\\nuint256 constant OneWord = 0x20;\\r\\nuint256 constant TwoWords = 0x40;\\r\\nuint256 constant ThreeWords = 0x60;\\r\\nuint256 constant FourWords = 0x80;\\r\\nuint256 constant FiveWords = 0xa0;\\r\\n\\r\\nuint256 constant FreeMemoryPointerSlot = 0x40;\\r\\nuint256 constant ZeroSlot = 0x60;\\r\\nuint256 constant DefaultFreeMemoryPointer = 0x80;\\r\\n\\r\\nuint256 constant Slot0x80 = 0x80;\\r\\nuint256 constant Slot0xA0 = 0xa0;\\r\\n\\r\\nuint256 constant BasicOrder_endAmount_cdPtr = 0x104;\\r\\nuint256 constant BasicOrder_common_params_size = 0xa0;\\r\\nuint256 constant BasicOrder_considerationHashesArray_ptr = 0x160;\\r\\n\\r\\nuint256 constant EIP712_Order_size = 0x180;\\r\\nuint256 constant EIP712_OfferItem_size = 0xc0;\\r\\nuint256 constant EIP712_ConsiderationItem_size = 0xe0;\\r\\nuint256 constant AdditionalRecipients_size = 0x40;\\r\\n\\r\\nuint256 constant EIP712_DomainSeparator_offset = 0x02;\\r\\nuint256 constant EIP712_OrderHash_offset = 0x22;\\r\\nuint256 constant EIP712_DigestPayload_size = 0x42;\\r\\n\\r\\nuint256 constant receivedItemsHash_ptr = 0x60;\\r\\n\\r\\n/*\\r\\n *  Memory layout in _prepareBasicFulfillmentFromCalldata of\\r\\n *  data for OrderFulfilled\\r\\n *\\r\\n *   event OrderFulfilled(\\r\\n *     bytes32 orderHash,\\r\\n *     address indexed offerer,\\r\\n *     address indexed zone,\\r\\n *     address fulfiller,\\r\\n *     SpentItem[] offer,\\r\\n *       > (itemType, token, id, amount)\\r\\n *     ReceivedItem[] consideration\\r\\n *       > (itemType, token, id, amount, recipient)\\r\\n *   )\\r\\n *\\r\\n *  - 0x00: orderHash\\r\\n *  - 0x20: fulfiller\\r\\n *  - 0x40: offer offset (0x80)\\r\\n *  - 0x60: consideration offset (0x120)\\r\\n *  - 0x80: offer.length (1)\\r\\n *  - 0xa0: offerItemType\\r\\n *  - 0xc0: offerToken\\r\\n *  - 0xe0: offerIdentifier\\r\\n *  - 0x100: offerAmount\\r\\n *  - 0x120: consideration.length (1 + additionalRecipients.length)\\r\\n *  - 0x140: considerationItemType\\r\\n *  - 0x160: considerationToken\\r\\n *  - 0x180: considerationIdentifier\\r\\n *  - 0x1a0: considerationAmount\\r\\n *  - 0x1c0: considerationRecipient\\r\\n *  - ...\\r\\n */\\r\\n\\r\\n// Minimum length of the OrderFulfilled event data.\\r\\n// Must be added to the size of the ReceivedItem array for additionalRecipients\\r\\n// (0xa0 * additionalRecipients.length) to calculate full size of the buffer.\\r\\nuint256 constant OrderFulfilled_baseSize = 0x1e0;\\r\\nuint256 constant OrderFulfilled_selector = (\\r\\n    0x9d9af8e38d66c62e2c12f0225249fd9d721c54b83f48d9352c97c6cacdcb6f31\\r\\n);\\r\\n\\r\\n// Minimum offset in memory to OrderFulfilled event data.\\r\\n// Must be added to the size of the EIP712 hash array for additionalRecipients\\r\\n// (32 * additionalRecipients.length) to calculate the pointer to event data.\\r\\nuint256 constant OrderFulfilled_baseOffset = 0x180;\\r\\nuint256 constant OrderFulfilled_consideration_length_baseOffset = 0x2a0;\\r\\nuint256 constant OrderFulfilled_offer_length_baseOffset = 0x200;\\r\\n\\r\\n// uint256 constant OrderFulfilled_orderHash_offset = 0x00;\\r\\nuint256 constant OrderFulfilled_fulfiller_offset = 0x20;\\r\\nuint256 constant OrderFulfilled_offer_head_offset = 0x40;\\r\\nuint256 constant OrderFulfilled_offer_body_offset = 0x80;\\r\\nuint256 constant OrderFulfilled_consideration_head_offset = 0x60;\\r\\nuint256 constant OrderFulfilled_consideration_body_offset = 0x120;\\r\\n\\r\\n// BasicOrderParameters\\r\\nuint256 constant BasicOrder_parameters_cdPtr = 0x04;\\r\\nuint256 constant BasicOrder_considerationToken_cdPtr = 0x24;\\r\\n// uint256 constant BasicOrder_considerationIdentifier_cdPtr = 0x44;\\r\\nuint256 constant BasicOrder_considerationAmount_cdPtr = 0x64;\\r\\nuint256 constant BasicOrder_offerer_cdPtr = 0x84;\\r\\nuint256 constant BasicOrder_zone_cdPtr = 0xa4;\\r\\nuint256 constant BasicOrder_offerToken_cdPtr = 0xc4;\\r\\n// uint256 constant BasicOrder_offerIdentifier_cdPtr = 0xe4;\\r\\nuint256 constant BasicOrder_offerAmount_cdPtr = 0x104;\\r\\nuint256 constant BasicOrder_basicOrderType_cdPtr = 0x124;\\r\\nuint256 constant BasicOrder_startTime_cdPtr = 0x144;\\r\\n// uint256 constant BasicOrder_endTime_cdPtr = 0x164;\\r\\n// uint256 constant BasicOrder_zoneHash_cdPtr = 0x184;\\r\\n// uint256 constant BasicOrder_salt_cdPtr = 0x1a4;\\r\\nuint256 constant BasicOrder_offererConduit_cdPtr = 0x1c4;\\r\\nuint256 constant BasicOrder_fulfillerConduit_cdPtr = 0x1e4;\\r\\nuint256 constant BasicOrder_totalOriginalAdditionalRecipients_cdPtr = 0x204;\\r\\nuint256 constant BasicOrder_additionalRecipients_head_cdPtr = 0x224;\\r\\nuint256 constant BasicOrder_signature_cdPtr = 0x244;\\r\\nuint256 constant BasicOrder_additionalRecipients_length_cdPtr = 0x264;\\r\\nuint256 constant BasicOrder_additionalRecipients_data_cdPtr = 0x284;\\r\\n\\r\\nuint256 constant BasicOrder_parameters_ptr = 0x20;\\r\\n\\r\\nuint256 constant BasicOrder_basicOrderType_range = 0x18; // 24 values\\r\\n\\r\\n/*\\r\\n *  Memory layout in _prepareBasicFulfillmentFromCalldata of\\r\\n *  EIP712 data for ConsiderationItem\\r\\n *   - 0x80: ConsiderationItem EIP-712 typehash (constant)\\r\\n *   - 0xa0: itemType\\r\\n *   - 0xc0: token\\r\\n *   - 0xe0: identifier\\r\\n *   - 0x100: startAmount\\r\\n *   - 0x120: endAmount\\r\\n *   - 0x140: recipient\\r\\n */\\r\\nuint256 constant BasicOrder_considerationItem_typeHash_ptr = 0x80; // memoryPtr\\r\\nuint256 constant BasicOrder_considerationItem_itemType_ptr = 0xa0;\\r\\nuint256 constant BasicOrder_considerationItem_token_ptr = 0xc0;\\r\\nuint256 constant BasicOrder_considerationItem_identifier_ptr = 0xe0;\\r\\nuint256 constant BasicOrder_considerationItem_startAmount_ptr = 0x100;\\r\\nuint256 constant BasicOrder_considerationItem_endAmount_ptr = 0x120;\\r\\n// uint256 constant BasicOrder_considerationItem_recipient_ptr = 0x140;\\r\\n\\r\\n/*\\r\\n *  Memory layout in _prepareBasicFulfillmentFromCalldata of\\r\\n *  EIP712 data for OfferItem\\r\\n *   - 0x80:  OfferItem EIP-712 typehash (constant)\\r\\n *   - 0xa0:  itemType\\r\\n *   - 0xc0:  token\\r\\n *   - 0xe0:  identifier (reused for offeredItemsHash)\\r\\n *   - 0x100: startAmount\\r\\n *   - 0x120: endAmount\\r\\n */\\r\\nuint256 constant BasicOrder_offerItem_typeHash_ptr = DefaultFreeMemoryPointer;\\r\\nuint256 constant BasicOrder_offerItem_itemType_ptr = 0xa0;\\r\\nuint256 constant BasicOrder_offerItem_token_ptr = 0xc0;\\r\\n// uint256 constant BasicOrder_offerItem_identifier_ptr = 0xe0;\\r\\n// uint256 constant BasicOrder_offerItem_startAmount_ptr = 0x100;\\r\\nuint256 constant BasicOrder_offerItem_endAmount_ptr = 0x120;\\r\\n\\r\\n/*\\r\\n *  Memory layout in _prepareBasicFulfillmentFromCalldata of\\r\\n *  EIP712 data for Order\\r\\n *   - 0x80:   Order EIP-712 typehash (constant)\\r\\n *   - 0xa0:   orderParameters.offerer\\r\\n *   - 0xc0:   orderParameters.zone\\r\\n *   - 0xe0:   keccak256(abi.encodePacked(offerHashes))\\r\\n *   - 0x100:  keccak256(abi.encodePacked(considerationHashes))\\r\\n *   - 0x120:  orderType\\r\\n *   - 0x140:  startTime\\r\\n *   - 0x160:  endTime\\r\\n *   - 0x180:  zoneHash\\r\\n *   - 0x1a0:  salt\\r\\n *   - 0x1c0:  conduit\\r\\n *   - 0x1e0:  _counters[orderParameters.offerer] (from storage)\\r\\n */\\r\\nuint256 constant BasicOrder_order_typeHash_ptr = 0x80;\\r\\nuint256 constant BasicOrder_order_offerer_ptr = 0xa0;\\r\\n// uint256 constant BasicOrder_order_zone_ptr = 0xc0;\\r\\nuint256 constant BasicOrder_order_offerHashes_ptr = 0xe0;\\r\\nuint256 constant BasicOrder_order_considerationHashes_ptr = 0x100;\\r\\nuint256 constant BasicOrder_order_orderType_ptr = 0x120;\\r\\nuint256 constant BasicOrder_order_startTime_ptr = 0x140;\\r\\n// uint256 constant BasicOrder_order_endTime_ptr = 0x160;\\r\\n// uint256 constant BasicOrder_order_zoneHash_ptr = 0x180;\\r\\n// uint256 constant BasicOrder_order_salt_ptr = 0x1a0;\\r\\n// uint256 constant BasicOrder_order_conduitKey_ptr = 0x1c0;\\r\\nuint256 constant BasicOrder_order_counter_ptr = 0x1e0;\\r\\nuint256 constant BasicOrder_additionalRecipients_head_ptr = 0x240;\\r\\nuint256 constant BasicOrder_signature_ptr = 0x260;\\r\\n\\r\\n// Signature-related\\r\\nbytes32 constant EIP2098_allButHighestBitMask = (\\r\\n    0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\r\\n);\\r\\nbytes32 constant ECDSA_twentySeventhAndTwentyEighthBytesSet = (\\r\\n    0x0000000000000000000000000000000000000000000000000000000101000000\\r\\n);\\r\\nuint256 constant ECDSA_MaxLength = 65;\\r\\nuint256 constant ECDSA_signature_s_offset = 0x40;\\r\\nuint256 constant ECDSA_signature_v_offset = 0x60;\\r\\n\\r\\nbytes32 constant EIP1271_isValidSignature_selector = (\\r\\n    0x1626ba7e00000000000000000000000000000000000000000000000000000000\\r\\n);\\r\\nuint256 constant EIP1271_isValidSignature_signatureHead_negativeOffset = 0x20;\\r\\nuint256 constant EIP1271_isValidSignature_digest_negativeOffset = 0x40;\\r\\nuint256 constant EIP1271_isValidSignature_selector_negativeOffset = 0x44;\\r\\nuint256 constant EIP1271_isValidSignature_calldata_baseLength = 0x64;\\r\\n\\r\\nuint256 constant EIP1271_isValidSignature_signature_head_offset = 0x40;\\r\\n\\r\\n// abi.encodeWithSignature(\\\"NoContract(address)\\\")\\r\\nuint256 constant NoContract_error_signature = (\\r\\n    0x5f15d67200000000000000000000000000000000000000000000000000000000\\r\\n);\\r\\nuint256 constant NoContract_error_sig_ptr = 0x0;\\r\\nuint256 constant NoContract_error_token_ptr = 0x4;\\r\\nuint256 constant NoContract_error_length = 0x24; // 4 + 32 == 36\\r\\n\\r\\nuint256 constant EIP_712_PREFIX = (\\r\\n    0x1901000000000000000000000000000000000000000000000000000000000000\\r\\n);\\r\\n\\r\\nuint256 constant ExtraGasBuffer = 0x20;\\r\\nuint256 constant CostPerWord = 3;\\r\\nuint256 constant MemoryExpansionCoefficient = 0x200; // 512\\r\\n\\r\\nuint256 constant Create2AddressDerivation_ptr = 0x0b;\\r\\nuint256 constant Create2AddressDerivation_length = 0x55;\\r\\n\\r\\nuint256 constant MaskOverByteTwelve = (\\r\\n    0x0000000000000000000000ff0000000000000000000000000000000000000000\\r\\n);\\r\\n\\r\\nuint256 constant MaskOverLastTwentyBytes = (\\r\\n    0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff\\r\\n);\\r\\n\\r\\nuint256 constant MaskOverFirstFourBytes = (\\r\\n    0xffffffff00000000000000000000000000000000000000000000000000000000\\r\\n);\\r\\n\\r\\nuint256 constant Conduit_execute_signature = (\\r\\n    0x4ce34aa200000000000000000000000000000000000000000000000000000000\\r\\n);\\r\\n\\r\\nuint256 constant MaxUint8 = 0xff;\\r\\nuint256 constant MaxUint120 = 0xffffffffffffffffffffffffffffff;\\r\\n\\r\\nuint256 constant Conduit_execute_ConduitTransfer_ptr = 0x20;\\r\\nuint256 constant Conduit_execute_ConduitTransfer_length = 0x01;\\r\\n\\r\\nuint256 constant Conduit_execute_ConduitTransfer_offset_ptr = 0x04;\\r\\nuint256 constant Conduit_execute_ConduitTransfer_length_ptr = 0x24;\\r\\nuint256 constant Conduit_execute_transferItemType_ptr = 0x44;\\r\\nuint256 constant Conduit_execute_transferToken_ptr = 0x64;\\r\\nuint256 constant Conduit_execute_transferFrom_ptr = 0x84;\\r\\nuint256 constant Conduit_execute_transferTo_ptr = 0xa4;\\r\\nuint256 constant Conduit_execute_transferIdentifier_ptr = 0xc4;\\r\\nuint256 constant Conduit_execute_transferAmount_ptr = 0xe4;\\r\\n\\r\\nuint256 constant OneConduitExecute_size = 0x104;\\r\\n\\r\\n// Sentinel value to indicate that the conduit accumulator is not armed.\\r\\nuint256 constant AccumulatorDisarmed = 0x20;\\r\\nuint256 constant AccumulatorArmed = 0x40;\\r\\nuint256 constant Accumulator_conduitKey_ptr = 0x20;\\r\\nuint256 constant Accumulator_selector_ptr = 0x40;\\r\\nuint256 constant Accumulator_array_offset_ptr = 0x44;\\r\\nuint256 constant Accumulator_array_length_ptr = 0x64;\\r\\n\\r\\nuint256 constant Accumulator_itemSizeOffsetDifference = 0x3c;\\r\\n\\r\\nuint256 constant Accumulator_array_offset = 0x20;\\r\\nuint256 constant Conduit_transferItem_size = 0xc0;\\r\\nuint256 constant Conduit_transferItem_token_ptr = 0x20;\\r\\nuint256 constant Conduit_transferItem_from_ptr = 0x40;\\r\\nuint256 constant Conduit_transferItem_to_ptr = 0x60;\\r\\nuint256 constant Conduit_transferItem_identifier_ptr = 0x80;\\r\\nuint256 constant Conduit_transferItem_amount_ptr = 0xa0;\\r\\n\\r\\n// Declare constant for errors related to amount derivation.\\r\\n// error InexactFraction() @ AmountDerivationErrors.sol\\r\\nuint256 constant InexactFraction_error_signature = (\\r\\n    0xc63cf08900000000000000000000000000000000000000000000000000000000\\r\\n);\\r\\nuint256 constant InexactFraction_error_len = 0x04;\\r\\n\\r\\n// Declare constant for errors related to signature verification.\\r\\nuint256 constant Ecrecover_precompile = 1;\\r\\nuint256 constant Ecrecover_args_size = 0x80;\\r\\nuint256 constant Signature_lower_v = 27;\\r\\n\\r\\n// error BadSignatureV(uint8) @ SignatureVerificationErrors.sol\\r\\nuint256 constant BadSignatureV_error_signature = (\\r\\n    0x1f003d0a00000000000000000000000000000000000000000000000000000000\\r\\n);\\r\\nuint256 constant BadSignatureV_error_offset = 0x04;\\r\\nuint256 constant BadSignatureV_error_length = 0x24;\\r\\n\\r\\n// error InvalidSigner() @ SignatureVerificationErrors.sol\\r\\nuint256 constant InvalidSigner_error_signature = (\\r\\n    0x815e1d6400000000000000000000000000000000000000000000000000000000\\r\\n);\\r\\nuint256 constant InvalidSigner_error_length = 0x04;\\r\\n\\r\\n// error InvalidSignature() @ SignatureVerificationErrors.sol\\r\\nuint256 constant InvalidSignature_error_signature = (\\r\\n    0x8baa579f00000000000000000000000000000000000000000000000000000000\\r\\n);\\r\\nuint256 constant InvalidSignature_error_length = 0x04;\\r\\n\\r\\n// error BadContractSignature() @ SignatureVerificationErrors.sol\\r\\nuint256 constant BadContractSignature_error_signature = (\\r\\n    0x4f7fb80d00000000000000000000000000000000000000000000000000000000\\r\\n);\\r\\nuint256 constant BadContractSignature_error_length = 0x04;\\r\\n\\r\\nuint256 constant NumBitsAfterSelector = 0xe0;\\r\\n\\r\\n// 69 is the lowest modulus for which the remainder\\r\\n// of every selector other than the two match functions\\r\\n// is greater than those of the match functions.\\r\\nuint256 constant NonMatchSelector_MagicModulus = 69;\\r\\n// Of the two match function selectors, the highest\\r\\n// remainder modulo 69 is 29.\\r\\nuint256 constant NonMatchSelector_MagicRemainder = 0x1d;\\r\\n\",\"keccak256\":\"0x1b14d9576e020dd9ebff527c527dffef06a9bb5fe42b9e9ffc6bf8bcde3201e4\",\"license\":\"MIT\"},\"contracts/lib/ConsiderationEnums.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.7;\\r\\n\\r\\n// prettier-ignore\\r\\nenum OrderType {\\r\\n    // 0: no partial fills, anyone can execute\\r\\n    FULL_OPEN,\\r\\n\\r\\n    // 1: partial fills supported, anyone can execute\\r\\n    PARTIAL_OPEN,\\r\\n\\r\\n    // 2: no partial fills, only offerer or zone can execute\\r\\n    FULL_RESTRICTED,\\r\\n\\r\\n    // 3: partial fills supported, only offerer or zone can execute\\r\\n    PARTIAL_RESTRICTED\\r\\n}\\r\\n\\r\\n// prettier-ignore\\r\\nenum BasicOrderType {\\r\\n    // 0: no partial fills, anyone can execute\\r\\n    ETH_TO_ERC721_FULL_OPEN,\\r\\n\\r\\n    // 1: partial fills supported, anyone can execute\\r\\n    ETH_TO_ERC721_PARTIAL_OPEN,\\r\\n\\r\\n    // 2: no partial fills, only offerer or zone can execute\\r\\n    ETH_TO_ERC721_FULL_RESTRICTED,\\r\\n\\r\\n    // 3: partial fills supported, only offerer or zone can execute\\r\\n    ETH_TO_ERC721_PARTIAL_RESTRICTED,\\r\\n\\r\\n    // 4: no partial fills, anyone can execute\\r\\n    ETH_TO_ERC1155_FULL_OPEN,\\r\\n\\r\\n    // 5: partial fills supported, anyone can execute\\r\\n    ETH_TO_ERC1155_PARTIAL_OPEN,\\r\\n\\r\\n    // 6: no partial fills, only offerer or zone can execute\\r\\n    ETH_TO_ERC1155_FULL_RESTRICTED,\\r\\n\\r\\n    // 7: partial fills supported, only offerer or zone can execute\\r\\n    ETH_TO_ERC1155_PARTIAL_RESTRICTED,\\r\\n\\r\\n    // 8: no partial fills, anyone can execute\\r\\n    ERC20_TO_ERC721_FULL_OPEN,\\r\\n\\r\\n    // 9: partial fills supported, anyone can execute\\r\\n    ERC20_TO_ERC721_PARTIAL_OPEN,\\r\\n\\r\\n    // 10: no partial fills, only offerer or zone can execute\\r\\n    ERC20_TO_ERC721_FULL_RESTRICTED,\\r\\n\\r\\n    // 11: partial fills supported, only offerer or zone can execute\\r\\n    ERC20_TO_ERC721_PARTIAL_RESTRICTED,\\r\\n\\r\\n    // 12: no partial fills, anyone can execute\\r\\n    ERC20_TO_ERC1155_FULL_OPEN,\\r\\n\\r\\n    // 13: partial fills supported, anyone can execute\\r\\n    ERC20_TO_ERC1155_PARTIAL_OPEN,\\r\\n\\r\\n    // 14: no partial fills, only offerer or zone can execute\\r\\n    ERC20_TO_ERC1155_FULL_RESTRICTED,\\r\\n\\r\\n    // 15: partial fills supported, only offerer or zone can execute\\r\\n    ERC20_TO_ERC1155_PARTIAL_RESTRICTED,\\r\\n\\r\\n    // 16: no partial fills, anyone can execute\\r\\n    ERC721_TO_ERC20_FULL_OPEN,\\r\\n\\r\\n    // 17: partial fills supported, anyone can execute\\r\\n    ERC721_TO_ERC20_PARTIAL_OPEN,\\r\\n\\r\\n    // 18: no partial fills, only offerer or zone can execute\\r\\n    ERC721_TO_ERC20_FULL_RESTRICTED,\\r\\n\\r\\n    // 19: partial fills supported, only offerer or zone can execute\\r\\n    ERC721_TO_ERC20_PARTIAL_RESTRICTED,\\r\\n\\r\\n    // 20: no partial fills, anyone can execute\\r\\n    ERC1155_TO_ERC20_FULL_OPEN,\\r\\n\\r\\n    // 21: partial fills supported, anyone can execute\\r\\n    ERC1155_TO_ERC20_PARTIAL_OPEN,\\r\\n\\r\\n    // 22: no partial fills, only offerer or zone can execute\\r\\n    ERC1155_TO_ERC20_FULL_RESTRICTED,\\r\\n\\r\\n    // 23: partial fills supported, only offerer or zone can execute\\r\\n    ERC1155_TO_ERC20_PARTIAL_RESTRICTED\\r\\n}\\r\\n\\r\\n// prettier-ignore\\r\\nenum BasicOrderRouteType {\\r\\n    // 0: provide Ether (or other native token) to receive offered ERC721 item.\\r\\n    ETH_TO_ERC721,\\r\\n\\r\\n    // 1: provide Ether (or other native token) to receive offered ERC1155 item.\\r\\n    ETH_TO_ERC1155,\\r\\n\\r\\n    // 2: provide ERC20 item to receive offered ERC721 item.\\r\\n    ERC20_TO_ERC721,\\r\\n\\r\\n    // 3: provide ERC20 item to receive offered ERC1155 item.\\r\\n    ERC20_TO_ERC1155,\\r\\n\\r\\n    // 4: provide ERC721 item to receive offered ERC20 item.\\r\\n    ERC721_TO_ERC20,\\r\\n\\r\\n    // 5: provide ERC1155 item to receive offered ERC20 item.\\r\\n    ERC1155_TO_ERC20\\r\\n}\\r\\n\\r\\n// prettier-ignore\\r\\nenum ItemType {\\r\\n    // 0: ETH on mainnet, MATIC on polygon, etc.\\r\\n    NATIVE,\\r\\n\\r\\n    // 1: ERC20 items (ERC777 and ERC20 analogues could also technically work)\\r\\n    ERC20,\\r\\n\\r\\n    // 2: ERC721 items\\r\\n    ERC721,\\r\\n\\r\\n    // 3: ERC1155 items\\r\\n    ERC1155,\\r\\n\\r\\n    // 4: ERC721 items where a number of tokenIds are supported\\r\\n    ERC721_WITH_CRITERIA,\\r\\n\\r\\n    // 5: ERC1155 items where a number of ids are supported\\r\\n    ERC1155_WITH_CRITERIA\\r\\n}\\r\\n\\r\\n// prettier-ignore\\r\\nenum Side {\\r\\n    // 0: Items that can be spent\\r\\n    OFFER,\\r\\n\\r\\n    // 1: Items that must be received\\r\\n    CONSIDERATION\\r\\n}\\r\\n\",\"keccak256\":\"0x2a71736674241419f210c0007196958a61e57ba4b12601b38cbab81f567d48de\",\"license\":\"MIT\"},\"contracts/lib/ConsiderationStructs.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.7;\\r\\n\\r\\n// prettier-ignore\\r\\nimport {\\r\\n    OrderType,\\r\\n    BasicOrderType,\\r\\n    ItemType,\\r\\n    Side\\r\\n} from \\\"./ConsiderationEnums.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev An order contains eleven components: an offerer, a zone (or account that\\r\\n *      can cancel the order or restrict who can fulfill the order depending on\\r\\n *      the type), the order type (specifying partial fill support as well as\\r\\n *      restricted order status), the start and end time, a hash that will be\\r\\n *      provided to the zone when validating restricted orders, a salt, a key\\r\\n *      corresponding to a given conduit, a counter, and an arbitrary number of\\r\\n *      offer items that can be spent along with consideration items that must\\r\\n *      be received by their respective recipient.\\r\\n */\\r\\nstruct OrderComponents {\\r\\n    address offerer;\\r\\n    address zone;\\r\\n    OfferItem[] offer;\\r\\n    ConsiderationItem[] consideration;\\r\\n    OrderType orderType;\\r\\n    uint256 startTime;\\r\\n    uint256 endTime;\\r\\n    bytes32 zoneHash;\\r\\n    uint256 salt;\\r\\n    bytes32 conduitKey;\\r\\n    uint256 counter;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev An offer item has five components: an item type (ETH or other native\\r\\n *      tokens, ERC20, ERC721, and ERC1155, as well as criteria-based ERC721 and\\r\\n *      ERC1155), a token address, a dual-purpose \\\"identifierOrCriteria\\\"\\r\\n *      component that will either represent a tokenId or a merkle root\\r\\n *      depending on the item type, and a start and end amount that support\\r\\n *      increasing or decreasing amounts over the duration of the respective\\r\\n *      order.\\r\\n */\\r\\nstruct OfferItem {\\r\\n    ItemType itemType;\\r\\n    address token;\\r\\n    uint256 identifierOrCriteria;\\r\\n    uint256 startAmount;\\r\\n    uint256 endAmount;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev A consideration item has the same five components as an offer item and\\r\\n *      an additional sixth component designating the required recipient of the\\r\\n *      item.\\r\\n */\\r\\nstruct ConsiderationItem {\\r\\n    ItemType itemType;\\r\\n    address token;\\r\\n    uint256 identifierOrCriteria;\\r\\n    uint256 startAmount;\\r\\n    uint256 endAmount;\\r\\n    address payable recipient;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev A spent item is translated from a utilized offer item and has four\\r\\n *      components: an item type (ETH or other native tokens, ERC20, ERC721, and\\r\\n *      ERC1155), a token address, a tokenId, and an amount.\\r\\n */\\r\\nstruct SpentItem {\\r\\n    ItemType itemType;\\r\\n    address token;\\r\\n    uint256 identifier;\\r\\n    uint256 amount;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev A received item is translated from a utilized consideration item and has\\r\\n *      the same four components as a spent item, as well as an additional fifth\\r\\n *      component designating the required recipient of the item.\\r\\n */\\r\\nstruct ReceivedItem {\\r\\n    ItemType itemType;\\r\\n    address token;\\r\\n    uint256 identifier;\\r\\n    uint256 amount;\\r\\n    address payable recipient;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev For basic orders involving ETH / native / ERC20 <=> ERC721 / ERC1155\\r\\n *      matching, a group of six functions may be called that only requires a\\r\\n *      subset of the usual order arguments. Note the use of a \\\"basicOrderType\\\"\\r\\n *      enum; this represents both the usual order type as well as the \\\"route\\\"\\r\\n *      of the basic order (a simple derivation function for the basic order\\r\\n *      type is `basicOrderType = orderType + (4 * basicOrderRoute)`.)\\r\\n */\\r\\nstruct BasicOrderParameters {\\r\\n    // calldata offset\\r\\n    address considerationToken; // 0x24\\r\\n    uint256 considerationIdentifier; // 0x44\\r\\n    uint256 considerationAmount; // 0x64\\r\\n    address payable offerer; // 0x84\\r\\n    address zone; // 0xa4\\r\\n    address offerToken; // 0xc4\\r\\n    uint256 offerIdentifier; // 0xe4\\r\\n    uint256 offerAmount; // 0x104\\r\\n    BasicOrderType basicOrderType; // 0x124\\r\\n    uint256 startTime; // 0x144\\r\\n    uint256 endTime; // 0x164\\r\\n    bytes32 zoneHash; // 0x184\\r\\n    uint256 salt; // 0x1a4\\r\\n    bytes32 offererConduitKey; // 0x1c4\\r\\n    bytes32 fulfillerConduitKey; // 0x1e4\\r\\n    uint256 totalOriginalAdditionalRecipients; // 0x204\\r\\n    AdditionalRecipient[] additionalRecipients; // 0x224\\r\\n    bytes signature; // 0x244\\r\\n    // Total length, excluding dynamic array data: 0x264 (580)\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Basic orders can supply any number of additional recipients, with the\\r\\n *      implied assumption that they are supplied from the offered ETH (or other\\r\\n *      native token) or ERC20 token for the order.\\r\\n */\\r\\nstruct AdditionalRecipient {\\r\\n    uint256 amount;\\r\\n    address payable recipient;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev The full set of order components, with the exception of the counter,\\r\\n *      must be supplied when fulfilling more sophisticated orders or groups of\\r\\n *      orders. The total number of original consideration items must also be\\r\\n *      supplied, as the caller may specify additional consideration items.\\r\\n */\\r\\nstruct OrderParameters {\\r\\n    address offerer; // 0x00\\r\\n    address zone; // 0x20\\r\\n    OfferItem[] offer; // 0x40\\r\\n    ConsiderationItem[] consideration; // 0x60\\r\\n    OrderType orderType; // 0x80\\r\\n    uint256 startTime; // 0xa0\\r\\n    uint256 endTime; // 0xc0\\r\\n    bytes32 zoneHash; // 0xe0\\r\\n    uint256 salt; // 0x100\\r\\n    bytes32 conduitKey; // 0x120\\r\\n    uint256 totalOriginalConsiderationItems; // 0x140\\r\\n    // offer.length                          // 0x160\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Orders require a signature in addition to the other order parameters.\\r\\n */\\r\\nstruct Order {\\r\\n    OrderParameters parameters;\\r\\n    bytes signature;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Advanced orders include a numerator (i.e. a fraction to attempt to fill)\\r\\n *      and a denominator (the total size of the order) in addition to the\\r\\n *      signature and other order parameters. It also supports an optional field\\r\\n *      for supplying extra data; this data will be included in a staticcall to\\r\\n *      `isValidOrderIncludingExtraData` on the zone for the order if the order\\r\\n *      type is restricted and the offerer or zone are not the caller.\\r\\n */\\r\\nstruct AdvancedOrder {\\r\\n    OrderParameters parameters;\\r\\n    uint120 numerator;\\r\\n    uint120 denominator;\\r\\n    bytes signature;\\r\\n    bytes extraData;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Orders can be validated (either explicitly via `validate`, or as a\\r\\n *      consequence of a full or partial fill), specifically cancelled (they can\\r\\n *      also be cancelled in bulk via incrementing a per-zone counter), and\\r\\n *      partially or fully filled (with the fraction filled represented by a\\r\\n *      numerator and denominator).\\r\\n */\\r\\nstruct OrderStatus {\\r\\n    bool isValidated;\\r\\n    bool isCancelled;\\r\\n    uint120 numerator;\\r\\n    uint120 denominator;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev A criteria resolver specifies an order, side (offer vs. consideration),\\r\\n *      and item index. It then provides a chosen identifier (i.e. tokenId)\\r\\n *      alongside a merkle proof demonstrating the identifier meets the required\\r\\n *      criteria.\\r\\n */\\r\\nstruct CriteriaResolver {\\r\\n    uint256 orderIndex;\\r\\n    Side side;\\r\\n    uint256 index;\\r\\n    uint256 identifier;\\r\\n    bytes32[] criteriaProof;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev A fulfillment is applied to a group of orders. It decrements a series of\\r\\n *      offer and consideration items, then generates a single execution\\r\\n *      element. A given fulfillment can be applied to as many offer and\\r\\n *      consideration items as desired, but must contain at least one offer and\\r\\n *      at least one consideration that match. The fulfillment must also remain\\r\\n *      consistent on all key parameters across all offer items (same offerer,\\r\\n *      token, type, tokenId, and conduit preference) as well as across all\\r\\n *      consideration items (token, type, tokenId, and recipient).\\r\\n */\\r\\nstruct Fulfillment {\\r\\n    FulfillmentComponent[] offerComponents;\\r\\n    FulfillmentComponent[] considerationComponents;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Each fulfillment component contains one index referencing a specific\\r\\n *      order and another referencing a specific offer or consideration item.\\r\\n */\\r\\nstruct FulfillmentComponent {\\r\\n    uint256 orderIndex;\\r\\n    uint256 itemIndex;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev An execution is triggered once all consideration items have been zeroed\\r\\n *      out. It sends the item in question from the offerer to the item's\\r\\n *      recipient, optionally sourcing approvals from either this contract\\r\\n *      directly or from the offerer's chosen conduit if one is specified. An\\r\\n *      execution is not provided as an argument, but rather is derived via\\r\\n *      orders, criteria resolvers, and fulfillments (where the total number of\\r\\n *      executions will be less than or equal to the total number of indicated\\r\\n *      fulfillments) and returned as part of `matchOrders`.\\r\\n */\\r\\nstruct Execution {\\r\\n    ReceivedItem item;\\r\\n    address offerer;\\r\\n    bytes32 conduitKey;\\r\\n}\\r\\n\",\"keccak256\":\"0x48439f01a8426f8c9ebb12d3efb59a5cc0ebbf8a0e8bedb5956bec8398fe213b\",\"license\":\"MIT\"},\"contracts/lib/CounterManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.13;\\r\\n\\r\\n// prettier-ignore\\r\\nimport {\\r\\n    ConsiderationEventsAndErrors\\r\\n} from \\\"../interfaces/ConsiderationEventsAndErrors.sol\\\";\\r\\n\\r\\nimport { ReentrancyGuard } from \\\"./ReentrancyGuard.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title CounterManager\\r\\n * @author 0age\\r\\n * @notice CounterManager contains a storage mapping and related functionality\\r\\n *         for retrieving and incrementing a per-offerer counter.\\r\\n */\\r\\ncontract CounterManager is ConsiderationEventsAndErrors, ReentrancyGuard {\\r\\n    // Only orders signed using an offerer's current counter are fulfillable.\\r\\n    mapping(address => uint256) private _counters;\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to cancel all orders from a given offerer with a\\r\\n     *      given zone in bulk by incrementing a counter. Note that only the\\r\\n     *      offerer may increment the counter.\\r\\n     *\\r\\n     * @return newCounter The new counter.\\r\\n     */\\r\\n    function _incrementCounter() internal returns (uint256 newCounter) {\\r\\n        // Ensure that the reentrancy guard is not currently set.\\r\\n        _assertNonReentrant();\\r\\n\\r\\n        // Skip overflow check as counter cannot be incremented that far.\\r\\n        unchecked {\\r\\n            // Increment current counter for the supplied offerer.\\r\\n            newCounter = ++_counters[msg.sender];\\r\\n        }\\r\\n\\r\\n        // Emit an event containing the new counter.\\r\\n        emit CounterIncremented(newCounter, msg.sender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal view function to retrieve the current counter for a given\\r\\n     *      offerer.\\r\\n     *\\r\\n     * @param offerer The offerer in question.\\r\\n     *\\r\\n     * @return currentCounter The current counter.\\r\\n     */\\r\\n    function _getCounter(address offerer)\\r\\n        internal\\r\\n        view\\r\\n        returns (uint256 currentCounter)\\r\\n    {\\r\\n        // Return the counter for the supplied offerer.\\r\\n        currentCounter = _counters[offerer];\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x97db36124387abcf240f437a2602528ae3b86714e8dfb1790cb9a73411324d84\",\"license\":\"MIT\"},\"contracts/lib/CriteriaResolution.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.13;\\r\\n\\r\\nimport { ItemType, Side } from \\\"./ConsiderationEnums.sol\\\";\\r\\n\\r\\n// prettier-ignore\\r\\nimport {\\r\\n    OfferItem,\\r\\n    ConsiderationItem,\\r\\n    OrderParameters,\\r\\n    AdvancedOrder,\\r\\n    CriteriaResolver\\r\\n} from \\\"./ConsiderationStructs.sol\\\";\\r\\n\\r\\nimport \\\"./ConsiderationConstants.sol\\\";\\r\\n\\r\\n// prettier-ignore\\r\\nimport {\\r\\n    CriteriaResolutionErrors\\r\\n} from \\\"../interfaces/CriteriaResolutionErrors.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title CriteriaResolution\\r\\n * @author 0age\\r\\n * @notice CriteriaResolution contains a collection of pure functions related to\\r\\n *         resolving criteria-based items.\\r\\n */\\r\\ncontract CriteriaResolution is CriteriaResolutionErrors {\\r\\n    /**\\r\\n     * @dev Internal pure function to apply criteria resolvers containing\\r\\n     *      specific token identifiers and associated proofs to order items.\\r\\n     *\\r\\n     * @param advancedOrders     The orders to apply criteria resolvers to.\\r\\n     * @param criteriaResolvers  An array where each element contains a\\r\\n     *                           reference to a specific order as well as that\\r\\n     *                           order's offer or consideration, a token\\r\\n     *                           identifier, and a proof that the supplied token\\r\\n     *                           identifier is contained in the order's merkle\\r\\n     *                           root. Note that a root of zero indicates that\\r\\n     *                           any transferable token identifier is valid and\\r\\n     *                           that no proof needs to be supplied.\\r\\n     */\\r\\n    function _applyCriteriaResolvers(\\r\\n        AdvancedOrder[] memory advancedOrders,\\r\\n        CriteriaResolver[] memory criteriaResolvers\\r\\n    ) internal pure {\\r\\n        // Skip overflow checks as all for loops are indexed starting at zero.\\r\\n        unchecked {\\r\\n            // Retrieve length of criteria resolvers array and place on stack.\\r\\n            uint256 totalCriteriaResolvers = criteriaResolvers.length;\\r\\n\\r\\n            // Retrieve length of orders array and place on stack.\\r\\n            uint256 totalAdvancedOrders = advancedOrders.length;\\r\\n\\r\\n            // Iterate over each criteria resolver.\\r\\n            for (uint256 i = 0; i < totalCriteriaResolvers; ++i) {\\r\\n                // Retrieve the criteria resolver.\\r\\n                CriteriaResolver memory criteriaResolver = (\\r\\n                    criteriaResolvers[i]\\r\\n                );\\r\\n\\r\\n                // Read the order index from memory and place it on the stack.\\r\\n                uint256 orderIndex = criteriaResolver.orderIndex;\\r\\n\\r\\n                // Ensure that the order index is in range.\\r\\n                if (orderIndex >= totalAdvancedOrders) {\\r\\n                    revert OrderCriteriaResolverOutOfRange();\\r\\n                }\\r\\n\\r\\n                // Skip criteria resolution for order if not fulfilled.\\r\\n                if (advancedOrders[orderIndex].numerator == 0) {\\r\\n                    continue;\\r\\n                }\\r\\n\\r\\n                // Retrieve the parameters for the order.\\r\\n                OrderParameters memory orderParameters = (\\r\\n                    advancedOrders[orderIndex].parameters\\r\\n                );\\r\\n\\r\\n                // Read component index from memory and place it on the stack.\\r\\n                uint256 componentIndex = criteriaResolver.index;\\r\\n\\r\\n                // Declare values for item's type and criteria.\\r\\n                ItemType itemType;\\r\\n                uint256 identifierOrCriteria;\\r\\n\\r\\n                // If the criteria resolver refers to an offer item...\\r\\n                if (criteriaResolver.side == Side.OFFER) {\\r\\n                    // Retrieve the offer.\\r\\n                    OfferItem[] memory offer = orderParameters.offer;\\r\\n\\r\\n                    // Ensure that the component index is in range.\\r\\n                    if (componentIndex >= offer.length) {\\r\\n                        revert OfferCriteriaResolverOutOfRange();\\r\\n                    }\\r\\n\\r\\n                    // Retrieve relevant item using the component index.\\r\\n                    OfferItem memory offerItem = offer[componentIndex];\\r\\n\\r\\n                    // Read item type and criteria from memory & place on stack.\\r\\n                    itemType = offerItem.itemType;\\r\\n                    identifierOrCriteria = offerItem.identifierOrCriteria;\\r\\n\\r\\n                    // Optimistically update item type to remove criteria usage.\\r\\n                    // Use assembly to operate on ItemType enum as a number.\\r\\n                    ItemType newItemType;\\r\\n                    assembly {\\r\\n                        // Item type 4 becomes 2 and item type 5 becomes 3.\\r\\n                        newItemType := sub(3, eq(itemType, 4))\\r\\n                    }\\r\\n                    offerItem.itemType = newItemType;\\r\\n\\r\\n                    // Optimistically update identifier w/ supplied identifier.\\r\\n                    offerItem.identifierOrCriteria = criteriaResolver\\r\\n                        .identifier;\\r\\n                } else {\\r\\n                    // Otherwise, the resolver refers to a consideration item.\\r\\n                    ConsiderationItem[] memory consideration = (\\r\\n                        orderParameters.consideration\\r\\n                    );\\r\\n\\r\\n                    // Ensure that the component index is in range.\\r\\n                    if (componentIndex >= consideration.length) {\\r\\n                        revert ConsiderationCriteriaResolverOutOfRange();\\r\\n                    }\\r\\n\\r\\n                    // Retrieve relevant item using order and component index.\\r\\n                    ConsiderationItem memory considerationItem = (\\r\\n                        consideration[componentIndex]\\r\\n                    );\\r\\n\\r\\n                    // Read item type and criteria from memory & place on stack.\\r\\n                    itemType = considerationItem.itemType;\\r\\n                    identifierOrCriteria = (\\r\\n                        considerationItem.identifierOrCriteria\\r\\n                    );\\r\\n\\r\\n                    // Optimistically update item type to remove criteria usage.\\r\\n                    // Use assembly to operate on ItemType enum as a number.\\r\\n                    ItemType newItemType;\\r\\n                    assembly {\\r\\n                        // Item type 4 becomes 2 and item type 5 becomes 3.\\r\\n                        newItemType := sub(3, eq(itemType, 4))\\r\\n                    }\\r\\n                    considerationItem.itemType = newItemType;\\r\\n\\r\\n                    // Optimistically update identifier w/ supplied identifier.\\r\\n                    considerationItem.identifierOrCriteria = (\\r\\n                        criteriaResolver.identifier\\r\\n                    );\\r\\n                }\\r\\n\\r\\n                // Ensure the specified item type indicates criteria usage.\\r\\n                if (!_isItemWithCriteria(itemType)) {\\r\\n                    revert CriteriaNotEnabledForItem();\\r\\n                }\\r\\n\\r\\n                // If criteria is not 0 (i.e. a collection-wide offer)...\\r\\n                if (identifierOrCriteria != uint256(0)) {\\r\\n                    // Verify identifier inclusion in criteria root using proof.\\r\\n                    _verifyProof(\\r\\n                        criteriaResolver.identifier,\\r\\n                        identifierOrCriteria,\\r\\n                        criteriaResolver.criteriaProof\\r\\n                    );\\r\\n                }\\r\\n            }\\r\\n\\r\\n            // Iterate over each advanced order.\\r\\n            for (uint256 i = 0; i < totalAdvancedOrders; ++i) {\\r\\n                // Retrieve the advanced order.\\r\\n                AdvancedOrder memory advancedOrder = advancedOrders[i];\\r\\n\\r\\n                // Skip criteria resolution for order if not fulfilled.\\r\\n                if (advancedOrder.numerator == 0) {\\r\\n                    continue;\\r\\n                }\\r\\n\\r\\n                // Retrieve the parameters for the order.\\r\\n                OrderParameters memory orderParameters = (\\r\\n                    advancedOrder.parameters\\r\\n                );\\r\\n\\r\\n                // Read consideration length from memory and place on stack.\\r\\n                uint256 totalItems = orderParameters.consideration.length;\\r\\n\\r\\n                // Iterate over each consideration item on the order.\\r\\n                for (uint256 j = 0; j < totalItems; ++j) {\\r\\n                    // Ensure item type no longer indicates criteria usage.\\r\\n                    if (\\r\\n                        _isItemWithCriteria(\\r\\n                            orderParameters.consideration[j].itemType\\r\\n                        )\\r\\n                    ) {\\r\\n                        revert UnresolvedConsiderationCriteria();\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                // Read offer length from memory and place on stack.\\r\\n                totalItems = orderParameters.offer.length;\\r\\n\\r\\n                // Iterate over each offer item on the order.\\r\\n                for (uint256 j = 0; j < totalItems; ++j) {\\r\\n                    // Ensure item type no longer indicates criteria usage.\\r\\n                    if (\\r\\n                        _isItemWithCriteria(orderParameters.offer[j].itemType)\\r\\n                    ) {\\r\\n                        revert UnresolvedOfferCriteria();\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal pure function to check whether a given item type represents\\r\\n     *      a criteria-based ERC721 or ERC1155 item (e.g. an item that can be\\r\\n     *      resolved to one of a number of different identifiers at the time of\\r\\n     *      order fulfillment).\\r\\n     *\\r\\n     * @param itemType The item type in question.\\r\\n     *\\r\\n     * @return withCriteria A boolean indicating that the item type in question\\r\\n     *                      represents a criteria-based item.\\r\\n     */\\r\\n    function _isItemWithCriteria(ItemType itemType)\\r\\n        internal\\r\\n        pure\\r\\n        returns (bool withCriteria)\\r\\n    {\\r\\n        // ERC721WithCriteria is ItemType 4. ERC1155WithCriteria is ItemType 5.\\r\\n        assembly {\\r\\n            withCriteria := gt(itemType, 3)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal pure function to ensure that a given element is contained\\r\\n     *      in a merkle root via a supplied proof.\\r\\n     *\\r\\n     * @param leaf  The element for which to prove inclusion.\\r\\n     * @param root  The merkle root that inclusion will be proved against.\\r\\n     * @param proof The merkle proof.\\r\\n     */\\r\\n    function _verifyProof(\\r\\n        uint256 leaf,\\r\\n        uint256 root,\\r\\n        bytes32[] memory proof\\r\\n    ) internal pure {\\r\\n        // Declare a variable that will be used to determine proof validity.\\r\\n        bool isValid;\\r\\n\\r\\n        // Utilize assembly to efficiently verify the proof against the root.\\r\\n        assembly {\\r\\n            // Store the leaf at the beginning of scratch space.\\r\\n            mstore(0, leaf)\\r\\n\\r\\n            // Derive the hash of the leaf to use as the initial proof element.\\r\\n            let computedHash := keccak256(0, OneWord)\\r\\n\\r\\n            // Based on: https://github.com/Rari-Capital/solmate/blob/v7/src/utils/MerkleProof.sol\\r\\n            // Get memory start location of the first element in proof array.\\r\\n            let data := add(proof, OneWord)\\r\\n\\r\\n            // Iterate over each proof element to compute the root hash.\\r\\n            for {\\r\\n                // Left shift by 5 is equivalent to multiplying by 0x20.\\r\\n                let end := add(data, shl(5, mload(proof)))\\r\\n            } lt(data, end) {\\r\\n                // Increment by one word at a time.\\r\\n                data := add(data, OneWord)\\r\\n            } {\\r\\n                // Get the proof element.\\r\\n                let loadedData := mload(data)\\r\\n\\r\\n                // Sort proof elements and place them in scratch space.\\r\\n                // Slot of `computedHash` in scratch space.\\r\\n                // If the condition is true: 0x20, otherwise: 0x00.\\r\\n                let scratch := shl(5, gt(computedHash, loadedData))\\r\\n\\r\\n                // Store elements to hash contiguously in scratch space. Scratch\\r\\n                // space is 64 bytes (0x00 - 0x3f) & both elements are 32 bytes.\\r\\n                mstore(scratch, computedHash)\\r\\n                mstore(xor(scratch, OneWord), loadedData)\\r\\n\\r\\n                // Derive the updated hash.\\r\\n                computedHash := keccak256(0, TwoWords)\\r\\n            }\\r\\n\\r\\n            // Compare the final hash to the supplied root.\\r\\n            isValid := eq(computedHash, root)\\r\\n        }\\r\\n\\r\\n        // Revert if computed hash does not equal supplied root.\\r\\n        if (!isValid) {\\r\\n            revert InvalidProof();\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x194772b00adbdcc6c2e10a58ec4b905e6d0e255cf66af98d7f2aa42ded2ee9cd\",\"license\":\"MIT\"},\"contracts/lib/Executor.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.13;\\r\\n\\r\\nimport { ConduitInterface } from \\\"../interfaces/ConduitInterface.sol\\\";\\r\\n\\r\\nimport { ConduitItemType } from \\\"../conduit/lib/ConduitEnums.sol\\\";\\r\\n\\r\\nimport { ItemType } from \\\"./ConsiderationEnums.sol\\\";\\r\\n\\r\\nimport { ReceivedItem } from \\\"./ConsiderationStructs.sol\\\";\\r\\n\\r\\nimport { Verifiers } from \\\"./Verifiers.sol\\\";\\r\\n\\r\\nimport { TokenTransferrer } from \\\"./TokenTransferrer.sol\\\";\\r\\n\\r\\nimport \\\"./ConsiderationConstants.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Executor\\r\\n * @author 0age\\r\\n * @notice Executor contains functions related to processing executions (i.e.\\r\\n *         transferring items, either directly or via conduits).\\r\\n */\\r\\ncontract Executor is Verifiers, TokenTransferrer {\\r\\n    /**\\r\\n     * @dev Derive and set hashes, reference chainId, and associated domain\\r\\n     *      separator during deployment.\\r\\n     *\\r\\n     * @param conduitController A contract that deploys conduits, or proxies\\r\\n     *                          that may optionally be used to transfer approved\\r\\n     *                          ERC20/721/1155 tokens.\\r\\n     */\\r\\n    constructor(address conduitController) Verifiers(conduitController) {}\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to transfer a given item, either directly or via\\r\\n     *      a corresponding conduit.\\r\\n     *\\r\\n     * @param item        The item to transfer, including an amount and a\\r\\n     *                    recipient.\\r\\n     * @param from        The account supplying the item.\\r\\n     * @param conduitKey  A bytes32 value indicating what corresponding conduit,\\r\\n     *                    if any, to source token approvals from. The zero hash\\r\\n     *                    signifies that no conduit should be used, with direct\\r\\n     *                    approvals set on this contract.\\r\\n     * @param accumulator An open-ended array that collects transfers to execute\\r\\n     *                    against a given conduit in a single call.\\r\\n     */\\r\\n    function _transfer(\\r\\n        ReceivedItem memory item,\\r\\n        address from,\\r\\n        bytes32 conduitKey,\\r\\n        bytes memory accumulator\\r\\n    ) internal {\\r\\n        // If the item type indicates Ether or a native token...\\r\\n        if (item.itemType == ItemType.NATIVE) {\\r\\n            // Ensure neither the token nor the identifier parameters are set.\\r\\n            if ((uint160(item.token) | item.identifier) != 0) {\\r\\n                revert UnusedItemParameters();\\r\\n            }\\r\\n\\r\\n            // transfer the native tokens to the recipient.\\r\\n            _transferEth(item.recipient, item.amount);\\r\\n        } else if (item.itemType == ItemType.ERC20) {\\r\\n            // Ensure that no identifier is supplied.\\r\\n            if (item.identifier != 0) {\\r\\n                revert UnusedItemParameters();\\r\\n            }\\r\\n\\r\\n            // Transfer ERC20 tokens from the source to the recipient.\\r\\n            _transferERC20(\\r\\n                item.token,\\r\\n                from,\\r\\n                item.recipient,\\r\\n                item.amount,\\r\\n                conduitKey,\\r\\n                accumulator\\r\\n            );\\r\\n        } else if (item.itemType == ItemType.ERC721) {\\r\\n            // Transfer ERC721 token from the source to the recipient.\\r\\n            _transferERC721(\\r\\n                item.token,\\r\\n                from,\\r\\n                item.recipient,\\r\\n                item.identifier,\\r\\n                item.amount,\\r\\n                conduitKey,\\r\\n                accumulator\\r\\n            );\\r\\n        } else {\\r\\n            // Transfer ERC1155 token from the source to the recipient.\\r\\n            _transferERC1155(\\r\\n                item.token,\\r\\n                from,\\r\\n                item.recipient,\\r\\n                item.identifier,\\r\\n                item.amount,\\r\\n                conduitKey,\\r\\n                accumulator\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to transfer an individual ERC721 or ERC1155 item\\r\\n     *      from a given originator to a given recipient. The accumulator will\\r\\n     *      be bypassed, meaning that this function should be utilized in cases\\r\\n     *      where multiple item transfers can be accumulated into a single\\r\\n     *      conduit call. Sufficient approvals must be set, either on the\\r\\n     *      respective conduit or on this contract itself.\\r\\n     *\\r\\n     * @param itemType   The type of item to transfer, either ERC721 or ERC1155.\\r\\n     * @param token      The token to transfer.\\r\\n     * @param from       The originator of the transfer.\\r\\n     * @param to         The recipient of the transfer.\\r\\n     * @param identifier The tokenId to transfer.\\r\\n     * @param amount     The amount to transfer.\\r\\n     * @param conduitKey A bytes32 value indicating what corresponding conduit,\\r\\n     *                   if any, to source token approvals from. The zero hash\\r\\n     *                   signifies that no conduit should be used, with direct\\r\\n     *                   approvals set on this contract.\\r\\n     */\\r\\n    function _transferIndividual721Or1155Item(\\r\\n        ItemType itemType,\\r\\n        address token,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 identifier,\\r\\n        uint256 amount,\\r\\n        bytes32 conduitKey\\r\\n    ) internal {\\r\\n        // Determine if the transfer is to be performed via a conduit.\\r\\n        if (conduitKey != bytes32(0)) {\\r\\n            // Use free memory pointer as calldata offset for the conduit call.\\r\\n            uint256 callDataOffset;\\r\\n\\r\\n            // Utilize assembly to place each argument in free memory.\\r\\n            assembly {\\r\\n                // Retrieve the free memory pointer and use it as the offset.\\r\\n                callDataOffset := mload(FreeMemoryPointerSlot)\\r\\n\\r\\n                // Write ConduitInterface.execute.selector to memory.\\r\\n                mstore(callDataOffset, Conduit_execute_signature)\\r\\n\\r\\n                // Write the offset to the ConduitTransfer array in memory.\\r\\n                mstore(\\r\\n                    add(\\r\\n                        callDataOffset,\\r\\n                        Conduit_execute_ConduitTransfer_offset_ptr\\r\\n                    ),\\r\\n                    Conduit_execute_ConduitTransfer_ptr\\r\\n                )\\r\\n\\r\\n                // Write the length of the ConduitTransfer array to memory.\\r\\n                mstore(\\r\\n                    add(\\r\\n                        callDataOffset,\\r\\n                        Conduit_execute_ConduitTransfer_length_ptr\\r\\n                    ),\\r\\n                    Conduit_execute_ConduitTransfer_length\\r\\n                )\\r\\n\\r\\n                // Write the item type to memory.\\r\\n                mstore(\\r\\n                    add(callDataOffset, Conduit_execute_transferItemType_ptr),\\r\\n                    itemType\\r\\n                )\\r\\n\\r\\n                // Write the token to memory.\\r\\n                mstore(\\r\\n                    add(callDataOffset, Conduit_execute_transferToken_ptr),\\r\\n                    token\\r\\n                )\\r\\n\\r\\n                // Write the transfer source to memory.\\r\\n                mstore(\\r\\n                    add(callDataOffset, Conduit_execute_transferFrom_ptr),\\r\\n                    from\\r\\n                )\\r\\n\\r\\n                // Write the transfer recipient to memory.\\r\\n                mstore(add(callDataOffset, Conduit_execute_transferTo_ptr), to)\\r\\n\\r\\n                // Write the token identifier to memory.\\r\\n                mstore(\\r\\n                    add(callDataOffset, Conduit_execute_transferIdentifier_ptr),\\r\\n                    identifier\\r\\n                )\\r\\n\\r\\n                // Write the transfer amount to memory.\\r\\n                mstore(\\r\\n                    add(callDataOffset, Conduit_execute_transferAmount_ptr),\\r\\n                    amount\\r\\n                )\\r\\n            }\\r\\n\\r\\n            // Perform the call to the conduit.\\r\\n            _callConduitUsingOffsets(\\r\\n                conduitKey,\\r\\n                callDataOffset,\\r\\n                OneConduitExecute_size\\r\\n            );\\r\\n        } else {\\r\\n            // Otherwise, determine whether it is an ERC721 or ERC1155 item.\\r\\n            if (itemType == ItemType.ERC721) {\\r\\n                // Ensure that exactly one 721 item is being transferred.\\r\\n                if (amount != 1) {\\r\\n                    revert InvalidERC721TransferAmount();\\r\\n                }\\r\\n\\r\\n                // Perform transfer via the token contract directly.\\r\\n                _performERC721Transfer(token, from, to, identifier);\\r\\n            } else {\\r\\n                // Perform transfer via the token contract directly.\\r\\n                _performERC1155Transfer(token, from, to, identifier, amount);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to transfer Ether or other native tokens to a\\r\\n     *      given recipient.\\r\\n     *\\r\\n     * @param to     The recipient of the transfer.\\r\\n     * @param amount The amount to transfer.\\r\\n     */\\r\\n    function _transferEth(address payable to, uint256 amount) internal {\\r\\n        // Ensure that the supplied amount is non-zero.\\r\\n        _assertNonZeroAmount(amount);\\r\\n\\r\\n        // Declare a variable indicating whether the call was successful or not.\\r\\n        bool success;\\r\\n\\r\\n        assembly {\\r\\n            // Transfer the ETH and store if it succeeded or not.\\r\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\r\\n        }\\r\\n\\r\\n        // If the call fails...\\r\\n        if (!success) {\\r\\n            // Revert and pass the revert reason along if one was returned.\\r\\n            _revertWithReasonIfOneIsReturned();\\r\\n\\r\\n            // Otherwise, revert with a generic error message.\\r\\n            revert EtherTransferGenericFailure(to, amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to transfer ERC20 tokens from a given originator\\r\\n     *      to a given recipient using a given conduit if applicable. Sufficient\\r\\n     *      approvals must be set on this contract or on a respective conduit.\\r\\n     *\\r\\n     * @param token       The ERC20 token to transfer.\\r\\n     * @param from        The originator of the transfer.\\r\\n     * @param to          The recipient of the transfer.\\r\\n     * @param amount      The amount to transfer.\\r\\n     * @param conduitKey  A bytes32 value indicating what corresponding conduit,\\r\\n     *                    if any, to source token approvals from. The zero hash\\r\\n     *                    signifies that no conduit should be used, with direct\\r\\n     *                    approvals set on this contract.\\r\\n     * @param accumulator An open-ended array that collects transfers to execute\\r\\n     *                    against a given conduit in a single call.\\r\\n     */\\r\\n    function _transferERC20(\\r\\n        address token,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount,\\r\\n        bytes32 conduitKey,\\r\\n        bytes memory accumulator\\r\\n    ) internal {\\r\\n        // Ensure that the supplied amount is non-zero.\\r\\n        _assertNonZeroAmount(amount);\\r\\n\\r\\n        // Trigger accumulated transfers if the conduits differ.\\r\\n        _triggerIfArmedAndNotAccumulatable(accumulator, conduitKey);\\r\\n\\r\\n        // If no conduit has been specified...\\r\\n        if (conduitKey == bytes32(0)) {\\r\\n            // Perform the token transfer directly.\\r\\n            _performERC20Transfer(token, from, to, amount);\\r\\n        } else {\\r\\n            // Insert the call to the conduit into the accumulator.\\r\\n            _insert(\\r\\n                conduitKey,\\r\\n                accumulator,\\r\\n                ConduitItemType.ERC20,\\r\\n                token,\\r\\n                from,\\r\\n                to,\\r\\n                uint256(0),\\r\\n                amount\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to transfer a single ERC721 token from a given\\r\\n     *      originator to a given recipient. Sufficient approvals must be set,\\r\\n     *      either on the respective conduit or on this contract itself.\\r\\n     *\\r\\n     * @param token       The ERC721 token to transfer.\\r\\n     * @param from        The originator of the transfer.\\r\\n     * @param to          The recipient of the transfer.\\r\\n     * @param identifier  The tokenId to transfer (must be 1 for ERC721).\\r\\n     * @param amount      The amount to transfer.\\r\\n     * @param conduitKey  A bytes32 value indicating what corresponding conduit,\\r\\n     *                    if any, to source token approvals from. The zero hash\\r\\n     *                    signifies that no conduit should be used, with direct\\r\\n     *                    approvals set on this contract.\\r\\n     * @param accumulator An open-ended array that collects transfers to execute\\r\\n     *                    against a given conduit in a single call.\\r\\n     */\\r\\n    function _transferERC721(\\r\\n        address token,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 identifier,\\r\\n        uint256 amount,\\r\\n        bytes32 conduitKey,\\r\\n        bytes memory accumulator\\r\\n    ) internal {\\r\\n        // Trigger accumulated transfers if the conduits differ.\\r\\n        _triggerIfArmedAndNotAccumulatable(accumulator, conduitKey);\\r\\n\\r\\n        // If no conduit has been specified...\\r\\n        if (conduitKey == bytes32(0)) {\\r\\n            // Ensure that exactly one 721 item is being transferred.\\r\\n            if (amount != 1) {\\r\\n                revert InvalidERC721TransferAmount();\\r\\n            }\\r\\n\\r\\n            // Perform transfer via the token contract directly.\\r\\n            _performERC721Transfer(token, from, to, identifier);\\r\\n        } else {\\r\\n            // Insert the call to the conduit into the accumulator.\\r\\n            _insert(\\r\\n                conduitKey,\\r\\n                accumulator,\\r\\n                ConduitItemType.ERC721,\\r\\n                token,\\r\\n                from,\\r\\n                to,\\r\\n                identifier,\\r\\n                amount\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to transfer ERC1155 tokens from a given originator\\r\\n     *      to a given recipient. Sufficient approvals must be set, either on\\r\\n     *      the respective conduit or on this contract itself.\\r\\n     *\\r\\n     * @param token       The ERC1155 token to transfer.\\r\\n     * @param from        The originator of the transfer.\\r\\n     * @param to          The recipient of the transfer.\\r\\n     * @param identifier  The id to transfer.\\r\\n     * @param amount      The amount to transfer.\\r\\n     * @param conduitKey  A bytes32 value indicating what corresponding conduit,\\r\\n     *                    if any, to source token approvals from. The zero hash\\r\\n     *                    signifies that no conduit should be used, with direct\\r\\n     *                    approvals set on this contract.\\r\\n     * @param accumulator An open-ended array that collects transfers to execute\\r\\n     *                    against a given conduit in a single call.\\r\\n     */\\r\\n    function _transferERC1155(\\r\\n        address token,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 identifier,\\r\\n        uint256 amount,\\r\\n        bytes32 conduitKey,\\r\\n        bytes memory accumulator\\r\\n    ) internal {\\r\\n        // Ensure that the supplied amount is non-zero.\\r\\n        _assertNonZeroAmount(amount);\\r\\n\\r\\n        // Trigger accumulated transfers if the conduits differ.\\r\\n        _triggerIfArmedAndNotAccumulatable(accumulator, conduitKey);\\r\\n\\r\\n        // If no conduit has been specified...\\r\\n        if (conduitKey == bytes32(0)) {\\r\\n            // Perform transfer via the token contract directly.\\r\\n            _performERC1155Transfer(token, from, to, identifier, amount);\\r\\n        } else {\\r\\n            // Insert the call to the conduit into the accumulator.\\r\\n            _insert(\\r\\n                conduitKey,\\r\\n                accumulator,\\r\\n                ConduitItemType.ERC1155,\\r\\n                token,\\r\\n                from,\\r\\n                to,\\r\\n                identifier,\\r\\n                amount\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to trigger a call to the conduit currently held by\\r\\n     *      the accumulator if the accumulator contains item transfers (i.e. it\\r\\n     *      is \\\"armed\\\") and the supplied conduit key does not match the key held\\r\\n     *      by the accumulator.\\r\\n     *\\r\\n     * @param accumulator An open-ended array that collects transfers to execute\\r\\n     *                    against a given conduit in a single call.\\r\\n     * @param conduitKey  A bytes32 value indicating what corresponding conduit,\\r\\n     *                    if any, to source token approvals from. The zero hash\\r\\n     *                    signifies that no conduit should be used, with direct\\r\\n     *                    approvals set on this contract.\\r\\n     */\\r\\n    function _triggerIfArmedAndNotAccumulatable(\\r\\n        bytes memory accumulator,\\r\\n        bytes32 conduitKey\\r\\n    ) internal {\\r\\n        // Retrieve the current conduit key from the accumulator.\\r\\n        bytes32 accumulatorConduitKey = _getAccumulatorConduitKey(accumulator);\\r\\n\\r\\n        // Perform conduit call if the set key does not match the supplied key.\\r\\n        if (accumulatorConduitKey != conduitKey) {\\r\\n            _triggerIfArmed(accumulator);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to trigger a call to the conduit currently held by\\r\\n     *      the accumulator if the accumulator contains item transfers (i.e. it\\r\\n     *      is \\\"armed\\\").\\r\\n     *\\r\\n     * @param accumulator An open-ended array that collects transfers to execute\\r\\n     *                    against a given conduit in a single call.\\r\\n     */\\r\\n    function _triggerIfArmed(bytes memory accumulator) internal {\\r\\n        // Exit if the accumulator is not \\\"armed\\\".\\r\\n        if (accumulator.length != AccumulatorArmed) {\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        // Retrieve the current conduit key from the accumulator.\\r\\n        bytes32 accumulatorConduitKey = _getAccumulatorConduitKey(accumulator);\\r\\n\\r\\n        // Perform conduit call.\\r\\n        _trigger(accumulatorConduitKey, accumulator);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to trigger a call to the conduit corresponding to\\r\\n     *      a given conduit key, supplying all accumulated item transfers. The\\r\\n     *      accumulator will be \\\"disarmed\\\" and reset in the process.\\r\\n     *\\r\\n     * @param conduitKey  A bytes32 value indicating what corresponding conduit,\\r\\n     *                    if any, to source token approvals from. The zero hash\\r\\n     *                    signifies that no conduit should be used, with direct\\r\\n     *                    approvals set on this contract.\\r\\n     * @param accumulator An open-ended array that collects transfers to execute\\r\\n     *                    against a given conduit in a single call.\\r\\n     */\\r\\n    function _trigger(bytes32 conduitKey, bytes memory accumulator) internal {\\r\\n        // Declare variables for offset in memory & size of calldata to conduit.\\r\\n        uint256 callDataOffset;\\r\\n        uint256 callDataSize;\\r\\n\\r\\n        // Call the conduit with all the accumulated transfers.\\r\\n        assembly {\\r\\n            // Call begins at third word; the first is length or \\\"armed\\\" status,\\r\\n            // and the second is the current conduit key.\\r\\n            callDataOffset := add(accumulator, TwoWords)\\r\\n\\r\\n            // 68 + items * 192\\r\\n            callDataSize := add(\\r\\n                Accumulator_array_offset_ptr,\\r\\n                mul(\\r\\n                    mload(add(accumulator, Accumulator_array_length_ptr)),\\r\\n                    Conduit_transferItem_size\\r\\n                )\\r\\n            )\\r\\n        }\\r\\n\\r\\n        // Call conduit derived from conduit key & supply accumulated transfers.\\r\\n        _callConduitUsingOffsets(conduitKey, callDataOffset, callDataSize);\\r\\n\\r\\n        // Reset accumulator length to signal that it is now \\\"disarmed\\\".\\r\\n        assembly {\\r\\n            mstore(accumulator, AccumulatorDisarmed)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to perform a call to the conduit corresponding to\\r\\n     *      a given conduit key based on the offset and size of the calldata in\\r\\n     *      question in memory.\\r\\n     *\\r\\n     * @param conduitKey     A bytes32 value indicating what corresponding\\r\\n     *                       conduit, if any, to source token approvals from.\\r\\n     *                       The zero hash signifies that no conduit should be\\r\\n     *                       used, with direct approvals set on this contract.\\r\\n     * @param callDataOffset The memory pointer where calldata is contained.\\r\\n     * @param callDataSize   The size of calldata in memory.\\r\\n     */\\r\\n    function _callConduitUsingOffsets(\\r\\n        bytes32 conduitKey,\\r\\n        uint256 callDataOffset,\\r\\n        uint256 callDataSize\\r\\n    ) internal {\\r\\n        // Derive the address of the conduit using the conduit key.\\r\\n        address conduit = _deriveConduit(conduitKey);\\r\\n\\r\\n        bool success;\\r\\n        bytes4 result;\\r\\n\\r\\n        // call the conduit.\\r\\n        assembly {\\r\\n            // Ensure first word of scratch space is empty.\\r\\n            mstore(0, 0)\\r\\n\\r\\n            // Perform call, placing first word of return data in scratch space.\\r\\n            success := call(\\r\\n                gas(),\\r\\n                conduit,\\r\\n                0,\\r\\n                callDataOffset,\\r\\n                callDataSize,\\r\\n                0,\\r\\n                OneWord\\r\\n            )\\r\\n\\r\\n            // Take value from scratch space and place it on the stack.\\r\\n            result := mload(0)\\r\\n        }\\r\\n\\r\\n        // If the call failed...\\r\\n        if (!success) {\\r\\n            // Pass along whatever revert reason was given by the conduit.\\r\\n            _revertWithReasonIfOneIsReturned();\\r\\n\\r\\n            // Otherwise, revert with a generic error.\\r\\n            revert InvalidCallToConduit(conduit);\\r\\n        }\\r\\n\\r\\n        // Ensure result was extracted and matches EIP-1271 magic value.\\r\\n        if (result != ConduitInterface.execute.selector) {\\r\\n            revert InvalidConduit(conduitKey, conduit);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal pure function to retrieve the current conduit key set for\\r\\n     *      the accumulator.\\r\\n     *\\r\\n     * @param accumulator An open-ended array that collects transfers to execute\\r\\n     *                    against a given conduit in a single call.\\r\\n     *\\r\\n     * @return accumulatorConduitKey The conduit key currently set for the\\r\\n     *                               accumulator.\\r\\n     */\\r\\n    function _getAccumulatorConduitKey(bytes memory accumulator)\\r\\n        internal\\r\\n        pure\\r\\n        returns (bytes32 accumulatorConduitKey)\\r\\n    {\\r\\n        // Retrieve the current conduit key from the accumulator.\\r\\n        assembly {\\r\\n            accumulatorConduitKey := mload(\\r\\n                add(accumulator, Accumulator_conduitKey_ptr)\\r\\n            )\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal pure function to place an item transfer into an accumulator\\r\\n     *      that collects a series of transfers to execute against a given\\r\\n     *      conduit in a single call.\\r\\n     *\\r\\n     * @param conduitKey  A bytes32 value indicating what corresponding conduit,\\r\\n     *                    if any, to source token approvals from. The zero hash\\r\\n     *                    signifies that no conduit should be used, with direct\\r\\n     *                    approvals set on this contract.\\r\\n     * @param accumulator An open-ended array that collects transfers to execute\\r\\n     *                    against a given conduit in a single call.\\r\\n     * @param itemType    The type of the item to transfer.\\r\\n     * @param token       The token to transfer.\\r\\n     * @param from        The originator of the transfer.\\r\\n     * @param to          The recipient of the transfer.\\r\\n     * @param identifier  The tokenId to transfer.\\r\\n     * @param amount      The amount to transfer.\\r\\n     */\\r\\n    function _insert(\\r\\n        bytes32 conduitKey,\\r\\n        bytes memory accumulator,\\r\\n        ConduitItemType itemType,\\r\\n        address token,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 identifier,\\r\\n        uint256 amount\\r\\n    ) internal pure {\\r\\n        uint256 elements;\\r\\n        // \\\"Arm\\\" and prime accumulator if it's not already armed. The sentinel\\r\\n        // value is held in the length of the accumulator array.\\r\\n        if (accumulator.length == AccumulatorDisarmed) {\\r\\n            elements = 1;\\r\\n            bytes4 selector = ConduitInterface.execute.selector;\\r\\n            assembly {\\r\\n                mstore(accumulator, AccumulatorArmed) // \\\"arm\\\" the accumulator.\\r\\n                mstore(add(accumulator, Accumulator_conduitKey_ptr), conduitKey)\\r\\n                mstore(add(accumulator, Accumulator_selector_ptr), selector)\\r\\n                mstore(\\r\\n                    add(accumulator, Accumulator_array_offset_ptr),\\r\\n                    Accumulator_array_offset\\r\\n                )\\r\\n                mstore(add(accumulator, Accumulator_array_length_ptr), elements)\\r\\n            }\\r\\n        } else {\\r\\n            // Otherwise, increase the number of elements by one.\\r\\n            assembly {\\r\\n                elements := add(\\r\\n                    mload(add(accumulator, Accumulator_array_length_ptr)),\\r\\n                    1\\r\\n                )\\r\\n                mstore(add(accumulator, Accumulator_array_length_ptr), elements)\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Insert the item.\\r\\n        assembly {\\r\\n            let itemPointer := sub(\\r\\n                add(accumulator, mul(elements, Conduit_transferItem_size)),\\r\\n                Accumulator_itemSizeOffsetDifference\\r\\n            )\\r\\n            mstore(itemPointer, itemType)\\r\\n            mstore(add(itemPointer, Conduit_transferItem_token_ptr), token)\\r\\n            mstore(add(itemPointer, Conduit_transferItem_from_ptr), from)\\r\\n            mstore(add(itemPointer, Conduit_transferItem_to_ptr), to)\\r\\n            mstore(\\r\\n                add(itemPointer, Conduit_transferItem_identifier_ptr),\\r\\n                identifier\\r\\n            )\\r\\n            mstore(add(itemPointer, Conduit_transferItem_amount_ptr), amount)\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xc5eae239090ddc0d66f343c5d69934cd911ced318ec147273d5f0169f909b19d\",\"license\":\"MIT\"},\"contracts/lib/FulfillmentApplier.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.13;\\r\\n\\r\\nimport { ItemType, Side } from \\\"./ConsiderationEnums.sol\\\";\\r\\n\\r\\n// prettier-ignore\\r\\nimport {\\r\\n    OfferItem,\\r\\n    ConsiderationItem,\\r\\n    ReceivedItem,\\r\\n    OrderParameters,\\r\\n    AdvancedOrder,\\r\\n    Execution,\\r\\n    FulfillmentComponent\\r\\n} from \\\"./ConsiderationStructs.sol\\\";\\r\\n\\r\\nimport \\\"./ConsiderationConstants.sol\\\";\\r\\n\\r\\n// prettier-ignore\\r\\nimport {\\r\\n    FulfillmentApplicationErrors\\r\\n} from \\\"../interfaces/FulfillmentApplicationErrors.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title FulfillmentApplier\\r\\n * @author 0age\\r\\n * @notice FulfillmentApplier contains logic related to applying fulfillments,\\r\\n *         both as part of order matching (where offer items are matched to\\r\\n *         consideration items) as well as fulfilling available orders (where\\r\\n *         order items and consideration items are independently aggregated).\\r\\n */\\r\\ncontract FulfillmentApplier is FulfillmentApplicationErrors {\\r\\n    /**\\r\\n     * @dev Internal pure function to match offer items to consideration items\\r\\n     *      on a group of orders via a supplied fulfillment.\\r\\n     *\\r\\n     * @param advancedOrders          The orders to match.\\r\\n     * @param offerComponents         An array designating offer components to\\r\\n     *                                match to consideration components.\\r\\n     * @param considerationComponents An array designating consideration\\r\\n     *                                components to match to offer components.\\r\\n     *                                Note that each consideration amount must\\r\\n     *                                be zero in order for the match operation\\r\\n     *                                to be valid.\\r\\n     *\\r\\n     * @return execution The transfer performed as a result of the fulfillment.\\r\\n     */\\r\\n    function _applyFulfillment(\\r\\n        AdvancedOrder[] memory advancedOrders,\\r\\n        FulfillmentComponent[] calldata offerComponents,\\r\\n        FulfillmentComponent[] calldata considerationComponents\\r\\n    ) internal pure returns (Execution memory execution) {\\r\\n        // Ensure 1+ of both offer and consideration components are supplied.\\r\\n        if (\\r\\n            offerComponents.length == 0 || considerationComponents.length == 0\\r\\n        ) {\\r\\n            revert OfferAndConsiderationRequiredOnFulfillment();\\r\\n        }\\r\\n\\r\\n        // Declare a new Execution struct.\\r\\n        Execution memory considerationExecution;\\r\\n\\r\\n        // Validate & aggregate consideration items to new Execution object.\\r\\n        _aggregateValidFulfillmentConsiderationItems(\\r\\n            advancedOrders,\\r\\n            considerationComponents,\\r\\n            considerationExecution\\r\\n        );\\r\\n\\r\\n        // Retrieve the consideration item from the execution struct.\\r\\n        ReceivedItem memory considerationItem = considerationExecution.item;\\r\\n\\r\\n        // Recipient does not need to be specified because it will always be set\\r\\n        // to that of the consideration.\\r\\n        // Validate & aggregate offer items to Execution object.\\r\\n        _aggregateValidFulfillmentOfferItems(\\r\\n            advancedOrders,\\r\\n            offerComponents,\\r\\n            execution\\r\\n        );\\r\\n\\r\\n        // Ensure offer and consideration share types, tokens and identifiers.\\r\\n        if (\\r\\n            execution.item.itemType != considerationItem.itemType ||\\r\\n            execution.item.token != considerationItem.token ||\\r\\n            execution.item.identifier != considerationItem.identifier\\r\\n        ) {\\r\\n            revert MismatchedFulfillmentOfferAndConsiderationComponents();\\r\\n        }\\r\\n\\r\\n        // If total consideration amount exceeds the offer amount...\\r\\n        if (considerationItem.amount > execution.item.amount) {\\r\\n            // Retrieve the first consideration component from the fulfillment.\\r\\n            FulfillmentComponent memory targetComponent = (\\r\\n                considerationComponents[0]\\r\\n            );\\r\\n\\r\\n            // Skip underflow check as the conditional being true implies that\\r\\n            // considerationItem.amount > execution.item.amount.\\r\\n            unchecked {\\r\\n                // Add excess consideration item amount to original order array.\\r\\n                advancedOrders[targetComponent.orderIndex]\\r\\n                    .parameters\\r\\n                    .consideration[targetComponent.itemIndex]\\r\\n                    .startAmount = (considerationItem.amount -\\r\\n                    execution.item.amount);\\r\\n            }\\r\\n\\r\\n            // Reduce total consideration amount to equal the offer amount.\\r\\n            considerationItem.amount = execution.item.amount;\\r\\n        } else {\\r\\n            // Retrieve the first offer component from the fulfillment.\\r\\n            FulfillmentComponent memory targetComponent = offerComponents[0];\\r\\n\\r\\n            // Skip underflow check as the conditional being false implies that\\r\\n            // execution.item.amount >= considerationItem.amount.\\r\\n            unchecked {\\r\\n                // Add excess offer item amount to the original array of orders.\\r\\n                advancedOrders[targetComponent.orderIndex]\\r\\n                    .parameters\\r\\n                    .offer[targetComponent.itemIndex]\\r\\n                    .startAmount = (execution.item.amount -\\r\\n                    considerationItem.amount);\\r\\n            }\\r\\n\\r\\n            // Reduce total offer amount to equal the consideration amount.\\r\\n            execution.item.amount = considerationItem.amount;\\r\\n        }\\r\\n\\r\\n        // Reuse consideration recipient.\\r\\n        execution.item.recipient = considerationItem.recipient;\\r\\n\\r\\n        // Return the final execution that will be triggered for relevant items.\\r\\n        return execution; // Execution(considerationItem, offerer, conduitKey);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal view function to aggregate offer or consideration items\\r\\n     *      from a group of orders into a single execution via a supplied array\\r\\n     *      of fulfillment components. Items that are not available to aggregate\\r\\n     *      will not be included in the aggregated execution.\\r\\n     *\\r\\n     * @param advancedOrders        The orders to aggregate.\\r\\n     * @param side                  The side (i.e. offer or consideration).\\r\\n     * @param fulfillmentComponents An array designating item components to\\r\\n     *                              aggregate if part of an available order.\\r\\n     * @param fulfillerConduitKey   A bytes32 value indicating what conduit, if\\r\\n     *                              any, to source the fulfiller's token\\r\\n     *                              approvals from. The zero hash signifies that\\r\\n     *                              no conduit should be used, with approvals\\r\\n     *                              set directly on this contract.\\r\\n     * @param recipient             The intended recipient for all received\\r\\n     *                              items.\\r\\n     *\\r\\n     * @return execution The transfer performed as a result of the fulfillment.\\r\\n     */\\r\\n    function _aggregateAvailable(\\r\\n        AdvancedOrder[] memory advancedOrders,\\r\\n        Side side,\\r\\n        FulfillmentComponent[] memory fulfillmentComponents,\\r\\n        bytes32 fulfillerConduitKey,\\r\\n        address recipient\\r\\n    ) internal view returns (Execution memory execution) {\\r\\n        // Skip overflow / underflow checks; conditions checked or unreachable.\\r\\n        unchecked {\\r\\n            // Retrieve fulfillment components array length and place on stack.\\r\\n            // Ensure at least one fulfillment component has been supplied.\\r\\n            if (fulfillmentComponents.length == 0) {\\r\\n                revert MissingFulfillmentComponentOnAggregation(side);\\r\\n            }\\r\\n\\r\\n            // If the fulfillment components are offer components...\\r\\n            if (side == Side.OFFER) {\\r\\n                // Set the supplied recipient on the execution item.\\r\\n                execution.item.recipient = payable(recipient);\\r\\n\\r\\n                // Return execution for aggregated items provided by offerer.\\r\\n                _aggregateValidFulfillmentOfferItems(\\r\\n                    advancedOrders,\\r\\n                    fulfillmentComponents,\\r\\n                    execution\\r\\n                );\\r\\n            } else {\\r\\n                // Otherwise, fulfillment components are consideration\\r\\n                // components. Return execution for aggregated items provided by\\r\\n                // the fulfiller.\\r\\n                _aggregateValidFulfillmentConsiderationItems(\\r\\n                    advancedOrders,\\r\\n                    fulfillmentComponents,\\r\\n                    execution\\r\\n                );\\r\\n\\r\\n                // Set the caller as the offerer on the execution.\\r\\n                execution.offerer = msg.sender;\\r\\n\\r\\n                // Set fulfiller conduit key as the conduit key on execution.\\r\\n                execution.conduitKey = fulfillerConduitKey;\\r\\n            }\\r\\n\\r\\n            // Set the offerer and recipient to null address if execution\\r\\n            // amount is zero. This will cause the execution item to be skipped.\\r\\n            if (execution.item.amount == 0) {\\r\\n                execution.offerer = address(0);\\r\\n                execution.item.recipient = payable(0);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal pure function to aggregate a group of offer items using\\r\\n     *      supplied directives on which component items are candidates for\\r\\n     *      aggregation, skipping items on orders that are not available.\\r\\n     *\\r\\n     * @param advancedOrders  The orders to aggregate offer items from.\\r\\n     * @param offerComponents An array of FulfillmentComponent structs\\r\\n     *                        indicating the order index and item index of each\\r\\n     *                        candidate offer item for aggregation.\\r\\n     * @param execution       The execution to apply the aggregation to.\\r\\n     */\\r\\n    function _aggregateValidFulfillmentOfferItems(\\r\\n        AdvancedOrder[] memory advancedOrders,\\r\\n        FulfillmentComponent[] memory offerComponents,\\r\\n        Execution memory execution\\r\\n    ) internal pure {\\r\\n        assembly {\\r\\n            // Declare function for reverts on invalid fulfillment data.\\r\\n            function throwInvalidFulfillmentComponentData() {\\r\\n                // Store the InvalidFulfillmentComponentData error signature.\\r\\n                mstore(0, InvalidFulfillmentComponentData_error_signature)\\r\\n\\r\\n                // Return, supplying InvalidFulfillmentComponentData signature.\\r\\n                revert(0, InvalidFulfillmentComponentData_error_len)\\r\\n            }\\r\\n\\r\\n            // Declare function for reverts due to arithmetic overflows.\\r\\n            function throwOverflow() {\\r\\n                // Store the Panic error signature.\\r\\n                mstore(0, Panic_error_signature)\\r\\n\\r\\n                // Store the arithmetic (0x11) panic code as initial argument.\\r\\n                mstore(Panic_error_offset, Panic_arithmetic)\\r\\n\\r\\n                // Return, supplying Panic signature and arithmetic code.\\r\\n                revert(0, Panic_error_length)\\r\\n            }\\r\\n\\r\\n            // Get position in offerComponents head.\\r\\n            let fulfillmentHeadPtr := add(offerComponents, OneWord)\\r\\n\\r\\n            // Retrieve the order index using the fulfillment pointer.\\r\\n            let orderIndex := mload(mload(fulfillmentHeadPtr))\\r\\n\\r\\n            // Ensure that the order index is not out of range.\\r\\n            if iszero(lt(orderIndex, mload(advancedOrders))) {\\r\\n                throwInvalidFulfillmentComponentData()\\r\\n            }\\r\\n\\r\\n            // Read advancedOrders[orderIndex] pointer from its array head.\\r\\n            let orderPtr := mload(\\r\\n                // Calculate head position of advancedOrders[orderIndex].\\r\\n                add(add(advancedOrders, OneWord), mul(orderIndex, OneWord))\\r\\n            )\\r\\n\\r\\n            // Read the pointer to OrderParameters from the AdvancedOrder.\\r\\n            let paramsPtr := mload(orderPtr)\\r\\n\\r\\n            // Load the offer array pointer.\\r\\n            let offerArrPtr := mload(\\r\\n                add(paramsPtr, OrderParameters_offer_head_offset)\\r\\n            )\\r\\n\\r\\n            // Retrieve item index using an offset of the fulfillment pointer.\\r\\n            let itemIndex := mload(\\r\\n                add(mload(fulfillmentHeadPtr), Fulfillment_itemIndex_offset)\\r\\n            )\\r\\n\\r\\n            // Only continue if the fulfillment is not invalid.\\r\\n            if iszero(lt(itemIndex, mload(offerArrPtr))) {\\r\\n                throwInvalidFulfillmentComponentData()\\r\\n            }\\r\\n\\r\\n            // Retrieve consideration item pointer using the item index.\\r\\n            let offerItemPtr := mload(\\r\\n                add(\\r\\n                    // Get pointer to beginning of receivedItem.\\r\\n                    add(offerArrPtr, OneWord),\\r\\n                    // Calculate offset to pointer for desired order.\\r\\n                    mul(itemIndex, OneWord)\\r\\n                )\\r\\n            )\\r\\n\\r\\n            // Declare a variable for the final aggregated item amount.\\r\\n            let amount := 0\\r\\n\\r\\n            // Create variable to track errors encountered with amount.\\r\\n            let errorBuffer := 0\\r\\n\\r\\n            // Only add offer amount to execution amount on a nonzero numerator.\\r\\n            if mload(add(orderPtr, AdvancedOrder_numerator_offset)) {\\r\\n                // Retrieve amount pointer using consideration item pointer.\\r\\n                let amountPtr := add(offerItemPtr, Common_amount_offset)\\r\\n\\r\\n                // Set the amount.\\r\\n                amount := mload(amountPtr)\\r\\n\\r\\n                // Zero out amount on item to indicate it is credited.\\r\\n                mstore(amountPtr, 0)\\r\\n\\r\\n                // Buffer indicating whether issues were found.\\r\\n                errorBuffer := iszero(amount)\\r\\n            }\\r\\n\\r\\n            // Retrieve the received item pointer.\\r\\n            let receivedItemPtr := mload(execution)\\r\\n\\r\\n            // Set the item type on the received item.\\r\\n            mstore(receivedItemPtr, mload(offerItemPtr))\\r\\n\\r\\n            // Set the token on the received item.\\r\\n            mstore(\\r\\n                add(receivedItemPtr, Common_token_offset),\\r\\n                mload(add(offerItemPtr, Common_token_offset))\\r\\n            )\\r\\n\\r\\n            // Set the identifier on the received item.\\r\\n            mstore(\\r\\n                add(receivedItemPtr, Common_identifier_offset),\\r\\n                mload(add(offerItemPtr, Common_identifier_offset))\\r\\n            )\\r\\n\\r\\n            // Set the offerer on returned execution using order pointer.\\r\\n            mstore(add(execution, Execution_offerer_offset), mload(paramsPtr))\\r\\n\\r\\n            // Set conduitKey on returned execution via offset of order pointer.\\r\\n            mstore(\\r\\n                add(execution, Execution_conduit_offset),\\r\\n                mload(add(paramsPtr, OrderParameters_conduit_offset))\\r\\n            )\\r\\n\\r\\n            // Calculate the hash of (itemType, token, identifier).\\r\\n            let dataHash := keccak256(\\r\\n                receivedItemPtr,\\r\\n                ReceivedItem_CommonParams_size\\r\\n            )\\r\\n\\r\\n            // Get position one word past last element in head of array.\\r\\n            let endPtr := add(\\r\\n                offerComponents,\\r\\n                mul(mload(offerComponents), OneWord)\\r\\n            )\\r\\n\\r\\n            // Iterate over remaining offer components.\\r\\n            // prettier-ignore\\r\\n            for {} lt(fulfillmentHeadPtr,  endPtr) {} {\\r\\n                // Increment the pointer to the fulfillment head by one word.\\r\\n                fulfillmentHeadPtr := add(fulfillmentHeadPtr, OneWord)\\r\\n\\r\\n                // Get the order index using the fulfillment pointer.\\r\\n                orderIndex := mload(mload(fulfillmentHeadPtr))\\r\\n\\r\\n                // Ensure the order index is in range.\\r\\n                if iszero(lt(orderIndex, mload(advancedOrders))) {\\r\\n                  throwInvalidFulfillmentComponentData()\\r\\n                }\\r\\n\\r\\n                // Get pointer to AdvancedOrder element.\\r\\n                orderPtr := mload(\\r\\n                    add(\\r\\n                        add(advancedOrders, OneWord),\\r\\n                        mul(orderIndex, OneWord)\\r\\n                    )\\r\\n                )\\r\\n\\r\\n                // Only continue if numerator is not zero.\\r\\n                if iszero(mload(\\r\\n                    add(orderPtr, AdvancedOrder_numerator_offset)\\r\\n                )) {\\r\\n                  continue\\r\\n                }\\r\\n\\r\\n                // Read the pointer to OrderParameters from the AdvancedOrder.\\r\\n                paramsPtr := mload(orderPtr)\\r\\n\\r\\n                // Load offer array pointer.\\r\\n                offerArrPtr := mload(\\r\\n                    add(\\r\\n                        paramsPtr,\\r\\n                        OrderParameters_offer_head_offset\\r\\n                    )\\r\\n                )\\r\\n\\r\\n                // Get the item index using the fulfillment pointer.\\r\\n                itemIndex := mload(add(mload(fulfillmentHeadPtr), OneWord))\\r\\n\\r\\n                // Throw if itemIndex is out of the range of array.\\r\\n                if iszero(\\r\\n                    lt(itemIndex, mload(offerArrPtr))\\r\\n                ) {\\r\\n                    throwInvalidFulfillmentComponentData()\\r\\n                }\\r\\n\\r\\n                // Retrieve offer item pointer using index.\\r\\n                offerItemPtr := mload(\\r\\n                    add(\\r\\n                        // Get pointer to beginning of receivedItem.\\r\\n                        add(offerArrPtr, OneWord),\\r\\n                        // Use offset to pointer for desired order.\\r\\n                        mul(itemIndex, OneWord)\\r\\n                    )\\r\\n                )\\r\\n\\r\\n                // Retrieve amount pointer using offer item pointer.\\r\\n                let amountPtr := add(\\r\\n                      offerItemPtr,\\r\\n                      Common_amount_offset\\r\\n                )\\r\\n\\r\\n                // Add offer amount to execution amount.\\r\\n                let newAmount := add(amount, mload(amountPtr))\\r\\n\\r\\n                // Update error buffer: 1 = zero amount, 2 = overflow, 3 = both.\\r\\n                errorBuffer := or(\\r\\n                  errorBuffer,\\r\\n                  or(\\r\\n                    shl(1, lt(newAmount, amount)),\\r\\n                    iszero(mload(amountPtr))\\r\\n                  )\\r\\n                )\\r\\n\\r\\n                // Update the amount to the new, summed amount.\\r\\n                amount := newAmount\\r\\n\\r\\n                // Zero out amount on original item to indicate it is credited.\\r\\n                mstore(amountPtr, 0)\\r\\n\\r\\n                // Ensure the indicated item matches original item.\\r\\n                if iszero(\\r\\n                    and(\\r\\n                        and(\\r\\n                          // The offerer must match on both items.\\r\\n                          eq(\\r\\n                              mload(paramsPtr),\\r\\n                              mload(\\r\\n                                  add(execution, Execution_offerer_offset)\\r\\n                              )\\r\\n                          ),\\r\\n                          // The conduit key must match on both items.\\r\\n                          eq(\\r\\n                              mload(\\r\\n                                  add(\\r\\n                                      paramsPtr,\\r\\n                                      OrderParameters_conduit_offset\\r\\n                                  )\\r\\n                              ),\\r\\n                              mload(\\r\\n                                  add(\\r\\n                                      execution,\\r\\n                                      Execution_conduit_offset\\r\\n                                  )\\r\\n                              )\\r\\n                          )\\r\\n                        ),\\r\\n                        // The itemType, token, and identifier must match.\\r\\n                        eq(\\r\\n                            dataHash,\\r\\n                            keccak256(\\r\\n                                offerItemPtr,\\r\\n                                ReceivedItem_CommonParams_size\\r\\n                            )\\r\\n                        )\\r\\n                    )\\r\\n                ) {\\r\\n                    // Throw if any of the requirements are not met.\\r\\n                    throwInvalidFulfillmentComponentData()\\r\\n                }\\r\\n            }\\r\\n            // Write final amount to execution.\\r\\n            mstore(add(mload(execution), Common_amount_offset), amount)\\r\\n\\r\\n            // Determine whether the error buffer contains a nonzero error code.\\r\\n            if errorBuffer {\\r\\n                // If errorBuffer is 1, an item had an amount of zero.\\r\\n                if eq(errorBuffer, 1) {\\r\\n                    // Store the MissingItemAmount error signature.\\r\\n                    mstore(0, MissingItemAmount_error_signature)\\r\\n\\r\\n                    // Return, supplying MissingItemAmount signature.\\r\\n                    revert(0, MissingItemAmount_error_len)\\r\\n                }\\r\\n\\r\\n                // If errorBuffer is not 1 or 0, the sum overflowed.\\r\\n                // Panic!\\r\\n                throwOverflow()\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal pure function to aggregate a group of consideration items\\r\\n     *      using supplied directives on which component items are candidates\\r\\n     *      for aggregation, skipping items on orders that are not available.\\r\\n     *\\r\\n     * @param advancedOrders          The orders to aggregate consideration\\r\\n     *                                items from.\\r\\n     * @param considerationComponents An array of FulfillmentComponent structs\\r\\n     *                                indicating the order index and item index\\r\\n     *                                of each candidate consideration item for\\r\\n     *                                aggregation.\\r\\n     * @param execution       The execution to apply the aggregation to.\\r\\n     */\\r\\n    function _aggregateValidFulfillmentConsiderationItems(\\r\\n        AdvancedOrder[] memory advancedOrders,\\r\\n        FulfillmentComponent[] memory considerationComponents,\\r\\n        Execution memory execution\\r\\n    ) internal pure {\\r\\n        // Utilize assembly in order to efficiently aggregate the items.\\r\\n        assembly {\\r\\n            // Declare function for reverts on invalid fulfillment data.\\r\\n            function throwInvalidFulfillmentComponentData() {\\r\\n                // Store the InvalidFulfillmentComponentData error signature.\\r\\n                mstore(0, InvalidFulfillmentComponentData_error_signature)\\r\\n\\r\\n                // Return, supplying InvalidFulfillmentComponentData signature.\\r\\n                revert(0, InvalidFulfillmentComponentData_error_len)\\r\\n            }\\r\\n\\r\\n            // Declare function for reverts due to arithmetic overflows.\\r\\n            function throwOverflow() {\\r\\n                // Store the Panic error signature.\\r\\n                mstore(0, Panic_error_signature)\\r\\n\\r\\n                // Store the arithmetic (0x11) panic code as initial argument.\\r\\n                mstore(Panic_error_offset, Panic_arithmetic)\\r\\n\\r\\n                // Return, supplying Panic signature and arithmetic code.\\r\\n                revert(0, Panic_error_length)\\r\\n            }\\r\\n\\r\\n            // Get position in considerationComponents head.\\r\\n            let fulfillmentHeadPtr := add(considerationComponents, OneWord)\\r\\n\\r\\n            // Retrieve the order index using the fulfillment pointer.\\r\\n            let orderIndex := mload(mload(fulfillmentHeadPtr))\\r\\n\\r\\n            // Ensure that the order index is not out of range.\\r\\n            if iszero(lt(orderIndex, mload(advancedOrders))) {\\r\\n                throwInvalidFulfillmentComponentData()\\r\\n            }\\r\\n\\r\\n            // Read advancedOrders[orderIndex] pointer from its array head.\\r\\n            let orderPtr := mload(\\r\\n                // Calculate head position of advancedOrders[orderIndex].\\r\\n                add(add(advancedOrders, OneWord), mul(orderIndex, OneWord))\\r\\n            )\\r\\n\\r\\n            // Load consideration array pointer.\\r\\n            let considerationArrPtr := mload(\\r\\n                add(\\r\\n                    // Read pointer to OrderParameters from the AdvancedOrder.\\r\\n                    mload(orderPtr),\\r\\n                    OrderParameters_consideration_head_offset\\r\\n                )\\r\\n            )\\r\\n\\r\\n            // Retrieve item index using an offset of the fulfillment pointer.\\r\\n            let itemIndex := mload(\\r\\n                add(mload(fulfillmentHeadPtr), Fulfillment_itemIndex_offset)\\r\\n            )\\r\\n\\r\\n            // Ensure that the order index is not out of range.\\r\\n            if iszero(lt(itemIndex, mload(considerationArrPtr))) {\\r\\n                throwInvalidFulfillmentComponentData()\\r\\n            }\\r\\n\\r\\n            // Retrieve consideration item pointer using the item index.\\r\\n            let considerationItemPtr := mload(\\r\\n                add(\\r\\n                    // Get pointer to beginning of receivedItem.\\r\\n                    add(considerationArrPtr, OneWord),\\r\\n                    // Calculate offset to pointer for desired order.\\r\\n                    mul(itemIndex, OneWord)\\r\\n                )\\r\\n            )\\r\\n\\r\\n            // Declare a variable for the final aggregated item amount.\\r\\n            let amount := 0\\r\\n\\r\\n            // Create variable to track errors encountered with amount.\\r\\n            let errorBuffer := 0\\r\\n\\r\\n            // Only add consideration amount to execution amount if numerator is\\r\\n            // greater than zero.\\r\\n            if mload(add(orderPtr, AdvancedOrder_numerator_offset)) {\\r\\n                // Retrieve amount pointer using consideration item pointer.\\r\\n                let amountPtr := add(considerationItemPtr, Common_amount_offset)\\r\\n\\r\\n                // Set the amount.\\r\\n                amount := mload(amountPtr)\\r\\n\\r\\n                // Set error bit if amount is zero.\\r\\n                errorBuffer := iszero(amount)\\r\\n\\r\\n                // Zero out amount on item to indicate it is credited.\\r\\n                mstore(amountPtr, 0)\\r\\n            }\\r\\n\\r\\n            // Retrieve ReceivedItem pointer from Execution.\\r\\n            let receivedItem := mload(execution)\\r\\n\\r\\n            // Set the item type on the received item.\\r\\n            mstore(receivedItem, mload(considerationItemPtr))\\r\\n\\r\\n            // Set the token on the received item.\\r\\n            mstore(\\r\\n                add(receivedItem, Common_token_offset),\\r\\n                mload(add(considerationItemPtr, Common_token_offset))\\r\\n            )\\r\\n\\r\\n            // Set the identifier on the received item.\\r\\n            mstore(\\r\\n                add(receivedItem, Common_identifier_offset),\\r\\n                mload(add(considerationItemPtr, Common_identifier_offset))\\r\\n            )\\r\\n\\r\\n            // Set the recipient on the received item.\\r\\n            mstore(\\r\\n                add(receivedItem, ReceivedItem_recipient_offset),\\r\\n                mload(\\r\\n                    add(\\r\\n                        considerationItemPtr,\\r\\n                        ConsiderationItem_recipient_offset\\r\\n                    )\\r\\n                )\\r\\n            )\\r\\n\\r\\n            // Calculate the hash of (itemType, token, identifier).\\r\\n            let dataHash := keccak256(\\r\\n                receivedItem,\\r\\n                ReceivedItem_CommonParams_size\\r\\n            )\\r\\n\\r\\n            // Get position one word past last element in head of array.\\r\\n            let endPtr := add(\\r\\n                considerationComponents,\\r\\n                mul(mload(considerationComponents), OneWord)\\r\\n            )\\r\\n\\r\\n            // Iterate over remaining offer components.\\r\\n            // prettier-ignore\\r\\n            for {} lt(fulfillmentHeadPtr,  endPtr) {} {\\r\\n                // Increment position in considerationComponents head.\\r\\n                fulfillmentHeadPtr := add(fulfillmentHeadPtr, OneWord)\\r\\n\\r\\n                // Get the order index using the fulfillment pointer.\\r\\n                orderIndex := mload(mload(fulfillmentHeadPtr))\\r\\n\\r\\n                // Ensure the order index is in range.\\r\\n                if iszero(lt(orderIndex, mload(advancedOrders))) {\\r\\n                  throwInvalidFulfillmentComponentData()\\r\\n                }\\r\\n\\r\\n                // Get pointer to AdvancedOrder element.\\r\\n                orderPtr := mload(\\r\\n                    add(\\r\\n                        add(advancedOrders, OneWord),\\r\\n                        mul(orderIndex, OneWord)\\r\\n                    )\\r\\n                )\\r\\n\\r\\n                // Only continue if numerator is not zero.\\r\\n                if iszero(\\r\\n                    mload(add(orderPtr, AdvancedOrder_numerator_offset))\\r\\n                ) {\\r\\n                  continue\\r\\n                }\\r\\n\\r\\n                // Load consideration array pointer from OrderParameters.\\r\\n                considerationArrPtr := mload(\\r\\n                    add(\\r\\n                        // Get pointer to OrderParameters from AdvancedOrder.\\r\\n                        mload(orderPtr),\\r\\n                        OrderParameters_consideration_head_offset\\r\\n                    )\\r\\n                )\\r\\n\\r\\n                // Get the item index using the fulfillment pointer.\\r\\n                itemIndex := mload(add(mload(fulfillmentHeadPtr), OneWord))\\r\\n\\r\\n                // Check if itemIndex is within the range of array.\\r\\n                if iszero(lt(itemIndex, mload(considerationArrPtr))) {\\r\\n                    throwInvalidFulfillmentComponentData()\\r\\n                }\\r\\n\\r\\n                // Retrieve consideration item pointer using index.\\r\\n                considerationItemPtr := mload(\\r\\n                    add(\\r\\n                        // Get pointer to beginning of receivedItem.\\r\\n                        add(considerationArrPtr, OneWord),\\r\\n                        // Use offset to pointer for desired order.\\r\\n                        mul(itemIndex, OneWord)\\r\\n                    )\\r\\n                )\\r\\n\\r\\n                // Retrieve amount pointer using consideration item pointer.\\r\\n                let amountPtr := add(\\r\\n                      considerationItemPtr,\\r\\n                      Common_amount_offset\\r\\n                )\\r\\n\\r\\n                // Add offer amount to execution amount.\\r\\n                let newAmount := add(amount, mload(amountPtr))\\r\\n\\r\\n                // Update error buffer: 1 = zero amount, 2 = overflow, 3 = both.\\r\\n                errorBuffer := or(\\r\\n                  errorBuffer,\\r\\n                  or(\\r\\n                    shl(1, lt(newAmount, amount)),\\r\\n                    iszero(mload(amountPtr))\\r\\n                  )\\r\\n                )\\r\\n\\r\\n                // Update the amount to the new, summed amount.\\r\\n                amount := newAmount\\r\\n\\r\\n                // Zero out amount on original item to indicate it is credited.\\r\\n                mstore(amountPtr, 0)\\r\\n\\r\\n                // Ensure the indicated item matches original item.\\r\\n                if iszero(\\r\\n                    and(\\r\\n                        // Item recipients must match.\\r\\n                        eq(\\r\\n                            mload(\\r\\n                                add(\\r\\n                                    considerationItemPtr,\\r\\n                                    ConsiderItem_recipient_offset\\r\\n                                )\\r\\n                            ),\\r\\n                            mload(\\r\\n                                add(\\r\\n                                    receivedItem,\\r\\n                                    ReceivedItem_recipient_offset\\r\\n                                )\\r\\n                            )\\r\\n                        ),\\r\\n                        // The itemType, token, identifier must match.\\r\\n                        eq(\\r\\n                          dataHash,\\r\\n                          keccak256(\\r\\n                            considerationItemPtr,\\r\\n                            ReceivedItem_CommonParams_size\\r\\n                          )\\r\\n                        )\\r\\n                    )\\r\\n                ) {\\r\\n                    // Throw if any of the requirements are not met.\\r\\n                    throwInvalidFulfillmentComponentData()\\r\\n                }\\r\\n            }\\r\\n            // Write final amount to execution.\\r\\n            mstore(add(receivedItem, Common_amount_offset), amount)\\r\\n\\r\\n            // Determine whether the error buffer contains a nonzero error code.\\r\\n            if errorBuffer {\\r\\n                // If errorBuffer is 1, an item had an amount of zero.\\r\\n                if eq(errorBuffer, 1) {\\r\\n                    // Store the MissingItemAmount error signature.\\r\\n                    mstore(0, MissingItemAmount_error_signature)\\r\\n\\r\\n                    // Return, supplying MissingItemAmount signature.\\r\\n                    revert(0, MissingItemAmount_error_len)\\r\\n                }\\r\\n\\r\\n                // If errorBuffer is not 1 or 0, the sum overflowed.\\r\\n                // Panic!\\r\\n                throwOverflow()\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x699b04d6152b094a1407eaceb728edb7caddc6223900dc55319c662e4a3c3404\",\"license\":\"MIT\"},\"contracts/lib/GettersAndDerivers.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.13;\\r\\n\\r\\nimport { OrderParameters } from \\\"./ConsiderationStructs.sol\\\";\\r\\n\\r\\nimport { ConsiderationBase } from \\\"./ConsiderationBase.sol\\\";\\r\\n\\r\\nimport \\\"./ConsiderationConstants.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title GettersAndDerivers\\r\\n * @author 0age\\r\\n * @notice ConsiderationInternal contains pure and internal view functions\\r\\n *         related to getting or deriving various values.\\r\\n */\\r\\ncontract GettersAndDerivers is ConsiderationBase {\\r\\n    /**\\r\\n     * @dev Derive and set hashes, reference chainId, and associated domain\\r\\n     *      separator during deployment.\\r\\n     *\\r\\n     * @param conduitController A contract that deploys conduits, or proxies\\r\\n     *                          that may optionally be used to transfer approved\\r\\n     *                          ERC20/721/1155 tokens.\\r\\n     */\\r\\n    constructor(address conduitController)\\r\\n        ConsiderationBase(conduitController)\\r\\n    {}\\r\\n\\r\\n    /**\\r\\n     * @dev Internal view function to derive the order hash for a given order.\\r\\n     *      Note that only the original consideration items are included in the\\r\\n     *      order hash, as additional consideration items may be supplied by the\\r\\n     *      caller.\\r\\n     *\\r\\n     * @param orderParameters The parameters of the order to hash.\\r\\n     * @param counter           The counter of the order to hash.\\r\\n     *\\r\\n     * @return orderHash The hash.\\r\\n     */\\r\\n    function _deriveOrderHash(\\r\\n        OrderParameters memory orderParameters,\\r\\n        uint256 counter\\r\\n    ) internal view returns (bytes32 orderHash) {\\r\\n        // Get length of original consideration array and place it on the stack.\\r\\n        uint256 originalConsiderationLength = (\\r\\n            orderParameters.totalOriginalConsiderationItems\\r\\n        );\\r\\n\\r\\n        /*\\r\\n         * Memory layout for an array of structs (dynamic or not) is similar\\r\\n         * to ABI encoding of dynamic types, with a head segment followed by\\r\\n         * a data segment. The main difference is that the head of an element\\r\\n         * is a memory pointer rather than an offset.\\r\\n         */\\r\\n\\r\\n        // Declare a variable for the derived hash of the offer array.\\r\\n        bytes32 offerHash;\\r\\n\\r\\n        // Read offer item EIP-712 typehash from runtime code & place on stack.\\r\\n        bytes32 typeHash = _OFFER_ITEM_TYPEHASH;\\r\\n\\r\\n        // Utilize assembly so that memory regions can be reused across hashes.\\r\\n        assembly {\\r\\n            // Retrieve the free memory pointer and place on the stack.\\r\\n            let hashArrPtr := mload(FreeMemoryPointerSlot)\\r\\n\\r\\n            // Get the pointer to the offers array.\\r\\n            let offerArrPtr := mload(\\r\\n                add(orderParameters, OrderParameters_offer_head_offset)\\r\\n            )\\r\\n\\r\\n            // Load the length.\\r\\n            let offerLength := mload(offerArrPtr)\\r\\n\\r\\n            // Set the pointer to the first offer's head.\\r\\n            offerArrPtr := add(offerArrPtr, OneWord)\\r\\n\\r\\n            // Iterate over the offer items.\\r\\n            // prettier-ignore\\r\\n            for { let i := 0 } lt(i, offerLength) {\\r\\n                i := add(i, 1)\\r\\n            } {\\r\\n                // Read the pointer to the offer data and subtract one word\\r\\n                // to get typeHash pointer.\\r\\n                let ptr := sub(mload(offerArrPtr), OneWord)\\r\\n\\r\\n                // Read the current value before the offer data.\\r\\n                let value := mload(ptr)\\r\\n\\r\\n                // Write the type hash to the previous word.\\r\\n                mstore(ptr, typeHash)\\r\\n\\r\\n                // Take the EIP712 hash and store it in the hash array.\\r\\n                mstore(hashArrPtr, keccak256(ptr, EIP712_OfferItem_size))\\r\\n\\r\\n                // Restore the previous word.\\r\\n                mstore(ptr, value)\\r\\n\\r\\n                // Increment the array pointers by one word.\\r\\n                offerArrPtr := add(offerArrPtr, OneWord)\\r\\n                hashArrPtr := add(hashArrPtr, OneWord)\\r\\n            }\\r\\n\\r\\n            // Derive the offer hash using the hashes of each item.\\r\\n            offerHash := keccak256(\\r\\n                mload(FreeMemoryPointerSlot),\\r\\n                mul(offerLength, OneWord)\\r\\n            )\\r\\n        }\\r\\n\\r\\n        // Declare a variable for the derived hash of the consideration array.\\r\\n        bytes32 considerationHash;\\r\\n\\r\\n        // Read consideration item typehash from runtime code & place on stack.\\r\\n        typeHash = _CONSIDERATION_ITEM_TYPEHASH;\\r\\n\\r\\n        // Utilize assembly so that memory regions can be reused across hashes.\\r\\n        assembly {\\r\\n            // Retrieve the free memory pointer and place on the stack.\\r\\n            let hashArrPtr := mload(FreeMemoryPointerSlot)\\r\\n\\r\\n            // Get the pointer to the consideration array.\\r\\n            let considerationArrPtr := add(\\r\\n                mload(\\r\\n                    add(\\r\\n                        orderParameters,\\r\\n                        OrderParameters_consideration_head_offset\\r\\n                    )\\r\\n                ),\\r\\n                OneWord\\r\\n            )\\r\\n\\r\\n            // Iterate over the consideration items (not including tips).\\r\\n            // prettier-ignore\\r\\n            for { let i := 0 } lt(i, originalConsiderationLength) {\\r\\n                i := add(i, 1)\\r\\n            } {\\r\\n                // Read the pointer to the consideration data and subtract one\\r\\n                // word to get typeHash pointer.\\r\\n                let ptr := sub(mload(considerationArrPtr), OneWord)\\r\\n\\r\\n                // Read the current value before the consideration data.\\r\\n                let value := mload(ptr)\\r\\n\\r\\n                // Write the type hash to the previous word.\\r\\n                mstore(ptr, typeHash)\\r\\n\\r\\n                // Take the EIP712 hash and store it in the hash array.\\r\\n                mstore(\\r\\n                    hashArrPtr,\\r\\n                    keccak256(ptr, EIP712_ConsiderationItem_size)\\r\\n                )\\r\\n\\r\\n                // Restore the previous word.\\r\\n                mstore(ptr, value)\\r\\n\\r\\n                // Increment the array pointers by one word.\\r\\n                considerationArrPtr := add(considerationArrPtr, OneWord)\\r\\n                hashArrPtr := add(hashArrPtr, OneWord)\\r\\n            }\\r\\n\\r\\n            // Derive the consideration hash using the hashes of each item.\\r\\n            considerationHash := keccak256(\\r\\n                mload(FreeMemoryPointerSlot),\\r\\n                mul(originalConsiderationLength, OneWord)\\r\\n            )\\r\\n        }\\r\\n\\r\\n        // Read order item EIP-712 typehash from runtime code & place on stack.\\r\\n        typeHash = _ORDER_TYPEHASH;\\r\\n\\r\\n        // Utilize assembly to access derived hashes & other arguments directly.\\r\\n        assembly {\\r\\n            // Retrieve pointer to the region located just behind parameters.\\r\\n            let typeHashPtr := sub(orderParameters, OneWord)\\r\\n\\r\\n            // Store the value at that pointer location to restore later.\\r\\n            let previousValue := mload(typeHashPtr)\\r\\n\\r\\n            // Store the order item EIP-712 typehash at the typehash location.\\r\\n            mstore(typeHashPtr, typeHash)\\r\\n\\r\\n            // Retrieve the pointer for the offer array head.\\r\\n            let offerHeadPtr := add(\\r\\n                orderParameters,\\r\\n                OrderParameters_offer_head_offset\\r\\n            )\\r\\n\\r\\n            // Retrieve the data pointer referenced by the offer head.\\r\\n            let offerDataPtr := mload(offerHeadPtr)\\r\\n\\r\\n            // Store the offer hash at the retrieved memory location.\\r\\n            mstore(offerHeadPtr, offerHash)\\r\\n\\r\\n            // Retrieve the pointer for the consideration array head.\\r\\n            let considerationHeadPtr := add(\\r\\n                orderParameters,\\r\\n                OrderParameters_consideration_head_offset\\r\\n            )\\r\\n\\r\\n            // Retrieve the data pointer referenced by the consideration head.\\r\\n            let considerationDataPtr := mload(considerationHeadPtr)\\r\\n\\r\\n            // Store the consideration hash at the retrieved memory location.\\r\\n            mstore(considerationHeadPtr, considerationHash)\\r\\n\\r\\n            // Retrieve the pointer for the counter.\\r\\n            let counterPtr := add(\\r\\n                orderParameters,\\r\\n                OrderParameters_counter_offset\\r\\n            )\\r\\n\\r\\n            // Store the counter at the retrieved memory location.\\r\\n            mstore(counterPtr, counter)\\r\\n\\r\\n            // Derive the order hash using the full range of order parameters.\\r\\n            orderHash := keccak256(typeHashPtr, EIP712_Order_size)\\r\\n\\r\\n            // Restore the value previously held at typehash pointer location.\\r\\n            mstore(typeHashPtr, previousValue)\\r\\n\\r\\n            // Restore offer data pointer at the offer head pointer location.\\r\\n            mstore(offerHeadPtr, offerDataPtr)\\r\\n\\r\\n            // Restore consideration data pointer at the consideration head ptr.\\r\\n            mstore(considerationHeadPtr, considerationDataPtr)\\r\\n\\r\\n            // Restore consideration item length at the counter pointer.\\r\\n            mstore(counterPtr, originalConsiderationLength)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal view function to derive the address of a given conduit\\r\\n     *      using a corresponding conduit key.\\r\\n     *\\r\\n     * @param conduitKey A bytes32 value indicating what corresponding conduit,\\r\\n     *                   if any, to source token approvals from. This value is\\r\\n     *                   the \\\"salt\\\" parameter supplied by the deployer (i.e. the\\r\\n     *                   conduit controller) when deploying the given conduit.\\r\\n     *\\r\\n     * @return conduit The address of the conduit associated with the given\\r\\n     *                 conduit key.\\r\\n     */\\r\\n    function _deriveConduit(bytes32 conduitKey)\\r\\n        internal\\r\\n        view\\r\\n        returns (address conduit)\\r\\n    {\\r\\n        // Read conduit controller address from runtime and place on the stack.\\r\\n        address conduitController = address(_CONDUIT_CONTROLLER);\\r\\n\\r\\n        // Read conduit creation code hash from runtime and place on the stack.\\r\\n        bytes32 conduitCreationCodeHash = _CONDUIT_CREATION_CODE_HASH;\\r\\n\\r\\n        // Leverage scratch space to perform an efficient hash.\\r\\n        assembly {\\r\\n            // Retrieve the free memory pointer; it will be replaced afterwards.\\r\\n            let freeMemoryPointer := mload(FreeMemoryPointerSlot)\\r\\n\\r\\n            // Place the control character and the conduit controller in scratch\\r\\n            // space; note that eleven bytes at the beginning are left unused.\\r\\n            mstore(0, or(MaskOverByteTwelve, conduitController))\\r\\n\\r\\n            // Place the conduit key in the next region of scratch space.\\r\\n            mstore(OneWord, conduitKey)\\r\\n\\r\\n            // Place conduit creation code hash in free memory pointer location.\\r\\n            mstore(TwoWords, conduitCreationCodeHash)\\r\\n\\r\\n            // Derive conduit by hashing and applying a mask over last 20 bytes.\\r\\n            conduit := and(\\r\\n                // Hash the relevant region.\\r\\n                keccak256(\\r\\n                    // The region starts at memory pointer 11.\\r\\n                    Create2AddressDerivation_ptr,\\r\\n                    // The region is 85 bytes long (1 + 20 + 32 + 32).\\r\\n                    Create2AddressDerivation_length\\r\\n                ),\\r\\n                // The address equals the last twenty bytes of the hash.\\r\\n                MaskOverLastTwentyBytes\\r\\n            )\\r\\n\\r\\n            // Restore the free memory pointer.\\r\\n            mstore(FreeMemoryPointerSlot, freeMemoryPointer)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal view function to get the EIP-712 domain separator. If the\\r\\n     *      chainId matches the chainId set on deployment, the cached domain\\r\\n     *      separator will be returned; otherwise, it will be derived from\\r\\n     *      scratch.\\r\\n     *\\r\\n     * @return The domain separator.\\r\\n     */\\r\\n    function _domainSeparator() internal view returns (bytes32) {\\r\\n        // prettier-ignore\\r\\n        return block.chainid == _CHAIN_ID\\r\\n            ? _DOMAIN_SEPARATOR\\r\\n            : _deriveDomainSeparator();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal view function to retrieve configuration information for\\r\\n     *      this contract.\\r\\n     *\\r\\n     * @return version           The contract version.\\r\\n     * @return domainSeparator   The domain separator for this contract.\\r\\n     * @return conduitController The conduit Controller set for this contract.\\r\\n     */\\r\\n    function _information()\\r\\n        internal\\r\\n        view\\r\\n        returns (\\r\\n            string memory version,\\r\\n            bytes32 domainSeparator,\\r\\n            address conduitController\\r\\n        )\\r\\n    {\\r\\n        // Derive the domain separator.\\r\\n        domainSeparator = _domainSeparator();\\r\\n\\r\\n        // Declare variable as immutables cannot be accessed within assembly.\\r\\n        conduitController = address(_CONDUIT_CONTROLLER);\\r\\n\\r\\n        // Allocate a string with the intended length.\\r\\n        version = new string(Version_length);\\r\\n\\r\\n        // Set the version as data on the newly allocated string.\\r\\n        assembly {\\r\\n            mstore(add(version, OneWord), shl(Version_shift, Version))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal pure function to efficiently derive an digest to sign for\\r\\n     *      an order in accordance with EIP-712.\\r\\n     *\\r\\n     * @param domainSeparator The domain separator.\\r\\n     * @param orderHash       The order hash.\\r\\n     *\\r\\n     * @return value The hash.\\r\\n     */\\r\\n    function _deriveEIP712Digest(bytes32 domainSeparator, bytes32 orderHash)\\r\\n        internal\\r\\n        pure\\r\\n        returns (bytes32 value)\\r\\n    {\\r\\n        // Leverage scratch space to perform an efficient hash.\\r\\n        assembly {\\r\\n            // Place the EIP-712 prefix at the start of scratch space.\\r\\n            mstore(0, EIP_712_PREFIX)\\r\\n\\r\\n            // Place the domain separator in the next region of scratch space.\\r\\n            mstore(EIP712_DomainSeparator_offset, domainSeparator)\\r\\n\\r\\n            // Place the order hash in scratch space, spilling into the first\\r\\n            // two bytes of the free memory pointer \\u2014 this should never be set\\r\\n            // as memory cannot be expanded to that size, and will be zeroed out\\r\\n            // after the hash is performed.\\r\\n            mstore(EIP712_OrderHash_offset, orderHash)\\r\\n\\r\\n            // Hash the relevant region (65 bytes).\\r\\n            value := keccak256(0, EIP712_DigestPayload_size)\\r\\n\\r\\n            // Clear out the dirtied bits in the memory pointer.\\r\\n            mstore(EIP712_OrderHash_offset, 0)\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xbd375e2af4590900bfcc5432ba88fe55c24b6016862a3734851663ef1632c6be\",\"license\":\"MIT\"},\"contracts/lib/LowLevelHelpers.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.13;\\r\\n\\r\\nimport \\\"./ConsiderationConstants.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title LowLevelHelpers\\r\\n * @author 0age\\r\\n * @notice LowLevelHelpers contains logic for performing various low-level\\r\\n *         operations.\\r\\n */\\r\\ncontract LowLevelHelpers {\\r\\n    /**\\r\\n     * @dev Internal view function to staticcall an arbitrary target with given\\r\\n     *      calldata. Note that no data is written to memory and no contract\\r\\n     *      size check is performed.\\r\\n     *\\r\\n     * @param target   The account to staticcall.\\r\\n     * @param callData The calldata to supply when staticcalling the target.\\r\\n     *\\r\\n     * @return success The status of the staticcall to the target.\\r\\n     */\\r\\n    function _staticcall(address target, bytes memory callData)\\r\\n        internal\\r\\n        view\\r\\n        returns (bool success)\\r\\n    {\\r\\n        assembly {\\r\\n            // Perform the staticcall.\\r\\n            success := staticcall(\\r\\n                gas(),\\r\\n                target,\\r\\n                add(callData, OneWord),\\r\\n                mload(callData),\\r\\n                0,\\r\\n                0\\r\\n            )\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal view function to revert and pass along the revert reason if\\r\\n     *      data was returned by the last call and that the size of that data\\r\\n     *      does not exceed the currently allocated memory size.\\r\\n     */\\r\\n    function _revertWithReasonIfOneIsReturned() internal view {\\r\\n        assembly {\\r\\n            // If it returned a message, bubble it up as long as sufficient gas\\r\\n            // remains to do so:\\r\\n            if returndatasize() {\\r\\n                // Ensure that sufficient gas is available to copy returndata\\r\\n                // while expanding memory where necessary. Start by computing\\r\\n                // the word size of returndata and allocated memory.\\r\\n                let returnDataWords := div(\\r\\n                    add(returndatasize(), AlmostOneWord),\\r\\n                    OneWord\\r\\n                )\\r\\n\\r\\n                // Note: use the free memory pointer in place of msize() to work\\r\\n                // around a Yul warning that prevents accessing msize directly\\r\\n                // when the IR pipeline is activated.\\r\\n                let msizeWords := div(mload(FreeMemoryPointerSlot), OneWord)\\r\\n\\r\\n                // Next, compute the cost of the returndatacopy.\\r\\n                let cost := mul(CostPerWord, returnDataWords)\\r\\n\\r\\n                // Then, compute cost of new memory allocation.\\r\\n                if gt(returnDataWords, msizeWords) {\\r\\n                    cost := add(\\r\\n                        cost,\\r\\n                        add(\\r\\n                            mul(sub(returnDataWords, msizeWords), CostPerWord),\\r\\n                            div(\\r\\n                                sub(\\r\\n                                    mul(returnDataWords, returnDataWords),\\r\\n                                    mul(msizeWords, msizeWords)\\r\\n                                ),\\r\\n                                MemoryExpansionCoefficient\\r\\n                            )\\r\\n                        )\\r\\n                    )\\r\\n                }\\r\\n\\r\\n                // Finally, add a small constant and compare to gas remaining;\\r\\n                // bubble up the revert data if enough gas is still available.\\r\\n                if lt(add(cost, ExtraGasBuffer), gas()) {\\r\\n                    // Copy returndata to memory; overwrite existing memory.\\r\\n                    returndatacopy(0, 0, returndatasize())\\r\\n\\r\\n                    // Revert, specifying memory region with copied returndata.\\r\\n                    revert(0, returndatasize())\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal pure function to determine if the first word of returndata\\r\\n     *      matches an expected magic value.\\r\\n     *\\r\\n     * @param expected The expected magic value.\\r\\n     *\\r\\n     * @return A boolean indicating whether the expected value matches the one\\r\\n     *         located in the first word of returndata.\\r\\n     */\\r\\n    function _doesNotMatchMagic(bytes4 expected) internal pure returns (bool) {\\r\\n        // Declare a variable for the value held by the return data buffer.\\r\\n        bytes4 result;\\r\\n\\r\\n        // Utilize assembly in order to read directly from returndata buffer.\\r\\n        assembly {\\r\\n            // Only put result on stack if return data is exactly one word.\\r\\n            if eq(returndatasize(), OneWord) {\\r\\n                // Copy the word directly from return data into scratch space.\\r\\n                returndatacopy(0, 0, OneWord)\\r\\n\\r\\n                // Take value from scratch space and place it on the stack.\\r\\n                result := mload(0)\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Return a boolean indicating whether expected and located value match.\\r\\n        return result != expected;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xd72d22999e2a3565237405853beccb55e939cfd95323c8fe613b2f0877a59e73\",\"license\":\"MIT\"},\"contracts/lib/OrderCombiner.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.13;\\r\\n\\r\\nimport { Side, ItemType } from \\\"./ConsiderationEnums.sol\\\";\\r\\n\\r\\n// prettier-ignore\\r\\nimport {\\r\\n    OfferItem,\\r\\n    ConsiderationItem,\\r\\n    ReceivedItem,\\r\\n    OrderParameters,\\r\\n    Fulfillment,\\r\\n    FulfillmentComponent,\\r\\n    Execution,\\r\\n    Order,\\r\\n    AdvancedOrder,\\r\\n    CriteriaResolver\\r\\n} from \\\"./ConsiderationStructs.sol\\\";\\r\\n\\r\\nimport { OrderFulfiller } from \\\"./OrderFulfiller.sol\\\";\\r\\n\\r\\nimport { FulfillmentApplier } from \\\"./FulfillmentApplier.sol\\\";\\r\\n\\r\\nimport \\\"./ConsiderationConstants.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title OrderCombiner\\r\\n * @author 0age\\r\\n * @notice OrderCombiner contains logic for fulfilling combinations of orders,\\r\\n *         either by matching offer items to consideration items or by\\r\\n *         fulfilling orders where available.\\r\\n */\\r\\ncontract OrderCombiner is OrderFulfiller, FulfillmentApplier {\\r\\n    /**\\r\\n     * @dev Derive and set hashes, reference chainId, and associated domain\\r\\n     *      separator during deployment.\\r\\n     *\\r\\n     * @param conduitController A contract that deploys conduits, or proxies\\r\\n     *                          that may optionally be used to transfer approved\\r\\n     *                          ERC20/721/1155 tokens.\\r\\n     */\\r\\n    constructor(address conduitController) OrderFulfiller(conduitController) {}\\r\\n\\r\\n    /**\\r\\n     * @notice Internal function to attempt to fill a group of orders, fully or\\r\\n     *         partially, with an arbitrary number of items for offer and\\r\\n     *         consideration per order alongside criteria resolvers containing\\r\\n     *         specific token identifiers and associated proofs. Any order that\\r\\n     *         is not currently active, has already been fully filled, or has\\r\\n     *         been cancelled will be omitted. Remaining offer and consideration\\r\\n     *         items will then be aggregated where possible as indicated by the\\r\\n     *         supplied offer and consideration component arrays and aggregated\\r\\n     *         items will be transferred to the fulfiller or to each intended\\r\\n     *         recipient, respectively. Note that a failing item transfer or an\\r\\n     *         issue with order formatting will cause the entire batch to fail.\\r\\n     *\\r\\n     * @param advancedOrders            The orders to fulfill along with the\\r\\n     *                                  fraction of those orders to attempt to\\r\\n     *                                  fill. Note that both the offerer and the\\r\\n     *                                  fulfiller must first approve this\\r\\n     *                                  contract (or a conduit if indicated by\\r\\n     *                                  the order) to transfer any relevant\\r\\n     *                                  tokens on their behalf and that\\r\\n     *                                  contracts must implement\\r\\n     *                                  `onERC1155Received` in order to receive\\r\\n     *                                  ERC1155 tokens as consideration. Also\\r\\n     *                                  note that all offer and consideration\\r\\n     *                                  components must have no remainder after\\r\\n     *                                  multiplication of the respective amount\\r\\n     *                                  with the supplied fraction for an\\r\\n     *                                  order's partial fill amount to be\\r\\n     *                                  considered valid.\\r\\n     * @param criteriaResolvers         An array where each element contains a\\r\\n     *                                  reference to a specific offer or\\r\\n     *                                  consideration, a token identifier, and a\\r\\n     *                                  proof that the supplied token identifier\\r\\n     *                                  is contained in the merkle root held by\\r\\n     *                                  the item in question's criteria element.\\r\\n     *                                  Note that an empty criteria indicates\\r\\n     *                                  that any (transferable) token\\r\\n     *                                  identifier on the token in question is\\r\\n     *                                  valid and that no associated proof needs\\r\\n     *                                  to be supplied.\\r\\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\\r\\n     *                                  indicating which offer items to attempt\\r\\n     *                                  to aggregate when preparing executions.\\r\\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\\r\\n     *                                  indicating which consideration items to\\r\\n     *                                  attempt to aggregate when preparing\\r\\n     *                                  executions.\\r\\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\\r\\n     *                                  if any, to source the fulfiller's token\\r\\n     *                                  approvals from. The zero hash signifies\\r\\n     *                                  that no conduit should be used (and\\r\\n     *                                  direct approvals set on Consideration).\\r\\n     * @param recipient                 The intended recipient for all received\\r\\n     *                                  items.\\r\\n     * @param maximumFulfilled          The maximum number of orders to fulfill.\\r\\n     *\\r\\n     * @return availableOrders An array of booleans indicating if each order\\r\\n     *                         with an index corresponding to the index of the\\r\\n     *                         returned boolean was fulfillable or not.\\r\\n     * @return executions      An array of elements indicating the sequence of\\r\\n     *                         transfers performed as part of matching the given\\r\\n     *                         orders.\\r\\n     */\\r\\n    function _fulfillAvailableAdvancedOrders(\\r\\n        AdvancedOrder[] memory advancedOrders,\\r\\n        CriteriaResolver[] memory criteriaResolvers,\\r\\n        FulfillmentComponent[][] calldata offerFulfillments,\\r\\n        FulfillmentComponent[][] calldata considerationFulfillments,\\r\\n        bytes32 fulfillerConduitKey,\\r\\n        address recipient,\\r\\n        uint256 maximumFulfilled\\r\\n    )\\r\\n        internal\\r\\n        returns (bool[] memory availableOrders, Execution[] memory executions)\\r\\n    {\\r\\n        // Validate orders, apply amounts, & determine if they utilize conduits.\\r\\n        _validateOrdersAndPrepareToFulfill(\\r\\n            advancedOrders,\\r\\n            criteriaResolvers,\\r\\n            false, // Signifies that invalid orders should NOT revert.\\r\\n            maximumFulfilled,\\r\\n            recipient\\r\\n        );\\r\\n\\r\\n        // Aggregate used offer and consideration items and execute transfers.\\r\\n        (availableOrders, executions) = _executeAvailableFulfillments(\\r\\n            advancedOrders,\\r\\n            offerFulfillments,\\r\\n            considerationFulfillments,\\r\\n            fulfillerConduitKey,\\r\\n            recipient\\r\\n        );\\r\\n\\r\\n        // Return order fulfillment details and executions.\\r\\n        return (availableOrders, executions);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to validate a group of orders, update their\\r\\n     *      statuses, reduce amounts by their previously filled fractions, apply\\r\\n     *      criteria resolvers, and emit OrderFulfilled events.\\r\\n     *\\r\\n     * @param advancedOrders    The advanced orders to validate and reduce by\\r\\n     *                          their previously filled amounts.\\r\\n     * @param criteriaResolvers An array where each element contains a reference\\r\\n     *                          to a specific order as well as that order's\\r\\n     *                          offer or consideration, a token identifier, and\\r\\n     *                          a proof that the supplied token identifier is\\r\\n     *                          contained in the order's merkle root. Note that\\r\\n     *                          a root of zero indicates that any transferable\\r\\n     *                          token identifier is valid and that no proof\\r\\n     *                          needs to be supplied.\\r\\n     * @param revertOnInvalid   A boolean indicating whether to revert on any\\r\\n     *                          order being invalid; setting this to false will\\r\\n     *                          instead cause the invalid order to be skipped.\\r\\n     * @param maximumFulfilled  The maximum number of orders to fulfill.\\r\\n     * @param recipient         The intended recipient for all received items.\\r\\n     */\\r\\n    function _validateOrdersAndPrepareToFulfill(\\r\\n        AdvancedOrder[] memory advancedOrders,\\r\\n        CriteriaResolver[] memory criteriaResolvers,\\r\\n        bool revertOnInvalid,\\r\\n        uint256 maximumFulfilled,\\r\\n        address recipient\\r\\n    ) internal {\\r\\n        // Ensure this function cannot be triggered during a reentrant call.\\r\\n        _setReentrancyGuard();\\r\\n\\r\\n        // Read length of orders array and place on the stack.\\r\\n        uint256 totalOrders = advancedOrders.length;\\r\\n\\r\\n        // Track the order hash for each order being fulfilled.\\r\\n        bytes32[] memory orderHashes = new bytes32[](totalOrders);\\r\\n\\r\\n        // Override orderHashes length to zero after memory has been allocated.\\r\\n        assembly {\\r\\n            mstore(orderHashes, 0)\\r\\n        }\\r\\n\\r\\n        // Declare an error buffer indicating status of any native offer items.\\r\\n        // {00} == 0 => In a match function, no native offer items: allow.\\r\\n        // {01} == 1 => In a match function, some native offer items: allow.\\r\\n        // {10} == 2 => Not in a match function, no native offer items: allow.\\r\\n        // {11} == 3 => Not in a match function, some native offer items: THROW.\\r\\n        uint256 invalidNativeOfferItemErrorBuffer;\\r\\n\\r\\n        // Use assembly to set the value for the second bit of the error buffer.\\r\\n        assembly {\\r\\n            // Use the second bit of the error buffer to indicate whether the\\r\\n            // current function is not matchAdvancedOrders or matchOrders.\\r\\n            invalidNativeOfferItemErrorBuffer := shl(\\r\\n                1,\\r\\n                gt(\\r\\n                    // Take the remainder of the selector modulo a magic value.\\r\\n                    mod(\\r\\n                        shr(NumBitsAfterSelector, calldataload(0)),\\r\\n                        NonMatchSelector_MagicModulus\\r\\n                    ),\\r\\n                    // Check if remainder is higher than the greatest remainder\\r\\n                    // of the two match selectors modulo the magic value.\\r\\n                    NonMatchSelector_MagicRemainder\\r\\n                )\\r\\n            )\\r\\n        }\\r\\n\\r\\n        // Skip overflow checks as all for loops are indexed starting at zero.\\r\\n        unchecked {\\r\\n            // Iterate over each order.\\r\\n            for (uint256 i = 0; i < totalOrders; ++i) {\\r\\n                // Retrieve the current order.\\r\\n                AdvancedOrder memory advancedOrder = advancedOrders[i];\\r\\n\\r\\n                // Determine if max number orders have already been fulfilled.\\r\\n                if (maximumFulfilled == 0) {\\r\\n                    // Mark fill fraction as zero as the order will not be used.\\r\\n                    advancedOrder.numerator = 0;\\r\\n\\r\\n                    // Update the length of the orderHashes array.\\r\\n                    assembly {\\r\\n                        mstore(orderHashes, add(i, 1))\\r\\n                    }\\r\\n\\r\\n                    // Continue iterating through the remaining orders.\\r\\n                    continue;\\r\\n                }\\r\\n\\r\\n                // Validate it, update status, and determine fraction to fill.\\r\\n                (\\r\\n                    bytes32 orderHash,\\r\\n                    uint256 numerator,\\r\\n                    uint256 denominator\\r\\n                ) = _validateOrderAndUpdateStatus(\\r\\n                        advancedOrder,\\r\\n                        criteriaResolvers,\\r\\n                        revertOnInvalid,\\r\\n                        orderHashes\\r\\n                    );\\r\\n\\r\\n                // Update the length of the orderHashes array.\\r\\n                assembly {\\r\\n                    mstore(orderHashes, add(i, 1))\\r\\n                }\\r\\n\\r\\n                // Do not track hash or adjust prices if order is not fulfilled.\\r\\n                if (numerator == 0) {\\r\\n                    // Mark fill fraction as zero if the order is not fulfilled.\\r\\n                    advancedOrder.numerator = 0;\\r\\n\\r\\n                    // Continue iterating through the remaining orders.\\r\\n                    continue;\\r\\n                }\\r\\n\\r\\n                // Otherwise, track the order hash in question.\\r\\n                orderHashes[i] = orderHash;\\r\\n\\r\\n                // Decrement the number of fulfilled orders.\\r\\n                // Skip underflow check as the condition before\\r\\n                // implies that maximumFulfilled > 0.\\r\\n                maximumFulfilled--;\\r\\n\\r\\n                // Place the start time for the order on the stack.\\r\\n                uint256 startTime = advancedOrder.parameters.startTime;\\r\\n\\r\\n                // Place the end time for the order on the stack.\\r\\n                uint256 endTime = advancedOrder.parameters.endTime;\\r\\n\\r\\n                // Retrieve array of offer items for the order in question.\\r\\n                OfferItem[] memory offer = advancedOrder.parameters.offer;\\r\\n\\r\\n                // Read length of offer array and place on the stack.\\r\\n                uint256 totalOfferItems = offer.length;\\r\\n\\r\\n                // Iterate over each offer item on the order.\\r\\n                for (uint256 j = 0; j < totalOfferItems; ++j) {\\r\\n                    // Retrieve the offer item.\\r\\n                    OfferItem memory offerItem = offer[j];\\r\\n\\r\\n                    assembly {\\r\\n                        // If the offer item is for the native token, set the\\r\\n                        // first bit of the error buffer to true.\\r\\n                        invalidNativeOfferItemErrorBuffer := or(\\r\\n                            invalidNativeOfferItemErrorBuffer,\\r\\n                            iszero(mload(offerItem))\\r\\n                        )\\r\\n                    }\\r\\n\\r\\n                    // Apply order fill fraction to offer item end amount.\\r\\n                    uint256 endAmount = _getFraction(\\r\\n                        numerator,\\r\\n                        denominator,\\r\\n                        offerItem.endAmount\\r\\n                    );\\r\\n\\r\\n                    // Reuse same fraction if start and end amounts are equal.\\r\\n                    if (offerItem.startAmount == offerItem.endAmount) {\\r\\n                        // Apply derived amount to both start and end amount.\\r\\n                        offerItem.startAmount = endAmount;\\r\\n                    } else {\\r\\n                        // Apply order fill fraction to offer item start amount.\\r\\n                        offerItem.startAmount = _getFraction(\\r\\n                            numerator,\\r\\n                            denominator,\\r\\n                            offerItem.startAmount\\r\\n                        );\\r\\n                    }\\r\\n\\r\\n                    // Update end amount in memory to match the derived amount.\\r\\n                    offerItem.endAmount = endAmount;\\r\\n\\r\\n                    // Adjust offer amount using current time; round down.\\r\\n                    offerItem.startAmount = _locateCurrentAmount(\\r\\n                        offerItem.startAmount,\\r\\n                        offerItem.endAmount,\\r\\n                        startTime,\\r\\n                        endTime,\\r\\n                        false // round down\\r\\n                    );\\r\\n                }\\r\\n\\r\\n                // Retrieve array of consideration items for order in question.\\r\\n                ConsiderationItem[] memory consideration = (\\r\\n                    advancedOrder.parameters.consideration\\r\\n                );\\r\\n\\r\\n                // Read length of consideration array and place on the stack.\\r\\n                uint256 totalConsiderationItems = consideration.length;\\r\\n\\r\\n                // Iterate over each consideration item on the order.\\r\\n                for (uint256 j = 0; j < totalConsiderationItems; ++j) {\\r\\n                    // Retrieve the consideration item.\\r\\n                    ConsiderationItem memory considerationItem = (\\r\\n                        consideration[j]\\r\\n                    );\\r\\n\\r\\n                    // Apply fraction to consideration item end amount.\\r\\n                    uint256 endAmount = _getFraction(\\r\\n                        numerator,\\r\\n                        denominator,\\r\\n                        considerationItem.endAmount\\r\\n                    );\\r\\n\\r\\n                    // Reuse same fraction if start and end amounts are equal.\\r\\n                    if (\\r\\n                        considerationItem.startAmount ==\\r\\n                        considerationItem.endAmount\\r\\n                    ) {\\r\\n                        // Apply derived amount to both start and end amount.\\r\\n                        considerationItem.startAmount = endAmount;\\r\\n                    } else {\\r\\n                        // Apply fraction to consideration item start amount.\\r\\n                        considerationItem.startAmount = _getFraction(\\r\\n                            numerator,\\r\\n                            denominator,\\r\\n                            considerationItem.startAmount\\r\\n                        );\\r\\n                    }\\r\\n\\r\\n                    // Update end amount in memory to match the derived amount.\\r\\n                    considerationItem.endAmount = endAmount;\\r\\n\\r\\n                    // Adjust consideration amount using current time; round up.\\r\\n                    considerationItem.startAmount = (\\r\\n                        _locateCurrentAmount(\\r\\n                            considerationItem.startAmount,\\r\\n                            considerationItem.endAmount,\\r\\n                            startTime,\\r\\n                            endTime,\\r\\n                            true // round up\\r\\n                        )\\r\\n                    );\\r\\n\\r\\n                    // Utilize assembly to manually \\\"shift\\\" the recipient value.\\r\\n                    assembly {\\r\\n                        // Write recipient to endAmount, as endAmount is not\\r\\n                        // used from this point on and can be repurposed to fit\\r\\n                        // the layout of a ReceivedItem.\\r\\n                        mstore(\\r\\n                            add(\\r\\n                                considerationItem,\\r\\n                                ReceivedItem_recipient_offset // old endAmount\\r\\n                            ),\\r\\n                            mload(\\r\\n                                add(\\r\\n                                    considerationItem,\\r\\n                                    ConsiderationItem_recipient_offset\\r\\n                                )\\r\\n                            )\\r\\n                        )\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // If the first bit is set, a native offer item was encountered. If the\\r\\n        // second bit is set in the error buffer, the current function is not\\r\\n        // matchOrders or matchAdvancedOrders. If the value is three, both the\\r\\n        // first and second bits were set; in that case, revert with an error.\\r\\n        if (invalidNativeOfferItemErrorBuffer == 3) {\\r\\n            revert InvalidNativeOfferItem();\\r\\n        }\\r\\n\\r\\n        // Apply criteria resolvers to each order as applicable.\\r\\n        _applyCriteriaResolvers(advancedOrders, criteriaResolvers);\\r\\n\\r\\n        // Emit an event for each order signifying that it has been fulfilled.\\r\\n        // Skip overflow checks as all for loops are indexed starting at zero.\\r\\n        unchecked {\\r\\n            // Iterate over each order.\\r\\n            for (uint256 i = 0; i < totalOrders; ++i) {\\r\\n                // Do not emit an event if no order hash is present.\\r\\n                if (orderHashes[i] == bytes32(0)) {\\r\\n                    continue;\\r\\n                }\\r\\n\\r\\n                // Retrieve parameters for the order in question.\\r\\n                OrderParameters memory orderParameters = (\\r\\n                    advancedOrders[i].parameters\\r\\n                );\\r\\n\\r\\n                // Emit an OrderFulfilled event.\\r\\n                _emitOrderFulfilledEvent(\\r\\n                    orderHashes[i],\\r\\n                    orderParameters.offerer,\\r\\n                    orderParameters.zone,\\r\\n                    recipient,\\r\\n                    orderParameters.offer,\\r\\n                    orderParameters.consideration\\r\\n                );\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to fulfill a group of validated orders, fully or\\r\\n     *      partially, with an arbitrary number of items for offer and\\r\\n     *      consideration per order and to execute transfers. Any order that is\\r\\n     *      not currently active, has already been fully filled, or has been\\r\\n     *      cancelled will be omitted. Remaining offer and consideration items\\r\\n     *      will then be aggregated where possible as indicated by the supplied\\r\\n     *      offer and consideration component arrays and aggregated items will\\r\\n     *      be transferred to the fulfiller or to each intended recipient,\\r\\n     *      respectively. Note that a failing item transfer or an issue with\\r\\n     *      order formatting will cause the entire batch to fail.\\r\\n     *\\r\\n     * @param advancedOrders            The orders to fulfill along with the\\r\\n     *                                  fraction of those orders to attempt to\\r\\n     *                                  fill. Note that both the offerer and the\\r\\n     *                                  fulfiller must first approve this\\r\\n     *                                  contract (or the conduit if indicated by\\r\\n     *                                  the order) to transfer any relevant\\r\\n     *                                  tokens on their behalf and that\\r\\n     *                                  contracts must implement\\r\\n     *                                  `onERC1155Received` in order to receive\\r\\n     *                                  ERC1155 tokens as consideration. Also\\r\\n     *                                  note that all offer and consideration\\r\\n     *                                  components must have no remainder after\\r\\n     *                                  multiplication of the respective amount\\r\\n     *                                  with the supplied fraction for an\\r\\n     *                                  order's partial fill amount to be\\r\\n     *                                  considered valid.\\r\\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\\r\\n     *                                  indicating which offer items to attempt\\r\\n     *                                  to aggregate when preparing executions.\\r\\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\\r\\n     *                                  indicating which consideration items to\\r\\n     *                                  attempt to aggregate when preparing\\r\\n     *                                  executions.\\r\\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\\r\\n     *                                  if any, to source the fulfiller's token\\r\\n     *                                  approvals from. The zero hash signifies\\r\\n     *                                  that no conduit should be used, with\\r\\n     *                                  direct approvals set on Consideration.\\r\\n     * @param recipient                 The intended recipient for all received\\r\\n     *                                  items.\\r\\n     *\\r\\n     * @return availableOrders An array of booleans indicating if each order\\r\\n     *                         with an index corresponding to the index of the\\r\\n     *                         returned boolean was fulfillable or not.\\r\\n     * @return executions      An array of elements indicating the sequence of\\r\\n     *                         transfers performed as part of matching the given\\r\\n     *                         orders.\\r\\n     */\\r\\n    function _executeAvailableFulfillments(\\r\\n        AdvancedOrder[] memory advancedOrders,\\r\\n        FulfillmentComponent[][] memory offerFulfillments,\\r\\n        FulfillmentComponent[][] memory considerationFulfillments,\\r\\n        bytes32 fulfillerConduitKey,\\r\\n        address recipient\\r\\n    )\\r\\n        internal\\r\\n        returns (bool[] memory availableOrders, Execution[] memory executions)\\r\\n    {\\r\\n        // Retrieve length of offer fulfillments array and place on the stack.\\r\\n        uint256 totalOfferFulfillments = offerFulfillments.length;\\r\\n\\r\\n        // Retrieve length of consideration fulfillments array & place on stack.\\r\\n        uint256 totalConsiderationFulfillments = (\\r\\n            considerationFulfillments.length\\r\\n        );\\r\\n\\r\\n        // Allocate an execution for each offer and consideration fulfillment.\\r\\n        executions = new Execution[](\\r\\n            totalOfferFulfillments + totalConsiderationFulfillments\\r\\n        );\\r\\n\\r\\n        // Skip overflow checks as all for loops are indexed starting at zero.\\r\\n        unchecked {\\r\\n            // Track number of filtered executions.\\r\\n            uint256 totalFilteredExecutions = 0;\\r\\n\\r\\n            // Iterate over each offer fulfillment.\\r\\n            for (uint256 i = 0; i < totalOfferFulfillments; ++i) {\\r\\n                /// Retrieve the offer fulfillment components in question.\\r\\n                FulfillmentComponent[] memory components = (\\r\\n                    offerFulfillments[i]\\r\\n                );\\r\\n\\r\\n                // Derive aggregated execution corresponding with fulfillment.\\r\\n                Execution memory execution = _aggregateAvailable(\\r\\n                    advancedOrders,\\r\\n                    Side.OFFER,\\r\\n                    components,\\r\\n                    fulfillerConduitKey,\\r\\n                    recipient\\r\\n                );\\r\\n\\r\\n                // If offerer and recipient on the execution are the same...\\r\\n                if (execution.item.recipient == execution.offerer) {\\r\\n                    // Increment total filtered executions.\\r\\n                    ++totalFilteredExecutions;\\r\\n                } else {\\r\\n                    // Otherwise, assign the execution to the executions array.\\r\\n                    executions[i - totalFilteredExecutions] = execution;\\r\\n                }\\r\\n            }\\r\\n\\r\\n            // Iterate over each consideration fulfillment.\\r\\n            for (uint256 i = 0; i < totalConsiderationFulfillments; ++i) {\\r\\n                /// Retrieve consideration fulfillment components in question.\\r\\n                FulfillmentComponent[] memory components = (\\r\\n                    considerationFulfillments[i]\\r\\n                );\\r\\n\\r\\n                // Derive aggregated execution corresponding with fulfillment.\\r\\n                Execution memory execution = _aggregateAvailable(\\r\\n                    advancedOrders,\\r\\n                    Side.CONSIDERATION,\\r\\n                    components,\\r\\n                    fulfillerConduitKey,\\r\\n                    address(0) // unused\\r\\n                );\\r\\n\\r\\n                // If offerer and recipient on the execution are the same...\\r\\n                if (execution.item.recipient == execution.offerer) {\\r\\n                    // Increment total filtered executions.\\r\\n                    ++totalFilteredExecutions;\\r\\n                } else {\\r\\n                    // Otherwise, assign the execution to the executions array.\\r\\n                    executions[\\r\\n                        i + totalOfferFulfillments - totalFilteredExecutions\\r\\n                    ] = execution;\\r\\n                }\\r\\n            }\\r\\n\\r\\n            // If some number of executions have been filtered...\\r\\n            if (totalFilteredExecutions != 0) {\\r\\n                // reduce the total length of the executions array.\\r\\n                assembly {\\r\\n                    mstore(\\r\\n                        executions,\\r\\n                        sub(mload(executions), totalFilteredExecutions)\\r\\n                    )\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Revert if no orders are available.\\r\\n        if (executions.length == 0) {\\r\\n            revert NoSpecifiedOrdersAvailable();\\r\\n        }\\r\\n\\r\\n        // Perform final checks and return.\\r\\n        availableOrders = _performFinalChecksAndExecuteOrders(\\r\\n            advancedOrders,\\r\\n            executions\\r\\n        );\\r\\n\\r\\n        return (availableOrders, executions);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to perform a final check that each consideration\\r\\n     *      item for an arbitrary number of fulfilled orders has been met and to\\r\\n     *      trigger associated executions, transferring the respective items.\\r\\n     *\\r\\n     * @param advancedOrders     The orders to check and perform executions for.\\r\\n     * @param executions         An array of elements indicating the sequence of\\r\\n     *                           transfers to perform when fulfilling the given\\r\\n     *                           orders.\\r\\n     *\\r\\n     * @return availableOrders An array of booleans indicating if each order\\r\\n     *                         with an index corresponding to the index of the\\r\\n     *                         returned boolean was fulfillable or not.\\r\\n     */\\r\\n    function _performFinalChecksAndExecuteOrders(\\r\\n        AdvancedOrder[] memory advancedOrders,\\r\\n        Execution[] memory executions\\r\\n    ) internal returns (bool[] memory availableOrders) {\\r\\n        // Retrieve the length of the advanced orders array and place on stack.\\r\\n        uint256 totalOrders = advancedOrders.length;\\r\\n\\r\\n        // Initialize array for tracking available orders.\\r\\n        availableOrders = new bool[](totalOrders);\\r\\n\\r\\n        // Skip overflow checks as all for loops are indexed starting at zero.\\r\\n        unchecked {\\r\\n            // Iterate over orders to ensure all considerations are met.\\r\\n            for (uint256 i = 0; i < totalOrders; ++i) {\\r\\n                // Retrieve the order in question.\\r\\n                AdvancedOrder memory advancedOrder = advancedOrders[i];\\r\\n\\r\\n                // Skip consideration item checks for order if not fulfilled.\\r\\n                if (advancedOrder.numerator == 0) {\\r\\n                    // Note: orders do not need to be marked as unavailable as a\\r\\n                    // new memory region has been allocated. Review carefully if\\r\\n                    // altering compiler version or managing memory manually.\\r\\n                    continue;\\r\\n                }\\r\\n\\r\\n                // Mark the order as available.\\r\\n                availableOrders[i] = true;\\r\\n\\r\\n                // Retrieve consideration items to ensure they are fulfilled.\\r\\n                ConsiderationItem[] memory consideration = (\\r\\n                    advancedOrder.parameters.consideration\\r\\n                );\\r\\n\\r\\n                // Read length of consideration array and place on the stack.\\r\\n                uint256 totalConsiderationItems = consideration.length;\\r\\n\\r\\n                // Iterate over each consideration item to ensure it is met.\\r\\n                for (uint256 j = 0; j < totalConsiderationItems; ++j) {\\r\\n                    // Retrieve remaining amount on the consideration item.\\r\\n                    uint256 unmetAmount = consideration[j].startAmount;\\r\\n\\r\\n                    // Revert if the remaining amount is not zero.\\r\\n                    if (unmetAmount != 0) {\\r\\n                        revert ConsiderationNotMet(i, j, unmetAmount);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Put ether value supplied by the caller on the stack.\\r\\n        uint256 etherRemaining = msg.value;\\r\\n\\r\\n        // Initialize an accumulator array. From this point forward, no new\\r\\n        // memory regions can be safely allocated until the accumulator is no\\r\\n        // longer being utilized, as the accumulator operates in an open-ended\\r\\n        // fashion from this memory pointer; existing memory may still be\\r\\n        // accessed and modified, however.\\r\\n        bytes memory accumulator = new bytes(AccumulatorDisarmed);\\r\\n\\r\\n        // Retrieve the length of the executions array and place on stack.\\r\\n        uint256 totalExecutions = executions.length;\\r\\n\\r\\n        // Iterate over each execution.\\r\\n        for (uint256 i = 0; i < totalExecutions; ) {\\r\\n            // Retrieve the execution and the associated received item.\\r\\n            Execution memory execution = executions[i];\\r\\n            ReceivedItem memory item = execution.item;\\r\\n\\r\\n            // If execution transfers native tokens, reduce value available.\\r\\n            if (item.itemType == ItemType.NATIVE) {\\r\\n                // Ensure that sufficient native tokens are still available.\\r\\n                if (item.amount > etherRemaining) {\\r\\n                    revert InsufficientEtherSupplied();\\r\\n                }\\r\\n\\r\\n                // Skip underflow check as amount is less than ether remaining.\\r\\n                unchecked {\\r\\n                    etherRemaining -= item.amount;\\r\\n                }\\r\\n            }\\r\\n\\r\\n            // Transfer the item specified by the execution.\\r\\n            _transfer(\\r\\n                item,\\r\\n                execution.offerer,\\r\\n                execution.conduitKey,\\r\\n                accumulator\\r\\n            );\\r\\n\\r\\n            // Skip overflow check as for loop is indexed starting at zero.\\r\\n            unchecked {\\r\\n                ++i;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Trigger any remaining accumulated transfers via call to the conduit.\\r\\n        _triggerIfArmed(accumulator);\\r\\n\\r\\n        // If any ether remains after fulfillments, return it to the caller.\\r\\n        if (etherRemaining != 0) {\\r\\n            _transferEth(payable(msg.sender), etherRemaining);\\r\\n        }\\r\\n\\r\\n        // Clear the reentrancy guard.\\r\\n        _clearReentrancyGuard();\\r\\n\\r\\n        // Return the array containing available orders.\\r\\n        return (availableOrders);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to match an arbitrary number of full or partial\\r\\n     *      orders, each with an arbitrary number of items for offer and\\r\\n     *      consideration, supplying criteria resolvers containing specific\\r\\n     *      token identifiers and associated proofs as well as fulfillments\\r\\n     *      allocating offer components to consideration components.\\r\\n     *\\r\\n     * @param advancedOrders    The advanced orders to match. Note that both the\\r\\n     *                          offerer and fulfiller on each order must first\\r\\n     *                          approve this contract (or their conduit if\\r\\n     *                          indicated by the order) to transfer any relevant\\r\\n     *                          tokens on their behalf and each consideration\\r\\n     *                          recipient must implement `onERC1155Received` in\\r\\n     *                          order to receive ERC1155 tokens. Also note that\\r\\n     *                          the offer and consideration components for each\\r\\n     *                          order must have no remainder after multiplying\\r\\n     *                          the respective amount with the supplied fraction\\r\\n     *                          in order for the group of partial fills to be\\r\\n     *                          considered valid.\\r\\n     * @param criteriaResolvers An array where each element contains a reference\\r\\n     *                          to a specific order as well as that order's\\r\\n     *                          offer or consideration, a token identifier, and\\r\\n     *                          a proof that the supplied token identifier is\\r\\n     *                          contained in the order's merkle root. Note that\\r\\n     *                          an empty root indicates that any (transferable)\\r\\n     *                          token identifier is valid and that no associated\\r\\n     *                          proof needs to be supplied.\\r\\n     * @param fulfillments      An array of elements allocating offer components\\r\\n     *                          to consideration components. Note that each\\r\\n     *                          consideration component must be fully met in\\r\\n     *                          order for the match operation to be valid.\\r\\n     *\\r\\n     * @return executions An array of elements indicating the sequence of\\r\\n     *                    transfers performed as part of matching the given\\r\\n     *                    orders.\\r\\n     */\\r\\n    function _matchAdvancedOrders(\\r\\n        AdvancedOrder[] memory advancedOrders,\\r\\n        CriteriaResolver[] memory criteriaResolvers,\\r\\n        Fulfillment[] calldata fulfillments\\r\\n    ) internal returns (Execution[] memory executions) {\\r\\n        // Validate orders, update order status, and determine item amounts.\\r\\n        _validateOrdersAndPrepareToFulfill(\\r\\n            advancedOrders,\\r\\n            criteriaResolvers,\\r\\n            true, // Signifies that invalid orders should revert.\\r\\n            advancedOrders.length,\\r\\n            address(0) // OrderFulfilled event has no recipient when matching.\\r\\n        );\\r\\n\\r\\n        // Fulfill the orders using the supplied fulfillments.\\r\\n        return _fulfillAdvancedOrders(advancedOrders, fulfillments);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to fulfill an arbitrary number of orders, either\\r\\n     *      full or partial, after validating, adjusting amounts, and applying\\r\\n     *      criteria resolvers.\\r\\n     *\\r\\n     * @param advancedOrders     The orders to match, including a fraction to\\r\\n     *                           attempt to fill for each order.\\r\\n     * @param fulfillments       An array of elements allocating offer\\r\\n     *                           components to consideration components. Note\\r\\n     *                           that the final amount of each consideration\\r\\n     *                           component must be zero for a match operation to\\r\\n     *                           be considered valid.\\r\\n     *\\r\\n     * @return executions An array of elements indicating the sequence of\\r\\n     *                    transfers performed as part of matching the given\\r\\n     *                    orders.\\r\\n     */\\r\\n    function _fulfillAdvancedOrders(\\r\\n        AdvancedOrder[] memory advancedOrders,\\r\\n        Fulfillment[] calldata fulfillments\\r\\n    ) internal returns (Execution[] memory executions) {\\r\\n        // Retrieve fulfillments array length and place on the stack.\\r\\n        uint256 totalFulfillments = fulfillments.length;\\r\\n\\r\\n        // Allocate executions by fulfillment and apply them to each execution.\\r\\n        executions = new Execution[](totalFulfillments);\\r\\n\\r\\n        // Skip overflow checks as all for loops are indexed starting at zero.\\r\\n        unchecked {\\r\\n            // Track number of filtered executions.\\r\\n            uint256 totalFilteredExecutions = 0;\\r\\n\\r\\n            // Iterate over each fulfillment.\\r\\n            for (uint256 i = 0; i < totalFulfillments; ++i) {\\r\\n                /// Retrieve the fulfillment in question.\\r\\n                Fulfillment calldata fulfillment = fulfillments[i];\\r\\n\\r\\n                // Derive the execution corresponding with the fulfillment.\\r\\n                Execution memory execution = _applyFulfillment(\\r\\n                    advancedOrders,\\r\\n                    fulfillment.offerComponents,\\r\\n                    fulfillment.considerationComponents\\r\\n                );\\r\\n\\r\\n                // If offerer and recipient on the execution are the same...\\r\\n                if (execution.item.recipient == execution.offerer) {\\r\\n                    // Increment total filtered executions.\\r\\n                    ++totalFilteredExecutions;\\r\\n                } else {\\r\\n                    // Otherwise, assign the execution to the executions array.\\r\\n                    executions[i - totalFilteredExecutions] = execution;\\r\\n                }\\r\\n            }\\r\\n\\r\\n            // If some number of executions have been filtered...\\r\\n            if (totalFilteredExecutions != 0) {\\r\\n                // reduce the total length of the executions array.\\r\\n                assembly {\\r\\n                    mstore(\\r\\n                        executions,\\r\\n                        sub(mload(executions), totalFilteredExecutions)\\r\\n                    )\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Perform final checks and execute orders.\\r\\n        _performFinalChecksAndExecuteOrders(advancedOrders, executions);\\r\\n\\r\\n        // Return the executions array.\\r\\n        return (executions);\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xff5522e0ab4e402feb7f1ce88a645d185f3f3c1cccca84185e589384d1f64240\",\"license\":\"MIT\"},\"contracts/lib/OrderFulfiller.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.13;\\r\\n\\r\\nimport { ItemType } from \\\"./ConsiderationEnums.sol\\\";\\r\\n\\r\\n// prettier-ignore\\r\\nimport {\\r\\n    OfferItem,\\r\\n    ConsiderationItem,\\r\\n    SpentItem,\\r\\n    ReceivedItem,\\r\\n    OrderParameters,\\r\\n    Order,\\r\\n    AdvancedOrder,\\r\\n    CriteriaResolver\\r\\n} from \\\"./ConsiderationStructs.sol\\\";\\r\\n\\r\\nimport { BasicOrderFulfiller } from \\\"./BasicOrderFulfiller.sol\\\";\\r\\n\\r\\nimport { CriteriaResolution } from \\\"./CriteriaResolution.sol\\\";\\r\\n\\r\\nimport { AmountDeriver } from \\\"./AmountDeriver.sol\\\";\\r\\n\\r\\nimport \\\"./ConsiderationConstants.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title OrderFulfiller\\r\\n * @author 0age\\r\\n * @notice OrderFulfiller contains logic related to order fulfillment where a\\r\\n *         single order is being fulfilled and where basic order fulfillment is\\r\\n *         not available as an option.\\r\\n */\\r\\ncontract OrderFulfiller is\\r\\n    BasicOrderFulfiller,\\r\\n    CriteriaResolution,\\r\\n    AmountDeriver\\r\\n{\\r\\n    /**\\r\\n     * @dev Derive and set hashes, reference chainId, and associated domain\\r\\n     *      separator during deployment.\\r\\n     *\\r\\n     * @param conduitController A contract that deploys conduits, or proxies\\r\\n     *                          that may optionally be used to transfer approved\\r\\n     *                          ERC20/721/1155 tokens.\\r\\n     */\\r\\n    constructor(address conduitController)\\r\\n        BasicOrderFulfiller(conduitController)\\r\\n    {}\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to validate an order and update its status, adjust\\r\\n     *      prices based on current time, apply criteria resolvers, determine\\r\\n     *      what portion to fill, and transfer relevant tokens.\\r\\n     *\\r\\n     * @param advancedOrder       The order to fulfill as well as the fraction\\r\\n     *                            to fill. Note that all offer and consideration\\r\\n     *                            components must divide with no remainder for\\r\\n     *                            the partial fill to be valid.\\r\\n     * @param criteriaResolvers   An array where each element contains a\\r\\n     *                            reference to a specific offer or\\r\\n     *                            consideration, a token identifier, and a proof\\r\\n     *                            that the supplied token identifier is\\r\\n     *                            contained in the order's merkle root. Note\\r\\n     *                            that a criteria of zero indicates that any\\r\\n     *                            (transferable) token identifier is valid and\\r\\n     *                            that no proof needs to be supplied.\\r\\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\\r\\n     *                            any, to source the fulfiller's token approvals\\r\\n     *                            from. The zero hash signifies that no conduit\\r\\n     *                            should be used, with direct approvals set on\\r\\n     *                            Consideration.\\r\\n     * @param recipient           The intended recipient for all received items.\\r\\n     *\\r\\n     * @return A boolean indicating whether the order has been fulfilled.\\r\\n     */\\r\\n    function _validateAndFulfillAdvancedOrder(\\r\\n        AdvancedOrder memory advancedOrder,\\r\\n        CriteriaResolver[] memory criteriaResolvers,\\r\\n        bytes32 fulfillerConduitKey,\\r\\n        address recipient\\r\\n    ) internal returns (bool) {\\r\\n        // Ensure this function cannot be triggered during a reentrant call.\\r\\n        _setReentrancyGuard();\\r\\n\\r\\n        // Declare empty bytes32 array (unused, will remain empty).\\r\\n        bytes32[] memory priorOrderHashes;\\r\\n\\r\\n        // Validate order, update status, and determine fraction to fill.\\r\\n        (\\r\\n            bytes32 orderHash,\\r\\n            uint256 fillNumerator,\\r\\n            uint256 fillDenominator\\r\\n        ) = _validateOrderAndUpdateStatus(\\r\\n                advancedOrder,\\r\\n                criteriaResolvers,\\r\\n                true,\\r\\n                priorOrderHashes\\r\\n            );\\r\\n\\r\\n        // Create an array with length 1 containing the order.\\r\\n        AdvancedOrder[] memory advancedOrders = new AdvancedOrder[](1);\\r\\n\\r\\n        // Populate the order as the first and only element of the new array.\\r\\n        advancedOrders[0] = advancedOrder;\\r\\n\\r\\n        // Apply criteria resolvers using generated orders and details arrays.\\r\\n        _applyCriteriaResolvers(advancedOrders, criteriaResolvers);\\r\\n\\r\\n        // Retrieve the order parameters after applying criteria resolvers.\\r\\n        OrderParameters memory orderParameters = advancedOrders[0].parameters;\\r\\n\\r\\n        // Perform each item transfer with the appropriate fractional amount.\\r\\n        _applyFractionsAndTransferEach(\\r\\n            orderParameters,\\r\\n            fillNumerator,\\r\\n            fillDenominator,\\r\\n            fulfillerConduitKey,\\r\\n            recipient\\r\\n        );\\r\\n\\r\\n        // Emit an event signifying that the order has been fulfilled.\\r\\n        _emitOrderFulfilledEvent(\\r\\n            orderHash,\\r\\n            orderParameters.offerer,\\r\\n            orderParameters.zone,\\r\\n            recipient,\\r\\n            orderParameters.offer,\\r\\n            orderParameters.consideration\\r\\n        );\\r\\n\\r\\n        // Clear the reentrancy guard.\\r\\n        _clearReentrancyGuard();\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to transfer each item contained in a given single\\r\\n     *      order fulfillment after applying a respective fraction to the amount\\r\\n     *      being transferred.\\r\\n     *\\r\\n     * @param orderParameters     The parameters for the fulfilled order.\\r\\n     * @param numerator           A value indicating the portion of the order\\r\\n     *                            that should be filled.\\r\\n     * @param denominator         A value indicating the total order size.\\r\\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\\r\\n     *                            any, to source the fulfiller's token approvals\\r\\n     *                            from. The zero hash signifies that no conduit\\r\\n     *                            should be used, with direct approvals set on\\r\\n     *                            Consideration.\\r\\n     * @param recipient           The intended recipient for all received items.\\r\\n     */\\r\\n    function _applyFractionsAndTransferEach(\\r\\n        OrderParameters memory orderParameters,\\r\\n        uint256 numerator,\\r\\n        uint256 denominator,\\r\\n        bytes32 fulfillerConduitKey,\\r\\n        address recipient\\r\\n    ) internal {\\r\\n        // Read start time & end time from order parameters and place on stack.\\r\\n        uint256 startTime = orderParameters.startTime;\\r\\n        uint256 endTime = orderParameters.endTime;\\r\\n\\r\\n        // Initialize an accumulator array. From this point forward, no new\\r\\n        // memory regions can be safely allocated until the accumulator is no\\r\\n        // longer being utilized, as the accumulator operates in an open-ended\\r\\n        // fashion from this memory pointer; existing memory may still be\\r\\n        // accessed and modified, however.\\r\\n        bytes memory accumulator = new bytes(AccumulatorDisarmed);\\r\\n\\r\\n        // As of solidity 0.6.0, inline assembly cannot directly access function\\r\\n        // definitions, but can still access locally scoped function variables.\\r\\n        // This means that in order to recast the type of a function, we need to\\r\\n        // create a local variable to reference the internal function definition\\r\\n        // (using the same type) and a local variable with the desired type,\\r\\n        // and then cast the original function pointer to the desired type.\\r\\n\\r\\n        /**\\r\\n         * Repurpose existing OfferItem memory regions on the offer array for\\r\\n         * the order by overriding the _transfer function pointer to accept a\\r\\n         * modified OfferItem argument in place of the usual ReceivedItem:\\r\\n         *\\r\\n         *   ========= OfferItem ==========   ====== ReceivedItem ======\\r\\n         *   ItemType itemType; ------------> ItemType itemType;\\r\\n         *   address token; ----------------> address token;\\r\\n         *   uint256 identifierOrCriteria; -> uint256 identifier;\\r\\n         *   uint256 startAmount; ----------> uint256 amount;\\r\\n         *   uint256 endAmount; ------------> address recipient;\\r\\n         */\\r\\n\\r\\n        // Declare a nested scope to minimize stack depth.\\r\\n        unchecked {\\r\\n            // Declare a virtual function pointer taking an OfferItem argument.\\r\\n            function(OfferItem memory, address, bytes32, bytes memory)\\r\\n                internal _transferOfferItem;\\r\\n\\r\\n            {\\r\\n                // Assign _transfer function to a new function pointer (it takes\\r\\n                // a ReceivedItem as its initial argument)\\r\\n                function(ReceivedItem memory, address, bytes32, bytes memory)\\r\\n                    internal _transferReceivedItem = _transfer;\\r\\n\\r\\n                // Utilize assembly to override the virtual function pointer.\\r\\n                assembly {\\r\\n                    // Cast initial ReceivedItem type to an OfferItem type.\\r\\n                    _transferOfferItem := _transferReceivedItem\\r\\n                }\\r\\n            }\\r\\n\\r\\n            // Read offer array length from memory and place on stack.\\r\\n            uint256 totalOfferItems = orderParameters.offer.length;\\r\\n\\r\\n            // Iterate over each offer on the order.\\r\\n            // Skip overflow check as for loop is indexed starting at zero.\\r\\n            for (uint256 i = 0; i < totalOfferItems; ++i) {\\r\\n                // Retrieve the offer item.\\r\\n                OfferItem memory offerItem = orderParameters.offer[i];\\r\\n\\r\\n                // Offer items for the native token can not be received\\r\\n                // outside of a match order function.\\r\\n                if (offerItem.itemType == ItemType.NATIVE) {\\r\\n                    revert InvalidNativeOfferItem();\\r\\n                }\\r\\n\\r\\n                // Declare an additional nested scope to minimize stack depth.\\r\\n                {\\r\\n                    // Apply fill fraction to get offer item amount to transfer.\\r\\n                    uint256 amount = _applyFraction(\\r\\n                        offerItem.startAmount,\\r\\n                        offerItem.endAmount,\\r\\n                        numerator,\\r\\n                        denominator,\\r\\n                        startTime,\\r\\n                        endTime,\\r\\n                        false\\r\\n                    );\\r\\n\\r\\n                    // Utilize assembly to set overloaded offerItem arguments.\\r\\n                    assembly {\\r\\n                        // Write new fractional amount to startAmount as amount.\\r\\n                        mstore(\\r\\n                            add(offerItem, ReceivedItem_amount_offset),\\r\\n                            amount\\r\\n                        )\\r\\n\\r\\n                        // Write recipient to endAmount.\\r\\n                        mstore(\\r\\n                            add(offerItem, ReceivedItem_recipient_offset),\\r\\n                            recipient\\r\\n                        )\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                // Transfer the item from the offerer to the recipient.\\r\\n                _transferOfferItem(\\r\\n                    offerItem,\\r\\n                    orderParameters.offerer,\\r\\n                    orderParameters.conduitKey,\\r\\n                    accumulator\\r\\n                );\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Put ether value supplied by the caller on the stack.\\r\\n        uint256 etherRemaining = msg.value;\\r\\n\\r\\n        /**\\r\\n         * Repurpose existing ConsiderationItem memory regions on the\\r\\n         * consideration array for the order by overriding the _transfer\\r\\n         * function pointer to accept a modified ConsiderationItem argument in\\r\\n         * place of the usual ReceivedItem:\\r\\n         *\\r\\n         *   ====== ConsiderationItem =====   ====== ReceivedItem ======\\r\\n         *   ItemType itemType; ------------> ItemType itemType;\\r\\n         *   address token; ----------------> address token;\\r\\n         *   uint256 identifierOrCriteria;--> uint256 identifier;\\r\\n         *   uint256 startAmount; ----------> uint256 amount;\\r\\n         *   uint256 endAmount;        /----> address recipient;\\r\\n         *   address recipient; ------/\\r\\n         */\\r\\n\\r\\n        // Declare a nested scope to minimize stack depth.\\r\\n        unchecked {\\r\\n            // Declare virtual function pointer with ConsiderationItem argument.\\r\\n            function(ConsiderationItem memory, address, bytes32, bytes memory)\\r\\n                internal _transferConsiderationItem;\\r\\n            {\\r\\n                // Reassign _transfer function to a new function pointer (it\\r\\n                // takes a ReceivedItem as its initial argument).\\r\\n                function(ReceivedItem memory, address, bytes32, bytes memory)\\r\\n                    internal _transferReceivedItem = _transfer;\\r\\n\\r\\n                // Utilize assembly to override the virtual function pointer.\\r\\n                assembly {\\r\\n                    // Cast ReceivedItem type to ConsiderationItem type.\\r\\n                    _transferConsiderationItem := _transferReceivedItem\\r\\n                }\\r\\n            }\\r\\n\\r\\n            // Read consideration array length from memory and place on stack.\\r\\n            uint256 totalConsiderationItems = orderParameters\\r\\n                .consideration\\r\\n                .length;\\r\\n\\r\\n            // Iterate over each consideration item on the order.\\r\\n            // Skip overflow check as for loop is indexed starting at zero.\\r\\n            for (uint256 i = 0; i < totalConsiderationItems; ++i) {\\r\\n                // Retrieve the consideration item.\\r\\n                ConsiderationItem memory considerationItem = (\\r\\n                    orderParameters.consideration[i]\\r\\n                );\\r\\n\\r\\n                // Apply fraction & derive considerationItem amount to transfer.\\r\\n                uint256 amount = _applyFraction(\\r\\n                    considerationItem.startAmount,\\r\\n                    considerationItem.endAmount,\\r\\n                    numerator,\\r\\n                    denominator,\\r\\n                    startTime,\\r\\n                    endTime,\\r\\n                    true\\r\\n                );\\r\\n\\r\\n                // Use assembly to set overloaded considerationItem arguments.\\r\\n                assembly {\\r\\n                    // Write derived fractional amount to startAmount as amount.\\r\\n                    mstore(\\r\\n                        add(considerationItem, ReceivedItem_amount_offset),\\r\\n                        amount\\r\\n                    )\\r\\n\\r\\n                    // Write original recipient to endAmount as recipient.\\r\\n                    mstore(\\r\\n                        add(considerationItem, ReceivedItem_recipient_offset),\\r\\n                        mload(\\r\\n                            add(\\r\\n                                considerationItem,\\r\\n                                ConsiderationItem_recipient_offset\\r\\n                            )\\r\\n                        )\\r\\n                    )\\r\\n                }\\r\\n\\r\\n                // Reduce available value if offer spent ETH or a native token.\\r\\n                if (considerationItem.itemType == ItemType.NATIVE) {\\r\\n                    // Ensure that sufficient native tokens are still available.\\r\\n                    if (amount > etherRemaining) {\\r\\n                        revert InsufficientEtherSupplied();\\r\\n                    }\\r\\n\\r\\n                    // Skip underflow check as a comparison has just been made.\\r\\n                    etherRemaining -= amount;\\r\\n                }\\r\\n\\r\\n                // Transfer item from caller to recipient specified by the item.\\r\\n                _transferConsiderationItem(\\r\\n                    considerationItem,\\r\\n                    msg.sender,\\r\\n                    fulfillerConduitKey,\\r\\n                    accumulator\\r\\n                );\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Trigger any remaining accumulated transfers via call to the conduit.\\r\\n        _triggerIfArmed(accumulator);\\r\\n\\r\\n        // If any ether remains after fulfillments...\\r\\n        if (etherRemaining != 0) {\\r\\n            // return it to the caller.\\r\\n            _transferEth(payable(msg.sender), etherRemaining);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to emit an OrderFulfilled event. OfferItems are\\r\\n     *      translated into SpentItems and ConsiderationItems are translated\\r\\n     *      into ReceivedItems.\\r\\n     *\\r\\n     * @param orderHash     The order hash.\\r\\n     * @param offerer       The offerer for the order.\\r\\n     * @param zone          The zone for the order.\\r\\n     * @param fulfiller     The fulfiller of the order, or the null address if\\r\\n     *                      the order was fulfilled via order matching.\\r\\n     * @param offer         The offer items for the order.\\r\\n     * @param consideration The consideration items for the order.\\r\\n     */\\r\\n    function _emitOrderFulfilledEvent(\\r\\n        bytes32 orderHash,\\r\\n        address offerer,\\r\\n        address zone,\\r\\n        address fulfiller,\\r\\n        OfferItem[] memory offer,\\r\\n        ConsiderationItem[] memory consideration\\r\\n    ) internal {\\r\\n        // Cast already-modified offer memory region as spent items.\\r\\n        SpentItem[] memory spentItems;\\r\\n        assembly {\\r\\n            spentItems := offer\\r\\n        }\\r\\n\\r\\n        // Cast already-modified consideration memory region as received items.\\r\\n        ReceivedItem[] memory receivedItems;\\r\\n        assembly {\\r\\n            receivedItems := consideration\\r\\n        }\\r\\n\\r\\n        // Emit an event signifying that the order has been fulfilled.\\r\\n        emit OrderFulfilled(\\r\\n            orderHash,\\r\\n            offerer,\\r\\n            zone,\\r\\n            fulfiller,\\r\\n            spentItems,\\r\\n            receivedItems\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal pure function to convert an order to an advanced order with\\r\\n     *      numerator and denominator of 1 and empty extraData.\\r\\n     *\\r\\n     * @param order The order to convert.\\r\\n     *\\r\\n     * @return advancedOrder The new advanced order.\\r\\n     */\\r\\n    function _convertOrderToAdvanced(Order calldata order)\\r\\n        internal\\r\\n        pure\\r\\n        returns (AdvancedOrder memory advancedOrder)\\r\\n    {\\r\\n        // Convert to partial order (1/1 or full fill) and return new value.\\r\\n        advancedOrder = AdvancedOrder(\\r\\n            order.parameters,\\r\\n            1,\\r\\n            1,\\r\\n            order.signature,\\r\\n            \\\"\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal pure function to convert an array of orders to an array of\\r\\n     *      advanced orders with numerator and denominator of 1.\\r\\n     *\\r\\n     * @param orders The orders to convert.\\r\\n     *\\r\\n     * @return advancedOrders The new array of partial orders.\\r\\n     */\\r\\n    function _convertOrdersToAdvanced(Order[] calldata orders)\\r\\n        internal\\r\\n        pure\\r\\n        returns (AdvancedOrder[] memory advancedOrders)\\r\\n    {\\r\\n        // Read the number of orders from calldata and place on the stack.\\r\\n        uint256 totalOrders = orders.length;\\r\\n\\r\\n        // Allocate new empty array for each partial order in memory.\\r\\n        advancedOrders = new AdvancedOrder[](totalOrders);\\r\\n\\r\\n        // Skip overflow check as the index for the loop starts at zero.\\r\\n        unchecked {\\r\\n            // Iterate over the given orders.\\r\\n            for (uint256 i = 0; i < totalOrders; ++i) {\\r\\n                // Convert to partial order (1/1 or full fill) and update array.\\r\\n                advancedOrders[i] = _convertOrderToAdvanced(orders[i]);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Return the array of advanced orders.\\r\\n        return advancedOrders;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x90640be6005068485343d584d695a4be0da785f21a3092b48197f3e4f40cb8f1\",\"license\":\"MIT\"},\"contracts/lib/OrderValidator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.13;\\r\\n\\r\\nimport { OrderType } from \\\"./ConsiderationEnums.sol\\\";\\r\\n\\r\\n// prettier-ignore\\r\\nimport {\\r\\n    OrderParameters,\\r\\n    Order,\\r\\n    AdvancedOrder,\\r\\n    OrderComponents,\\r\\n    OrderStatus,\\r\\n    CriteriaResolver\\r\\n} from \\\"./ConsiderationStructs.sol\\\";\\r\\n\\r\\nimport \\\"./ConsiderationConstants.sol\\\";\\r\\n\\r\\nimport { Executor } from \\\"./Executor.sol\\\";\\r\\n\\r\\nimport { ZoneInteraction } from \\\"./ZoneInteraction.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title OrderValidator\\r\\n * @author 0age\\r\\n * @notice OrderValidator contains functionality related to validating orders\\r\\n *         and updating their status.\\r\\n */\\r\\ncontract OrderValidator is Executor, ZoneInteraction {\\r\\n    // Track status of each order (validated, cancelled, and fraction filled).\\r\\n    mapping(bytes32 => OrderStatus) private _orderStatus;\\r\\n\\r\\n    /**\\r\\n     * @dev Derive and set hashes, reference chainId, and associated domain\\r\\n     *      separator during deployment.\\r\\n     *\\r\\n     * @param conduitController A contract that deploys conduits, or proxies\\r\\n     *                          that may optionally be used to transfer approved\\r\\n     *                          ERC20/721/1155 tokens.\\r\\n     */\\r\\n    constructor(address conduitController) Executor(conduitController) {}\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to verify and update the status of a basic order.\\r\\n     *\\r\\n     * @param orderHash The hash of the order.\\r\\n     * @param offerer   The offerer of the order.\\r\\n     * @param signature A signature from the offerer indicating that the order\\r\\n     *                  has been approved.\\r\\n     */\\r\\n    function _validateBasicOrderAndUpdateStatus(\\r\\n        bytes32 orderHash,\\r\\n        address offerer,\\r\\n        bytes memory signature\\r\\n    ) internal {\\r\\n        // Retrieve the order status for the given order hash.\\r\\n        OrderStatus storage orderStatus = _orderStatus[orderHash];\\r\\n\\r\\n        // Ensure order is fillable and is not cancelled.\\r\\n        _verifyOrderStatus(\\r\\n            orderHash,\\r\\n            orderStatus,\\r\\n            true, // Only allow unused orders when fulfilling basic orders.\\r\\n            true // Signifies to revert if the order is invalid.\\r\\n        );\\r\\n\\r\\n        // If the order is not already validated, verify the supplied signature.\\r\\n        if (!orderStatus.isValidated) {\\r\\n            _verifySignature(offerer, orderHash, signature);\\r\\n        }\\r\\n\\r\\n        // Update order status as fully filled, packing struct values.\\r\\n        orderStatus.isValidated = true;\\r\\n        orderStatus.isCancelled = false;\\r\\n        orderStatus.numerator = 1;\\r\\n        orderStatus.denominator = 1;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to validate an order, determine what portion to\\r\\n     *      fill, and update its status. The desired fill amount is supplied as\\r\\n     *      a fraction, as is the returned amount to fill.\\r\\n     *\\r\\n     * @param advancedOrder     The order to fulfill as well as the fraction to\\r\\n     *                          fill. Note that all offer and consideration\\r\\n     *                          amounts must divide with no remainder in order\\r\\n     *                          for a partial fill to be valid.\\r\\n     * @param criteriaResolvers An array where each element contains a reference\\r\\n     *                          to a specific offer or consideration, a token\\r\\n     *                          identifier, and a proof that the supplied token\\r\\n     *                          identifier is contained in the order's merkle\\r\\n     *                          root. Note that a criteria of zero indicates\\r\\n     *                          that any (transferable) token identifier is\\r\\n     *                          valid and that no proof needs to be supplied.\\r\\n     * @param revertOnInvalid   A boolean indicating whether to revert if the\\r\\n     *                          order is invalid due to the time or status.\\r\\n     * @param priorOrderHashes  The order hashes of each order supplied prior to\\r\\n     *                          the current order as part of a \\\"match\\\" variety\\r\\n     *                          of order fulfillment (e.g. this array will be\\r\\n     *                          empty for single or \\\"fulfill available\\\").\\r\\n     *\\r\\n     * @return orderHash      The order hash.\\r\\n     * @return newNumerator   A value indicating the portion of the order that\\r\\n     *                        will be filled.\\r\\n     * @return newDenominator A value indicating the total size of the order.\\r\\n     */\\r\\n    function _validateOrderAndUpdateStatus(\\r\\n        AdvancedOrder memory advancedOrder,\\r\\n        CriteriaResolver[] memory criteriaResolvers,\\r\\n        bool revertOnInvalid,\\r\\n        bytes32[] memory priorOrderHashes\\r\\n    )\\r\\n        internal\\r\\n        returns (\\r\\n            bytes32 orderHash,\\r\\n            uint256 newNumerator,\\r\\n            uint256 newDenominator\\r\\n        )\\r\\n    {\\r\\n        // Retrieve the parameters for the order.\\r\\n        OrderParameters memory orderParameters = advancedOrder.parameters;\\r\\n\\r\\n        // Ensure current timestamp falls between order start time and end time.\\r\\n        if (\\r\\n            !_verifyTime(\\r\\n                orderParameters.startTime,\\r\\n                orderParameters.endTime,\\r\\n                revertOnInvalid\\r\\n            )\\r\\n        ) {\\r\\n            // Assuming an invalid time and no revert, return zeroed out values.\\r\\n            return (bytes32(0), 0, 0);\\r\\n        }\\r\\n\\r\\n        // Read numerator and denominator from memory and place on the stack.\\r\\n        uint256 numerator = uint256(advancedOrder.numerator);\\r\\n        uint256 denominator = uint256(advancedOrder.denominator);\\r\\n\\r\\n        // Ensure that the supplied numerator and denominator are valid.\\r\\n        if (numerator > denominator || numerator == 0) {\\r\\n            revert BadFraction();\\r\\n        }\\r\\n\\r\\n        // If attempting partial fill (n < d) check order type & ensure support.\\r\\n        if (\\r\\n            numerator < denominator &&\\r\\n            _doesNotSupportPartialFills(orderParameters.orderType)\\r\\n        ) {\\r\\n            // Revert if partial fill was attempted on an unsupported order.\\r\\n            revert PartialFillsNotEnabledForOrder();\\r\\n        }\\r\\n\\r\\n        // Retrieve current counter & use it w/ parameters to derive order hash.\\r\\n        orderHash = _assertConsiderationLengthAndGetOrderHash(orderParameters);\\r\\n\\r\\n        // Ensure restricted orders have a valid submitter or pass a zone check.\\r\\n        _assertRestrictedAdvancedOrderValidity(\\r\\n            advancedOrder,\\r\\n            criteriaResolvers,\\r\\n            priorOrderHashes,\\r\\n            orderHash,\\r\\n            orderParameters.zoneHash,\\r\\n            orderParameters.orderType,\\r\\n            orderParameters.offerer,\\r\\n            orderParameters.zone\\r\\n        );\\r\\n\\r\\n        // Retrieve the order status using the derived order hash.\\r\\n        OrderStatus storage orderStatus = _orderStatus[orderHash];\\r\\n\\r\\n        // Ensure order is fillable and is not cancelled.\\r\\n        if (\\r\\n            !_verifyOrderStatus(\\r\\n                orderHash,\\r\\n                orderStatus,\\r\\n                false, // Allow partially used orders to be filled.\\r\\n                revertOnInvalid\\r\\n            )\\r\\n        ) {\\r\\n            // Assuming an invalid order status and no revert, return zero fill.\\r\\n            return (orderHash, 0, 0);\\r\\n        }\\r\\n\\r\\n        // If the order is not already validated, verify the supplied signature.\\r\\n        if (!orderStatus.isValidated) {\\r\\n            _verifySignature(\\r\\n                orderParameters.offerer,\\r\\n                orderHash,\\r\\n                advancedOrder.signature\\r\\n            );\\r\\n        }\\r\\n\\r\\n        // Read filled amount as numerator and denominator and put on the stack.\\r\\n        uint256 filledNumerator = orderStatus.numerator;\\r\\n        uint256 filledDenominator = orderStatus.denominator;\\r\\n\\r\\n        // If order (orderStatus) currently has a non-zero denominator it is\\r\\n        // partially filled.\\r\\n        if (filledDenominator != 0) {\\r\\n            // If denominator of 1 supplied, fill all remaining amount on order.\\r\\n            if (denominator == 1) {\\r\\n                // Scale numerator & denominator to match current denominator.\\r\\n                numerator = filledDenominator;\\r\\n                denominator = filledDenominator;\\r\\n            }\\r\\n            // Otherwise, if supplied denominator differs from current one...\\r\\n            else if (filledDenominator != denominator) {\\r\\n                // scale current numerator by the supplied denominator, then...\\r\\n                filledNumerator *= denominator;\\r\\n\\r\\n                // the supplied numerator & denominator by current denominator.\\r\\n                numerator *= filledDenominator;\\r\\n                denominator *= filledDenominator;\\r\\n            }\\r\\n\\r\\n            // Once adjusted, if current+supplied numerator exceeds denominator:\\r\\n            if (filledNumerator + numerator > denominator) {\\r\\n                // Skip underflow check: denominator >= orderStatus.numerator\\r\\n                unchecked {\\r\\n                    // Reduce current numerator so it + supplied = denominator.\\r\\n                    numerator = denominator - filledNumerator;\\r\\n                }\\r\\n            }\\r\\n\\r\\n            // Increment the filled numerator by the new numerator.\\r\\n            filledNumerator += numerator;\\r\\n\\r\\n            // Use assembly to ensure fractional amounts are below max uint120.\\r\\n            assembly {\\r\\n                // Check filledNumerator and denominator for uint120 overflow.\\r\\n                if or(\\r\\n                    gt(filledNumerator, MaxUint120),\\r\\n                    gt(denominator, MaxUint120)\\r\\n                ) {\\r\\n                    // Derive greatest common divisor using euclidean algorithm.\\r\\n                    function gcd(_a, _b) -> out {\\r\\n                        for {\\r\\n\\r\\n                        } _b {\\r\\n\\r\\n                        } {\\r\\n                            let _c := _b\\r\\n                            _b := mod(_a, _c)\\r\\n                            _a := _c\\r\\n                        }\\r\\n                        out := _a\\r\\n                    }\\r\\n                    let scaleDown := gcd(\\r\\n                        numerator,\\r\\n                        gcd(filledNumerator, denominator)\\r\\n                    )\\r\\n\\r\\n                    // Ensure that the divisor is at least one.\\r\\n                    let safeScaleDown := add(scaleDown, iszero(scaleDown))\\r\\n\\r\\n                    // Scale all fractional values down by gcd.\\r\\n                    numerator := div(numerator, safeScaleDown)\\r\\n                    filledNumerator := div(filledNumerator, safeScaleDown)\\r\\n                    denominator := div(denominator, safeScaleDown)\\r\\n\\r\\n                    // Perform the overflow check a second time.\\r\\n                    if or(\\r\\n                        gt(filledNumerator, MaxUint120),\\r\\n                        gt(denominator, MaxUint120)\\r\\n                    ) {\\r\\n                        // Store the Panic error signature.\\r\\n                        mstore(0, Panic_error_signature)\\r\\n\\r\\n                        // Set arithmetic (0x11) panic code as initial argument.\\r\\n                        mstore(Panic_error_offset, Panic_arithmetic)\\r\\n\\r\\n                        // Return, supplying Panic signature & arithmetic code.\\r\\n                        revert(0, Panic_error_length)\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            // Skip overflow check: checked above unless numerator is reduced.\\r\\n            unchecked {\\r\\n                // Update order status and fill amount, packing struct values.\\r\\n                orderStatus.isValidated = true;\\r\\n                orderStatus.isCancelled = false;\\r\\n                orderStatus.numerator = uint120(filledNumerator);\\r\\n                orderStatus.denominator = uint120(denominator);\\r\\n            }\\r\\n        } else {\\r\\n            // Update order status and fill amount, packing struct values.\\r\\n            orderStatus.isValidated = true;\\r\\n            orderStatus.isCancelled = false;\\r\\n            orderStatus.numerator = uint120(numerator);\\r\\n            orderStatus.denominator = uint120(denominator);\\r\\n        }\\r\\n\\r\\n        // Return order hash, a modified numerator, and a modified denominator.\\r\\n        return (orderHash, numerator, denominator);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to cancel an arbitrary number of orders. Note that\\r\\n     *      only the offerer or the zone of a given order may cancel it. Callers\\r\\n     *      should ensure that the intended order was cancelled by calling\\r\\n     *      `getOrderStatus` and confirming that `isCancelled` returns `true`.\\r\\n     *\\r\\n     * @param orders The orders to cancel.\\r\\n     *\\r\\n     * @return cancelled A boolean indicating whether the supplied orders were\\r\\n     *                   successfully cancelled.\\r\\n     */\\r\\n    function _cancel(OrderComponents[] calldata orders)\\r\\n        internal\\r\\n        returns (bool cancelled)\\r\\n    {\\r\\n        // Ensure that the reentrancy guard is not currently set.\\r\\n        _assertNonReentrant();\\r\\n\\r\\n        // Declare variables outside of the loop.\\r\\n        OrderStatus storage orderStatus;\\r\\n        address offerer;\\r\\n        address zone;\\r\\n\\r\\n        // Skip overflow check as for loop is indexed starting at zero.\\r\\n        unchecked {\\r\\n            // Read length of the orders array from memory and place on stack.\\r\\n            uint256 totalOrders = orders.length;\\r\\n\\r\\n            // Iterate over each order.\\r\\n            for (uint256 i = 0; i < totalOrders; ) {\\r\\n                // Retrieve the order.\\r\\n                OrderComponents calldata order = orders[i];\\r\\n\\r\\n                offerer = order.offerer;\\r\\n                zone = order.zone;\\r\\n\\r\\n                // Ensure caller is either offerer or zone of the order.\\r\\n                if (msg.sender != offerer && msg.sender != zone) {\\r\\n                    revert InvalidCanceller();\\r\\n                }\\r\\n\\r\\n                // Derive order hash using the order parameters and the counter.\\r\\n                bytes32 orderHash = _deriveOrderHash(\\r\\n                    OrderParameters(\\r\\n                        offerer,\\r\\n                        zone,\\r\\n                        order.offer,\\r\\n                        order.consideration,\\r\\n                        order.orderType,\\r\\n                        order.startTime,\\r\\n                        order.endTime,\\r\\n                        order.zoneHash,\\r\\n                        order.salt,\\r\\n                        order.conduitKey,\\r\\n                        order.consideration.length\\r\\n                    ),\\r\\n                    order.counter\\r\\n                );\\r\\n\\r\\n                // Retrieve the order status using the derived order hash.\\r\\n                orderStatus = _orderStatus[orderHash];\\r\\n\\r\\n                // Update the order status as not valid and cancelled.\\r\\n                orderStatus.isValidated = false;\\r\\n                orderStatus.isCancelled = true;\\r\\n\\r\\n                // Emit an event signifying that the order has been cancelled.\\r\\n                emit OrderCancelled(orderHash, offerer, zone);\\r\\n\\r\\n                // Increment counter inside body of loop for gas efficiency.\\r\\n                ++i;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Return a boolean indicating that orders were successfully cancelled.\\r\\n        cancelled = true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to validate an arbitrary number of orders, thereby\\r\\n     *      registering their signatures as valid and allowing the fulfiller to\\r\\n     *      skip signature verification on fulfillment. Note that validated\\r\\n     *      orders may still be unfulfillable due to invalid item amounts or\\r\\n     *      other factors; callers should determine whether validated orders are\\r\\n     *      fulfillable by simulating the fulfillment call prior to execution.\\r\\n     *      Also note that anyone can validate a signed order, but only the\\r\\n     *      offerer can validate an order without supplying a signature.\\r\\n     *\\r\\n     * @param orders The orders to validate.\\r\\n     *\\r\\n     * @return validated A boolean indicating whether the supplied orders were\\r\\n     *                   successfully validated.\\r\\n     */\\r\\n    function _validate(Order[] calldata orders)\\r\\n        internal\\r\\n        returns (bool validated)\\r\\n    {\\r\\n        // Ensure that the reentrancy guard is not currently set.\\r\\n        _assertNonReentrant();\\r\\n\\r\\n        // Declare variables outside of the loop.\\r\\n        OrderStatus storage orderStatus;\\r\\n        bytes32 orderHash;\\r\\n        address offerer;\\r\\n\\r\\n        // Skip overflow check as for loop is indexed starting at zero.\\r\\n        unchecked {\\r\\n            // Read length of the orders array from memory and place on stack.\\r\\n            uint256 totalOrders = orders.length;\\r\\n\\r\\n            // Iterate over each order.\\r\\n            for (uint256 i = 0; i < totalOrders; ) {\\r\\n                // Retrieve the order.\\r\\n                Order calldata order = orders[i];\\r\\n\\r\\n                // Retrieve the order parameters.\\r\\n                OrderParameters calldata orderParameters = order.parameters;\\r\\n\\r\\n                // Move offerer from memory to the stack.\\r\\n                offerer = orderParameters.offerer;\\r\\n\\r\\n                // Get current counter & use it w/ params to derive order hash.\\r\\n                orderHash = _assertConsiderationLengthAndGetOrderHash(\\r\\n                    orderParameters\\r\\n                );\\r\\n\\r\\n                // Retrieve the order status using the derived order hash.\\r\\n                orderStatus = _orderStatus[orderHash];\\r\\n\\r\\n                // Ensure order is fillable and retrieve the filled amount.\\r\\n                _verifyOrderStatus(\\r\\n                    orderHash,\\r\\n                    orderStatus,\\r\\n                    false, // Signifies that partially filled orders are valid.\\r\\n                    true // Signifies to revert if the order is invalid.\\r\\n                );\\r\\n\\r\\n                // If the order has not already been validated...\\r\\n                if (!orderStatus.isValidated) {\\r\\n                    // Verify the supplied signature.\\r\\n                    _verifySignature(offerer, orderHash, order.signature);\\r\\n\\r\\n                    // Update order status to mark the order as valid.\\r\\n                    orderStatus.isValidated = true;\\r\\n\\r\\n                    // Emit an event signifying the order has been validated.\\r\\n                    emit OrderValidated(\\r\\n                        orderHash,\\r\\n                        offerer,\\r\\n                        orderParameters.zone\\r\\n                    );\\r\\n                }\\r\\n\\r\\n                // Increment counter inside body of the loop for gas efficiency.\\r\\n                ++i;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Return a boolean indicating that orders were successfully validated.\\r\\n        validated = true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal view function to retrieve the status of a given order by\\r\\n     *      hash, including whether the order has been cancelled or validated\\r\\n     *      and the fraction of the order that has been filled.\\r\\n     *\\r\\n     * @param orderHash The order hash in question.\\r\\n     *\\r\\n     * @return isValidated A boolean indicating whether the order in question\\r\\n     *                     has been validated (i.e. previously approved or\\r\\n     *                     partially filled).\\r\\n     * @return isCancelled A boolean indicating whether the order in question\\r\\n     *                     has been cancelled.\\r\\n     * @return totalFilled The total portion of the order that has been filled\\r\\n     *                     (i.e. the \\\"numerator\\\").\\r\\n     * @return totalSize   The total size of the order that is either filled or\\r\\n     *                     unfilled (i.e. the \\\"denominator\\\").\\r\\n     */\\r\\n    function _getOrderStatus(bytes32 orderHash)\\r\\n        internal\\r\\n        view\\r\\n        returns (\\r\\n            bool isValidated,\\r\\n            bool isCancelled,\\r\\n            uint256 totalFilled,\\r\\n            uint256 totalSize\\r\\n        )\\r\\n    {\\r\\n        // Retrieve the order status using the order hash.\\r\\n        OrderStatus storage orderStatus = _orderStatus[orderHash];\\r\\n\\r\\n        // Return the fields on the order status.\\r\\n        return (\\r\\n            orderStatus.isValidated,\\r\\n            orderStatus.isCancelled,\\r\\n            orderStatus.numerator,\\r\\n            orderStatus.denominator\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal pure function to check whether a given order type indicates\\r\\n     *      that partial fills are not supported (e.g. only \\\"full fills\\\" are\\r\\n     *      allowed for the order in question).\\r\\n     *\\r\\n     * @param orderType The order type in question.\\r\\n     *\\r\\n     * @return isFullOrder A boolean indicating whether the order type only\\r\\n     *                     supports full fills.\\r\\n     */\\r\\n    function _doesNotSupportPartialFills(OrderType orderType)\\r\\n        internal\\r\\n        pure\\r\\n        returns (bool isFullOrder)\\r\\n    {\\r\\n        // The \\\"full\\\" order types are even, while \\\"partial\\\" order types are odd.\\r\\n        // Bitwise and by 1 is equivalent to modulo by 2, but 2 gas cheaper.\\r\\n        assembly {\\r\\n            // Equivalent to `uint256(orderType) & 1 == 0`.\\r\\n            isFullOrder := iszero(and(orderType, 1))\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x0a880fc1a91b537a02489b051b3145ce126f605d24273ca0e1a5b52f7810071c\",\"license\":\"MIT\"},\"contracts/lib/ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.13;\\r\\n\\r\\nimport { ReentrancyErrors } from \\\"../interfaces/ReentrancyErrors.sol\\\";\\r\\n\\r\\nimport \\\"./ConsiderationConstants.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title ReentrancyGuard\\r\\n * @author 0age\\r\\n * @notice ReentrancyGuard contains a storage variable and related functionality\\r\\n *         for protecting against reentrancy.\\r\\n */\\r\\ncontract ReentrancyGuard is ReentrancyErrors {\\r\\n    // Prevent reentrant calls on protected functions.\\r\\n    uint256 private _reentrancyGuard;\\r\\n\\r\\n    /**\\r\\n     * @dev Initialize the reentrancy guard during deployment.\\r\\n     */\\r\\n    constructor() {\\r\\n        // Initialize the reentrancy guard in a cleared state.\\r\\n        _reentrancyGuard = _NOT_ENTERED;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to ensure that the sentinel value for the\\r\\n     *      reentrancy guard is not currently set and, if not, to set the\\r\\n     *      sentinel value for the reentrancy guard.\\r\\n     */\\r\\n    function _setReentrancyGuard() internal {\\r\\n        // Ensure that the reentrancy guard is not already set.\\r\\n        _assertNonReentrant();\\r\\n\\r\\n        // Set the reentrancy guard.\\r\\n        _reentrancyGuard = _ENTERED;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to unset the reentrancy guard sentinel value.\\r\\n     */\\r\\n    function _clearReentrancyGuard() internal {\\r\\n        // Clear the reentrancy guard.\\r\\n        _reentrancyGuard = _NOT_ENTERED;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal view function to ensure that the sentinel value for the\\r\\n            reentrancy guard is not currently set.\\r\\n     */\\r\\n    function _assertNonReentrant() internal view {\\r\\n        // Ensure that the reentrancy guard is not currently set.\\r\\n        if (_reentrancyGuard != _NOT_ENTERED) {\\r\\n            revert NoReentrantCalls();\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xa234526fb3da7aebebc9d963be1e152d7707830f8916f54bda0b985ecf4d7924\",\"license\":\"MIT\"},\"contracts/lib/SignatureVerification.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.13;\\r\\n\\r\\nimport { EIP1271Interface } from \\\"../interfaces/EIP1271Interface.sol\\\";\\r\\n\\r\\n// prettier-ignore\\r\\nimport {\\r\\n    SignatureVerificationErrors\\r\\n} from \\\"../interfaces/SignatureVerificationErrors.sol\\\";\\r\\n\\r\\nimport { LowLevelHelpers } from \\\"./LowLevelHelpers.sol\\\";\\r\\n\\r\\nimport \\\"./ConsiderationConstants.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title SignatureVerification\\r\\n * @author 0age\\r\\n * @notice SignatureVerification contains logic for verifying signatures.\\r\\n */\\r\\ncontract SignatureVerification is SignatureVerificationErrors, LowLevelHelpers {\\r\\n    /**\\r\\n     * @dev Internal view function to verify the signature of an order. An\\r\\n     *      ERC-1271 fallback will be attempted if either the signature length\\r\\n     *      is not 64 or 65 bytes or if the recovered signer does not match the\\r\\n     *      supplied signer.\\r\\n     *\\r\\n     * @param signer    The signer for the order.\\r\\n     * @param digest    The digest to verify the signature against.\\r\\n     * @param signature A signature from the signer indicating that the order\\r\\n     *                  has been approved.\\r\\n     */\\r\\n    function _assertValidSignature(\\r\\n        address signer,\\r\\n        bytes32 digest,\\r\\n        bytes memory signature\\r\\n    ) internal view {\\r\\n        // Declare value for ecrecover equality or 1271 call success status.\\r\\n        bool success;\\r\\n\\r\\n        // Utilize assembly to perform optimized signature verification check.\\r\\n        assembly {\\r\\n            // Ensure that first word of scratch space is empty.\\r\\n            mstore(0, 0)\\r\\n\\r\\n            // Declare value for v signature parameter.\\r\\n            let v\\r\\n\\r\\n            // Get the length of the signature.\\r\\n            let signatureLength := mload(signature)\\r\\n\\r\\n            // Get the pointer to the value preceding the signature length.\\r\\n            // This will be used for temporary memory overrides - either the\\r\\n            // signature head for isValidSignature or the digest for ecrecover.\\r\\n            let wordBeforeSignaturePtr := sub(signature, OneWord)\\r\\n\\r\\n            // Cache the current value behind the signature to restore it later.\\r\\n            let cachedWordBeforeSignature := mload(wordBeforeSignaturePtr)\\r\\n\\r\\n            // Declare lenDiff + recoveredSigner scope to manage stack pressure.\\r\\n            {\\r\\n                // Take the difference between the max ECDSA signature length\\r\\n                // and the actual signature length. Overflow desired for any\\r\\n                // values > 65. If the diff is not 0 or 1, it is not a valid\\r\\n                // ECDSA signature - move on to EIP1271 check.\\r\\n                let lenDiff := sub(ECDSA_MaxLength, signatureLength)\\r\\n\\r\\n                // Declare variable for recovered signer.\\r\\n                let recoveredSigner\\r\\n\\r\\n                // If diff is 0 or 1, it may be an ECDSA signature.\\r\\n                // Try to recover signer.\\r\\n                if iszero(gt(lenDiff, 1)) {\\r\\n                    // Read the signature `s` value.\\r\\n                    let originalSignatureS := mload(\\r\\n                        add(signature, ECDSA_signature_s_offset)\\r\\n                    )\\r\\n\\r\\n                    // Read the first byte of the word after `s`. If the\\r\\n                    // signature is 65 bytes, this will be the real `v` value.\\r\\n                    // If not, it will need to be modified - doing it this way\\r\\n                    // saves an extra condition.\\r\\n                    v := byte(\\r\\n                        0,\\r\\n                        mload(add(signature, ECDSA_signature_v_offset))\\r\\n                    )\\r\\n\\r\\n                    // If lenDiff is 1, parse 64-byte signature as ECDSA.\\r\\n                    if lenDiff {\\r\\n                        // Extract yParity from highest bit of vs and add 27 to\\r\\n                        // get v.\\r\\n                        v := add(\\r\\n                            shr(MaxUint8, originalSignatureS),\\r\\n                            Signature_lower_v\\r\\n                        )\\r\\n\\r\\n                        // Extract canonical s from vs, all but the highest bit.\\r\\n                        // Temporarily overwrite the original `s` value in the\\r\\n                        // signature.\\r\\n                        mstore(\\r\\n                            add(signature, ECDSA_signature_s_offset),\\r\\n                            and(\\r\\n                                originalSignatureS,\\r\\n                                EIP2098_allButHighestBitMask\\r\\n                            )\\r\\n                        )\\r\\n                    }\\r\\n                    // Temporarily overwrite the signature length with `v` to\\r\\n                    // conform to the expected input for ecrecover.\\r\\n                    mstore(signature, v)\\r\\n\\r\\n                    // Temporarily overwrite the word before the length with\\r\\n                    // `digest` to conform to the expected input for ecrecover.\\r\\n                    mstore(wordBeforeSignaturePtr, digest)\\r\\n\\r\\n                    // Attempt to recover the signer for the given signature. Do\\r\\n                    // not check the call status as ecrecover will return a null\\r\\n                    // address if the signature is invalid.\\r\\n                    pop(\\r\\n                        staticcall(\\r\\n                            gas(),\\r\\n                            Ecrecover_precompile, // Call ecrecover precompile.\\r\\n                            wordBeforeSignaturePtr, // Use data memory location.\\r\\n                            Ecrecover_args_size, // Size of digest, v, r, and s.\\r\\n                            0, // Write result to scratch space.\\r\\n                            OneWord // Provide size of returned result.\\r\\n                        )\\r\\n                    )\\r\\n\\r\\n                    // Restore cached word before signature.\\r\\n                    mstore(wordBeforeSignaturePtr, cachedWordBeforeSignature)\\r\\n\\r\\n                    // Restore cached signature length.\\r\\n                    mstore(signature, signatureLength)\\r\\n\\r\\n                    // Restore cached signature `s` value.\\r\\n                    mstore(\\r\\n                        add(signature, ECDSA_signature_s_offset),\\r\\n                        originalSignatureS\\r\\n                    )\\r\\n\\r\\n                    // Read the recovered signer from the buffer given as return\\r\\n                    // space for ecrecover.\\r\\n                    recoveredSigner := mload(0)\\r\\n                }\\r\\n\\r\\n                // Set success to true if the signature provided was a valid\\r\\n                // ECDSA signature and the signer is not the null address. Use\\r\\n                // gt instead of direct as success is used outside of assembly.\\r\\n                success := and(eq(signer, recoveredSigner), gt(signer, 0))\\r\\n            }\\r\\n\\r\\n            // If the signature was not verified with ecrecover, try EIP1271.\\r\\n            if iszero(success) {\\r\\n                // Temporarily overwrite the word before the signature length\\r\\n                // and use it as the head of the signature input to\\r\\n                // `isValidSignature`, which has a value of 64.\\r\\n                mstore(\\r\\n                    wordBeforeSignaturePtr,\\r\\n                    EIP1271_isValidSignature_signature_head_offset\\r\\n                )\\r\\n\\r\\n                // Get pointer to use for the selector of `isValidSignature`.\\r\\n                let selectorPtr := sub(\\r\\n                    signature,\\r\\n                    EIP1271_isValidSignature_selector_negativeOffset\\r\\n                )\\r\\n\\r\\n                // Cache the value currently stored at the selector pointer.\\r\\n                let cachedWordOverwrittenBySelector := mload(selectorPtr)\\r\\n\\r\\n                // Get pointer to use for `digest` input to `isValidSignature`.\\r\\n                let digestPtr := sub(\\r\\n                    signature,\\r\\n                    EIP1271_isValidSignature_digest_negativeOffset\\r\\n                )\\r\\n\\r\\n                // Cache the value currently stored at the digest pointer.\\r\\n                let cachedWordOverwrittenByDigest := mload(digestPtr)\\r\\n\\r\\n                // Write the selector first, since it overlaps the digest.\\r\\n                mstore(selectorPtr, EIP1271_isValidSignature_selector)\\r\\n\\r\\n                // Next, write the digest.\\r\\n                mstore(digestPtr, digest)\\r\\n\\r\\n                // Call signer with `isValidSignature` to validate signature.\\r\\n                success := staticcall(\\r\\n                    gas(),\\r\\n                    signer,\\r\\n                    selectorPtr,\\r\\n                    add(\\r\\n                        signatureLength,\\r\\n                        EIP1271_isValidSignature_calldata_baseLength\\r\\n                    ),\\r\\n                    0,\\r\\n                    OneWord\\r\\n                )\\r\\n\\r\\n                // Determine if the signature is valid on successful calls.\\r\\n                if success {\\r\\n                    // If first word of scratch space does not contain EIP-1271\\r\\n                    // signature selector, revert.\\r\\n                    if iszero(eq(mload(0), EIP1271_isValidSignature_selector)) {\\r\\n                        // Revert with bad 1271 signature if signer has code.\\r\\n                        if extcodesize(signer) {\\r\\n                            // Bad contract signature.\\r\\n                            mstore(0, BadContractSignature_error_signature)\\r\\n                            revert(0, BadContractSignature_error_length)\\r\\n                        }\\r\\n\\r\\n                        // Check if signature length was invalid.\\r\\n                        if gt(sub(ECDSA_MaxLength, signatureLength), 1) {\\r\\n                            // Revert with generic invalid signature error.\\r\\n                            mstore(0, InvalidSignature_error_signature)\\r\\n                            revert(0, InvalidSignature_error_length)\\r\\n                        }\\r\\n\\r\\n                        // Check if v was invalid.\\r\\n                        if iszero(\\r\\n                            byte(v, ECDSA_twentySeventhAndTwentyEighthBytesSet)\\r\\n                        ) {\\r\\n                            // Revert with invalid v value.\\r\\n                            mstore(0, BadSignatureV_error_signature)\\r\\n                            mstore(BadSignatureV_error_offset, v)\\r\\n                            revert(0, BadSignatureV_error_length)\\r\\n                        }\\r\\n\\r\\n                        // Revert with generic invalid signer error message.\\r\\n                        mstore(0, InvalidSigner_error_signature)\\r\\n                        revert(0, InvalidSigner_error_length)\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                // Restore the cached values overwritten by selector, digest and\\r\\n                // signature head.\\r\\n                mstore(wordBeforeSignaturePtr, cachedWordBeforeSignature)\\r\\n                mstore(selectorPtr, cachedWordOverwrittenBySelector)\\r\\n                mstore(digestPtr, cachedWordOverwrittenByDigest)\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // If the call failed...\\r\\n        if (!success) {\\r\\n            // Revert and pass reason along if one was returned.\\r\\n            _revertWithReasonIfOneIsReturned();\\r\\n\\r\\n            // Otherwise, revert with error indicating bad contract signature.\\r\\n            assembly {\\r\\n                mstore(0, BadContractSignature_error_signature)\\r\\n                revert(0, BadContractSignature_error_length)\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xc7f3d0de5a8c6aa91ef99e75e9ad9e19a66fea02e927b324ae8314c5a740f57b\",\"license\":\"MIT\"},\"contracts/lib/TokenTransferrer.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.7;\\r\\n\\r\\nimport \\\"./TokenTransferrerConstants.sol\\\";\\r\\n\\r\\n// prettier-ignore\\r\\nimport {\\r\\n    TokenTransferrerErrors\\r\\n} from \\\"../interfaces/TokenTransferrerErrors.sol\\\";\\r\\n\\r\\nimport { ConduitBatch1155Transfer } from \\\"../conduit/lib/ConduitStructs.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title TokenTransferrer\\r\\n * @author 0age\\r\\n * @custom:coauthor d1ll0n\\r\\n * @custom:coauthor transmissions11\\r\\n * @notice TokenTransferrer is a library for performing optimized ERC20, ERC721,\\r\\n *         ERC1155, and batch ERC1155 transfers, used by both Seaport as well as\\r\\n *         by conduits deployed by the ConduitController. Use great caution when\\r\\n *         considering these functions for use in other codebases, as there are\\r\\n *         significant side effects and edge cases that need to be thoroughly\\r\\n *         understood and carefully addressed.\\r\\n */\\r\\ncontract TokenTransferrer is TokenTransferrerErrors {\\r\\n    /**\\r\\n     * @dev Internal function to transfer ERC20 tokens from a given originator\\r\\n     *      to a given recipient. Sufficient approvals must be set on the\\r\\n     *      contract performing the transfer.\\r\\n     *\\r\\n     * @param token      The ERC20 token to transfer.\\r\\n     * @param from       The originator of the transfer.\\r\\n     * @param to         The recipient of the transfer.\\r\\n     * @param amount     The amount to transfer.\\r\\n     */\\r\\n    function _performERC20Transfer(\\r\\n        address token,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal {\\r\\n        // Utilize assembly to perform an optimized ERC20 token transfer.\\r\\n        assembly {\\r\\n            // The free memory pointer memory slot will be used when populating\\r\\n            // call data for the transfer; read the value and restore it later.\\r\\n            let memPointer := mload(FreeMemoryPointerSlot)\\r\\n\\r\\n            // Write call data into memory, starting with function selector.\\r\\n            mstore(ERC20_transferFrom_sig_ptr, ERC20_transferFrom_signature)\\r\\n            mstore(ERC20_transferFrom_from_ptr, from)\\r\\n            mstore(ERC20_transferFrom_to_ptr, to)\\r\\n            mstore(ERC20_transferFrom_amount_ptr, amount)\\r\\n\\r\\n            // Make call & copy up to 32 bytes of return data to scratch space.\\r\\n            // Scratch space does not need to be cleared ahead of time, as the\\r\\n            // subsequent check will ensure that either at least a full word of\\r\\n            // return data is received (in which case it will be overwritten) or\\r\\n            // that no data is received (in which case scratch space will be\\r\\n            // ignored) on a successful call to the given token.\\r\\n            let callStatus := call(\\r\\n                gas(),\\r\\n                token,\\r\\n                0,\\r\\n                ERC20_transferFrom_sig_ptr,\\r\\n                ERC20_transferFrom_length,\\r\\n                0,\\r\\n                OneWord\\r\\n            )\\r\\n\\r\\n            // Determine whether transfer was successful using status & result.\\r\\n            let success := and(\\r\\n                // Set success to whether the call reverted, if not check it\\r\\n                // either returned exactly 1 (can't just be non-zero data), or\\r\\n                // had no return data.\\r\\n                or(\\r\\n                    and(eq(mload(0), 1), gt(returndatasize(), 31)),\\r\\n                    iszero(returndatasize())\\r\\n                ),\\r\\n                callStatus\\r\\n            )\\r\\n\\r\\n            // Handle cases where either the transfer failed or no data was\\r\\n            // returned. Group these, as most transfers will succeed with data.\\r\\n            // Equivalent to `or(iszero(success), iszero(returndatasize()))`\\r\\n            // but after it's inverted for JUMPI this expression is cheaper.\\r\\n            if iszero(and(success, iszero(iszero(returndatasize())))) {\\r\\n                // If the token has no code or the transfer failed: Equivalent\\r\\n                // to `or(iszero(success), iszero(extcodesize(token)))` but\\r\\n                // after it's inverted for JUMPI this expression is cheaper.\\r\\n                if iszero(and(iszero(iszero(extcodesize(token))), success)) {\\r\\n                    // If the transfer failed:\\r\\n                    if iszero(success) {\\r\\n                        // If it was due to a revert:\\r\\n                        if iszero(callStatus) {\\r\\n                            // If it returned a message, bubble it up as long as\\r\\n                            // sufficient gas remains to do so:\\r\\n                            if returndatasize() {\\r\\n                                // Ensure that sufficient gas is available to\\r\\n                                // copy returndata while expanding memory where\\r\\n                                // necessary. Start by computing the word size\\r\\n                                // of returndata and allocated memory. Round up\\r\\n                                // to the nearest full word.\\r\\n                                let returnDataWords := div(\\r\\n                                    add(returndatasize(), AlmostOneWord),\\r\\n                                    OneWord\\r\\n                                )\\r\\n\\r\\n                                // Note: use the free memory pointer in place of\\r\\n                                // msize() to work around a Yul warning that\\r\\n                                // prevents accessing msize directly when the IR\\r\\n                                // pipeline is activated.\\r\\n                                let msizeWords := div(memPointer, OneWord)\\r\\n\\r\\n                                // Next, compute the cost of the returndatacopy.\\r\\n                                let cost := mul(CostPerWord, returnDataWords)\\r\\n\\r\\n                                // Then, compute cost of new memory allocation.\\r\\n                                if gt(returnDataWords, msizeWords) {\\r\\n                                    cost := add(\\r\\n                                        cost,\\r\\n                                        add(\\r\\n                                            mul(\\r\\n                                                sub(\\r\\n                                                    returnDataWords,\\r\\n                                                    msizeWords\\r\\n                                                ),\\r\\n                                                CostPerWord\\r\\n                                            ),\\r\\n                                            div(\\r\\n                                                sub(\\r\\n                                                    mul(\\r\\n                                                        returnDataWords,\\r\\n                                                        returnDataWords\\r\\n                                                    ),\\r\\n                                                    mul(msizeWords, msizeWords)\\r\\n                                                ),\\r\\n                                                MemoryExpansionCoefficient\\r\\n                                            )\\r\\n                                        )\\r\\n                                    )\\r\\n                                }\\r\\n\\r\\n                                // Finally, add a small constant and compare to\\r\\n                                // gas remaining; bubble up the revert data if\\r\\n                                // enough gas is still available.\\r\\n                                if lt(add(cost, ExtraGasBuffer), gas()) {\\r\\n                                    // Copy returndata to memory; overwrite\\r\\n                                    // existing memory.\\r\\n                                    returndatacopy(0, 0, returndatasize())\\r\\n\\r\\n                                    // Revert, specifying memory region with\\r\\n                                    // copied returndata.\\r\\n                                    revert(0, returndatasize())\\r\\n                                }\\r\\n                            }\\r\\n\\r\\n                            // Otherwise revert with a generic error message.\\r\\n                            mstore(\\r\\n                                TokenTransferGenericFailure_error_sig_ptr,\\r\\n                                TokenTransferGenericFailure_error_signature\\r\\n                            )\\r\\n                            mstore(\\r\\n                                TokenTransferGenericFailure_error_token_ptr,\\r\\n                                token\\r\\n                            )\\r\\n                            mstore(\\r\\n                                TokenTransferGenericFailure_error_from_ptr,\\r\\n                                from\\r\\n                            )\\r\\n                            mstore(TokenTransferGenericFailure_error_to_ptr, to)\\r\\n                            mstore(TokenTransferGenericFailure_error_id_ptr, 0)\\r\\n                            mstore(\\r\\n                                TokenTransferGenericFailure_error_amount_ptr,\\r\\n                                amount\\r\\n                            )\\r\\n                            revert(\\r\\n                                TokenTransferGenericFailure_error_sig_ptr,\\r\\n                                TokenTransferGenericFailure_error_length\\r\\n                            )\\r\\n                        }\\r\\n\\r\\n                        // Otherwise revert with a message about the token\\r\\n                        // returning false or non-compliant return values.\\r\\n                        mstore(\\r\\n                            BadReturnValueFromERC20OnTransfer_error_sig_ptr,\\r\\n                            BadReturnValueFromERC20OnTransfer_error_signature\\r\\n                        )\\r\\n                        mstore(\\r\\n                            BadReturnValueFromERC20OnTransfer_error_token_ptr,\\r\\n                            token\\r\\n                        )\\r\\n                        mstore(\\r\\n                            BadReturnValueFromERC20OnTransfer_error_from_ptr,\\r\\n                            from\\r\\n                        )\\r\\n                        mstore(\\r\\n                            BadReturnValueFromERC20OnTransfer_error_to_ptr,\\r\\n                            to\\r\\n                        )\\r\\n                        mstore(\\r\\n                            BadReturnValueFromERC20OnTransfer_error_amount_ptr,\\r\\n                            amount\\r\\n                        )\\r\\n                        revert(\\r\\n                            BadReturnValueFromERC20OnTransfer_error_sig_ptr,\\r\\n                            BadReturnValueFromERC20OnTransfer_error_length\\r\\n                        )\\r\\n                    }\\r\\n\\r\\n                    // Otherwise, revert with error about token not having code:\\r\\n                    mstore(NoContract_error_sig_ptr, NoContract_error_signature)\\r\\n                    mstore(NoContract_error_token_ptr, token)\\r\\n                    revert(NoContract_error_sig_ptr, NoContract_error_length)\\r\\n                }\\r\\n\\r\\n                // Otherwise, the token just returned no data despite the call\\r\\n                // having succeeded; no need to optimize for this as it's not\\r\\n                // technically ERC20 compliant.\\r\\n            }\\r\\n\\r\\n            // Restore the original free memory pointer.\\r\\n            mstore(FreeMemoryPointerSlot, memPointer)\\r\\n\\r\\n            // Restore the zero slot to zero.\\r\\n            mstore(ZeroSlot, 0)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to transfer an ERC721 token from a given\\r\\n     *      originator to a given recipient. Sufficient approvals must be set on\\r\\n     *      the contract performing the transfer. Note that this function does\\r\\n     *      not check whether the receiver can accept the ERC721 token (i.e. it\\r\\n     *      does not use `safeTransferFrom`).\\r\\n     *\\r\\n     * @param token      The ERC721 token to transfer.\\r\\n     * @param from       The originator of the transfer.\\r\\n     * @param to         The recipient of the transfer.\\r\\n     * @param identifier The tokenId to transfer.\\r\\n     */\\r\\n    function _performERC721Transfer(\\r\\n        address token,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 identifier\\r\\n    ) internal {\\r\\n        // Utilize assembly to perform an optimized ERC721 token transfer.\\r\\n        assembly {\\r\\n            // If the token has no code, revert.\\r\\n            if iszero(extcodesize(token)) {\\r\\n                mstore(NoContract_error_sig_ptr, NoContract_error_signature)\\r\\n                mstore(NoContract_error_token_ptr, token)\\r\\n                revert(NoContract_error_sig_ptr, NoContract_error_length)\\r\\n            }\\r\\n\\r\\n            // The free memory pointer memory slot will be used when populating\\r\\n            // call data for the transfer; read the value and restore it later.\\r\\n            let memPointer := mload(FreeMemoryPointerSlot)\\r\\n\\r\\n            // Write call data to memory starting with function selector.\\r\\n            mstore(ERC721_transferFrom_sig_ptr, ERC721_transferFrom_signature)\\r\\n            mstore(ERC721_transferFrom_from_ptr, from)\\r\\n            mstore(ERC721_transferFrom_to_ptr, to)\\r\\n            mstore(ERC721_transferFrom_id_ptr, identifier)\\r\\n\\r\\n            // Perform the call, ignoring return data.\\r\\n            let success := call(\\r\\n                gas(),\\r\\n                token,\\r\\n                0,\\r\\n                ERC721_transferFrom_sig_ptr,\\r\\n                ERC721_transferFrom_length,\\r\\n                0,\\r\\n                0\\r\\n            )\\r\\n\\r\\n            // If the transfer reverted:\\r\\n            if iszero(success) {\\r\\n                // If it returned a message, bubble it up as long as sufficient\\r\\n                // gas remains to do so:\\r\\n                if returndatasize() {\\r\\n                    // Ensure that sufficient gas is available to copy\\r\\n                    // returndata while expanding memory where necessary. Start\\r\\n                    // by computing word size of returndata & allocated memory.\\r\\n                    // Round up to the nearest full word.\\r\\n                    let returnDataWords := div(\\r\\n                        add(returndatasize(), AlmostOneWord),\\r\\n                        OneWord\\r\\n                    )\\r\\n\\r\\n                    // Note: use the free memory pointer in place of msize() to\\r\\n                    // work around a Yul warning that prevents accessing msize\\r\\n                    // directly when the IR pipeline is activated.\\r\\n                    let msizeWords := div(memPointer, OneWord)\\r\\n\\r\\n                    // Next, compute the cost of the returndatacopy.\\r\\n                    let cost := mul(CostPerWord, returnDataWords)\\r\\n\\r\\n                    // Then, compute cost of new memory allocation.\\r\\n                    if gt(returnDataWords, msizeWords) {\\r\\n                        cost := add(\\r\\n                            cost,\\r\\n                            add(\\r\\n                                mul(\\r\\n                                    sub(returnDataWords, msizeWords),\\r\\n                                    CostPerWord\\r\\n                                ),\\r\\n                                div(\\r\\n                                    sub(\\r\\n                                        mul(returnDataWords, returnDataWords),\\r\\n                                        mul(msizeWords, msizeWords)\\r\\n                                    ),\\r\\n                                    MemoryExpansionCoefficient\\r\\n                                )\\r\\n                            )\\r\\n                        )\\r\\n                    }\\r\\n\\r\\n                    // Finally, add a small constant and compare to gas\\r\\n                    // remaining; bubble up the revert data if enough gas is\\r\\n                    // still available.\\r\\n                    if lt(add(cost, ExtraGasBuffer), gas()) {\\r\\n                        // Copy returndata to memory; overwrite existing memory.\\r\\n                        returndatacopy(0, 0, returndatasize())\\r\\n\\r\\n                        // Revert, giving memory region with copied returndata.\\r\\n                        revert(0, returndatasize())\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                // Otherwise revert with a generic error message.\\r\\n                mstore(\\r\\n                    TokenTransferGenericFailure_error_sig_ptr,\\r\\n                    TokenTransferGenericFailure_error_signature\\r\\n                )\\r\\n                mstore(TokenTransferGenericFailure_error_token_ptr, token)\\r\\n                mstore(TokenTransferGenericFailure_error_from_ptr, from)\\r\\n                mstore(TokenTransferGenericFailure_error_to_ptr, to)\\r\\n                mstore(TokenTransferGenericFailure_error_id_ptr, identifier)\\r\\n                mstore(TokenTransferGenericFailure_error_amount_ptr, 1)\\r\\n                revert(\\r\\n                    TokenTransferGenericFailure_error_sig_ptr,\\r\\n                    TokenTransferGenericFailure_error_length\\r\\n                )\\r\\n            }\\r\\n\\r\\n            // Restore the original free memory pointer.\\r\\n            mstore(FreeMemoryPointerSlot, memPointer)\\r\\n\\r\\n            // Restore the zero slot to zero.\\r\\n            mstore(ZeroSlot, 0)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to transfer ERC1155 tokens from a given\\r\\n     *      originator to a given recipient. Sufficient approvals must be set on\\r\\n     *      the contract performing the transfer and contract recipients must\\r\\n     *      implement the ERC1155TokenReceiver interface to indicate that they\\r\\n     *      are willing to accept the transfer.\\r\\n     *\\r\\n     * @param token      The ERC1155 token to transfer.\\r\\n     * @param from       The originator of the transfer.\\r\\n     * @param to         The recipient of the transfer.\\r\\n     * @param identifier The id to transfer.\\r\\n     * @param amount     The amount to transfer.\\r\\n     */\\r\\n    function _performERC1155Transfer(\\r\\n        address token,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 identifier,\\r\\n        uint256 amount\\r\\n    ) internal {\\r\\n        // Utilize assembly to perform an optimized ERC1155 token transfer.\\r\\n        assembly {\\r\\n            // If the token has no code, revert.\\r\\n            if iszero(extcodesize(token)) {\\r\\n                mstore(NoContract_error_sig_ptr, NoContract_error_signature)\\r\\n                mstore(NoContract_error_token_ptr, token)\\r\\n                revert(NoContract_error_sig_ptr, NoContract_error_length)\\r\\n            }\\r\\n\\r\\n            // The following memory slots will be used when populating call data\\r\\n            // for the transfer; read the values and restore them later.\\r\\n            let memPointer := mload(FreeMemoryPointerSlot)\\r\\n            let slot0x80 := mload(Slot0x80)\\r\\n            let slot0xA0 := mload(Slot0xA0)\\r\\n            let slot0xC0 := mload(Slot0xC0)\\r\\n\\r\\n            // Write call data into memory, beginning with function selector.\\r\\n            mstore(\\r\\n                ERC1155_safeTransferFrom_sig_ptr,\\r\\n                ERC1155_safeTransferFrom_signature\\r\\n            )\\r\\n            mstore(ERC1155_safeTransferFrom_from_ptr, from)\\r\\n            mstore(ERC1155_safeTransferFrom_to_ptr, to)\\r\\n            mstore(ERC1155_safeTransferFrom_id_ptr, identifier)\\r\\n            mstore(ERC1155_safeTransferFrom_amount_ptr, amount)\\r\\n            mstore(\\r\\n                ERC1155_safeTransferFrom_data_offset_ptr,\\r\\n                ERC1155_safeTransferFrom_data_length_offset\\r\\n            )\\r\\n            mstore(ERC1155_safeTransferFrom_data_length_ptr, 0)\\r\\n\\r\\n            // Perform the call, ignoring return data.\\r\\n            let success := call(\\r\\n                gas(),\\r\\n                token,\\r\\n                0,\\r\\n                ERC1155_safeTransferFrom_sig_ptr,\\r\\n                ERC1155_safeTransferFrom_length,\\r\\n                0,\\r\\n                0\\r\\n            )\\r\\n\\r\\n            // If the transfer reverted:\\r\\n            if iszero(success) {\\r\\n                // If it returned a message, bubble it up as long as sufficient\\r\\n                // gas remains to do so:\\r\\n                if returndatasize() {\\r\\n                    // Ensure that sufficient gas is available to copy\\r\\n                    // returndata while expanding memory where necessary. Start\\r\\n                    // by computing word size of returndata & allocated memory.\\r\\n                    // Round up to the nearest full word.\\r\\n                    let returnDataWords := div(\\r\\n                        add(returndatasize(), AlmostOneWord),\\r\\n                        OneWord\\r\\n                    )\\r\\n\\r\\n                    // Note: use the free memory pointer in place of msize() to\\r\\n                    // work around a Yul warning that prevents accessing msize\\r\\n                    // directly when the IR pipeline is activated.\\r\\n                    let msizeWords := div(memPointer, OneWord)\\r\\n\\r\\n                    // Next, compute the cost of the returndatacopy.\\r\\n                    let cost := mul(CostPerWord, returnDataWords)\\r\\n\\r\\n                    // Then, compute cost of new memory allocation.\\r\\n                    if gt(returnDataWords, msizeWords) {\\r\\n                        cost := add(\\r\\n                            cost,\\r\\n                            add(\\r\\n                                mul(\\r\\n                                    sub(returnDataWords, msizeWords),\\r\\n                                    CostPerWord\\r\\n                                ),\\r\\n                                div(\\r\\n                                    sub(\\r\\n                                        mul(returnDataWords, returnDataWords),\\r\\n                                        mul(msizeWords, msizeWords)\\r\\n                                    ),\\r\\n                                    MemoryExpansionCoefficient\\r\\n                                )\\r\\n                            )\\r\\n                        )\\r\\n                    }\\r\\n\\r\\n                    // Finally, add a small constant and compare to gas\\r\\n                    // remaining; bubble up the revert data if enough gas is\\r\\n                    // still available.\\r\\n                    if lt(add(cost, ExtraGasBuffer), gas()) {\\r\\n                        // Copy returndata to memory; overwrite existing memory.\\r\\n                        returndatacopy(0, 0, returndatasize())\\r\\n\\r\\n                        // Revert, giving memory region with copied returndata.\\r\\n                        revert(0, returndatasize())\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                // Otherwise revert with a generic error message.\\r\\n                mstore(\\r\\n                    TokenTransferGenericFailure_error_sig_ptr,\\r\\n                    TokenTransferGenericFailure_error_signature\\r\\n                )\\r\\n                mstore(TokenTransferGenericFailure_error_token_ptr, token)\\r\\n                mstore(TokenTransferGenericFailure_error_from_ptr, from)\\r\\n                mstore(TokenTransferGenericFailure_error_to_ptr, to)\\r\\n                mstore(TokenTransferGenericFailure_error_id_ptr, identifier)\\r\\n                mstore(TokenTransferGenericFailure_error_amount_ptr, amount)\\r\\n                revert(\\r\\n                    TokenTransferGenericFailure_error_sig_ptr,\\r\\n                    TokenTransferGenericFailure_error_length\\r\\n                )\\r\\n            }\\r\\n\\r\\n            mstore(Slot0x80, slot0x80) // Restore slot 0x80.\\r\\n            mstore(Slot0xA0, slot0xA0) // Restore slot 0xA0.\\r\\n            mstore(Slot0xC0, slot0xC0) // Restore slot 0xC0.\\r\\n\\r\\n            // Restore the original free memory pointer.\\r\\n            mstore(FreeMemoryPointerSlot, memPointer)\\r\\n\\r\\n            // Restore the zero slot to zero.\\r\\n            mstore(ZeroSlot, 0)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to transfer ERC1155 tokens from a given\\r\\n     *      originator to a given recipient. Sufficient approvals must be set on\\r\\n     *      the contract performing the transfer and contract recipients must\\r\\n     *      implement the ERC1155TokenReceiver interface to indicate that they\\r\\n     *      are willing to accept the transfer. NOTE: this function is not\\r\\n     *      memory-safe; it will overwrite existing memory, restore the free\\r\\n     *      memory pointer to the default value, and overwrite the zero slot.\\r\\n     *      This function should only be called once memory is no longer\\r\\n     *      required and when uninitialized arrays are not utilized, and memory\\r\\n     *      should be considered fully corrupted (aside from the existence of a\\r\\n     *      default-value free memory pointer) after calling this function.\\r\\n     *\\r\\n     * @param batchTransfers The group of 1155 batch transfers to perform.\\r\\n     */\\r\\n    function _performERC1155BatchTransfers(\\r\\n        ConduitBatch1155Transfer[] calldata batchTransfers\\r\\n    ) internal {\\r\\n        // Utilize assembly to perform optimized batch 1155 transfers.\\r\\n        assembly {\\r\\n            let len := batchTransfers.length\\r\\n            // Pointer to first head in the array, which is offset to the struct\\r\\n            // at each index. This gets incremented after each loop to avoid\\r\\n            // multiplying by 32 to get the offset for each element.\\r\\n            let nextElementHeadPtr := batchTransfers.offset\\r\\n\\r\\n            // Pointer to beginning of the head of the array. This is the\\r\\n            // reference position each offset references. It's held static to\\r\\n            // let each loop calculate the data position for an element.\\r\\n            let arrayHeadPtr := nextElementHeadPtr\\r\\n\\r\\n            // Write the function selector, which will be reused for each call:\\r\\n            // safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)\\r\\n            mstore(\\r\\n                ConduitBatch1155Transfer_from_offset,\\r\\n                ERC1155_safeBatchTransferFrom_signature\\r\\n            )\\r\\n\\r\\n            // Iterate over each batch transfer.\\r\\n            for {\\r\\n                let i := 0\\r\\n            } lt(i, len) {\\r\\n                i := add(i, 1)\\r\\n            } {\\r\\n                // Read the offset to the beginning of the element and add\\r\\n                // it to pointer to the beginning of the array head to get\\r\\n                // the absolute position of the element in calldata.\\r\\n                let elementPtr := add(\\r\\n                    arrayHeadPtr,\\r\\n                    calldataload(nextElementHeadPtr)\\r\\n                )\\r\\n\\r\\n                // Retrieve the token from calldata.\\r\\n                let token := calldataload(elementPtr)\\r\\n\\r\\n                // If the token has no code, revert.\\r\\n                if iszero(extcodesize(token)) {\\r\\n                    mstore(NoContract_error_sig_ptr, NoContract_error_signature)\\r\\n                    mstore(NoContract_error_token_ptr, token)\\r\\n                    revert(NoContract_error_sig_ptr, NoContract_error_length)\\r\\n                }\\r\\n\\r\\n                // Get the total number of supplied ids.\\r\\n                let idsLength := calldataload(\\r\\n                    add(elementPtr, ConduitBatch1155Transfer_ids_length_offset)\\r\\n                )\\r\\n\\r\\n                // Determine the expected offset for the amounts array.\\r\\n                let expectedAmountsOffset := add(\\r\\n                    ConduitBatch1155Transfer_amounts_length_baseOffset,\\r\\n                    mul(idsLength, OneWord)\\r\\n                )\\r\\n\\r\\n                // Validate struct encoding.\\r\\n                let invalidEncoding := iszero(\\r\\n                    and(\\r\\n                        // ids.length == amounts.length\\r\\n                        eq(\\r\\n                            idsLength,\\r\\n                            calldataload(add(elementPtr, expectedAmountsOffset))\\r\\n                        ),\\r\\n                        and(\\r\\n                            // ids_offset == 0xa0\\r\\n                            eq(\\r\\n                                calldataload(\\r\\n                                    add(\\r\\n                                        elementPtr,\\r\\n                                        ConduitBatch1155Transfer_ids_head_offset\\r\\n                                    )\\r\\n                                ),\\r\\n                                ConduitBatch1155Transfer_ids_length_offset\\r\\n                            ),\\r\\n                            // amounts_offset == 0xc0 + ids.length*32\\r\\n                            eq(\\r\\n                                calldataload(\\r\\n                                    add(\\r\\n                                        elementPtr,\\r\\n                                        ConduitBatchTransfer_amounts_head_offset\\r\\n                                    )\\r\\n                                ),\\r\\n                                expectedAmountsOffset\\r\\n                            )\\r\\n                        )\\r\\n                    )\\r\\n                )\\r\\n\\r\\n                // Revert with an error if the encoding is not valid.\\r\\n                if invalidEncoding {\\r\\n                    mstore(\\r\\n                        Invalid1155BatchTransferEncoding_ptr,\\r\\n                        Invalid1155BatchTransferEncoding_selector\\r\\n                    )\\r\\n                    revert(\\r\\n                        Invalid1155BatchTransferEncoding_ptr,\\r\\n                        Invalid1155BatchTransferEncoding_length\\r\\n                    )\\r\\n                }\\r\\n\\r\\n                // Update the offset position for the next loop\\r\\n                nextElementHeadPtr := add(nextElementHeadPtr, OneWord)\\r\\n\\r\\n                // Copy the first section of calldata (before dynamic values).\\r\\n                calldatacopy(\\r\\n                    BatchTransfer1155Params_ptr,\\r\\n                    add(elementPtr, ConduitBatch1155Transfer_from_offset),\\r\\n                    ConduitBatch1155Transfer_usable_head_size\\r\\n                )\\r\\n\\r\\n                // Determine size of calldata required for ids and amounts. Note\\r\\n                // that the size includes both lengths as well as the data.\\r\\n                let idsAndAmountsSize := add(TwoWords, mul(idsLength, TwoWords))\\r\\n\\r\\n                // Update the offset for the data array in memory.\\r\\n                mstore(\\r\\n                    BatchTransfer1155Params_data_head_ptr,\\r\\n                    add(\\r\\n                        BatchTransfer1155Params_ids_length_offset,\\r\\n                        idsAndAmountsSize\\r\\n                    )\\r\\n                )\\r\\n\\r\\n                // Set the length of the data array in memory to zero.\\r\\n                mstore(\\r\\n                    add(\\r\\n                        BatchTransfer1155Params_data_length_basePtr,\\r\\n                        idsAndAmountsSize\\r\\n                    ),\\r\\n                    0\\r\\n                )\\r\\n\\r\\n                // Determine the total calldata size for the call to transfer.\\r\\n                let transferDataSize := add(\\r\\n                    BatchTransfer1155Params_calldata_baseSize,\\r\\n                    idsAndAmountsSize\\r\\n                )\\r\\n\\r\\n                // Copy second section of calldata (including dynamic values).\\r\\n                calldatacopy(\\r\\n                    BatchTransfer1155Params_ids_length_ptr,\\r\\n                    add(elementPtr, ConduitBatch1155Transfer_ids_length_offset),\\r\\n                    idsAndAmountsSize\\r\\n                )\\r\\n\\r\\n                // Perform the call to transfer 1155 tokens.\\r\\n                let success := call(\\r\\n                    gas(),\\r\\n                    token,\\r\\n                    0,\\r\\n                    ConduitBatch1155Transfer_from_offset, // Data portion start.\\r\\n                    transferDataSize, // Location of the length of callData.\\r\\n                    0,\\r\\n                    0\\r\\n                )\\r\\n\\r\\n                // If the transfer reverted:\\r\\n                if iszero(success) {\\r\\n                    // If it returned a message, bubble it up as long as\\r\\n                    // sufficient gas remains to do so:\\r\\n                    if returndatasize() {\\r\\n                        // Ensure that sufficient gas is available to copy\\r\\n                        // returndata while expanding memory where necessary.\\r\\n                        // Start by computing word size of returndata and\\r\\n                        // allocated memory. Round up to the nearest full word.\\r\\n                        let returnDataWords := div(\\r\\n                            add(returndatasize(), AlmostOneWord),\\r\\n                            OneWord\\r\\n                        )\\r\\n\\r\\n                        // Note: use transferDataSize in place of msize() to\\r\\n                        // work around a Yul warning that prevents accessing\\r\\n                        // msize directly when the IR pipeline is activated.\\r\\n                        // The free memory pointer is not used here because\\r\\n                        // this function does almost all memory management\\r\\n                        // manually and does not update it, and transferDataSize\\r\\n                        // should be the largest memory value used (unless a\\r\\n                        // previous batch was larger).\\r\\n                        let msizeWords := div(transferDataSize, OneWord)\\r\\n\\r\\n                        // Next, compute the cost of the returndatacopy.\\r\\n                        let cost := mul(CostPerWord, returnDataWords)\\r\\n\\r\\n                        // Then, compute cost of new memory allocation.\\r\\n                        if gt(returnDataWords, msizeWords) {\\r\\n                            cost := add(\\r\\n                                cost,\\r\\n                                add(\\r\\n                                    mul(\\r\\n                                        sub(returnDataWords, msizeWords),\\r\\n                                        CostPerWord\\r\\n                                    ),\\r\\n                                    div(\\r\\n                                        sub(\\r\\n                                            mul(\\r\\n                                                returnDataWords,\\r\\n                                                returnDataWords\\r\\n                                            ),\\r\\n                                            mul(msizeWords, msizeWords)\\r\\n                                        ),\\r\\n                                        MemoryExpansionCoefficient\\r\\n                                    )\\r\\n                                )\\r\\n                            )\\r\\n                        }\\r\\n\\r\\n                        // Finally, add a small constant and compare to gas\\r\\n                        // remaining; bubble up the revert data if enough gas is\\r\\n                        // still available.\\r\\n                        if lt(add(cost, ExtraGasBuffer), gas()) {\\r\\n                            // Copy returndata to memory; overwrite existing.\\r\\n                            returndatacopy(0, 0, returndatasize())\\r\\n\\r\\n                            // Revert with memory region containing returndata.\\r\\n                            revert(0, returndatasize())\\r\\n                        }\\r\\n                    }\\r\\n\\r\\n                    // Set the error signature.\\r\\n                    mstore(\\r\\n                        0,\\r\\n                        ERC1155BatchTransferGenericFailure_error_signature\\r\\n                    )\\r\\n\\r\\n                    // Write the token.\\r\\n                    mstore(ERC1155BatchTransferGenericFailure_token_ptr, token)\\r\\n\\r\\n                    // Increase the offset to ids by 32.\\r\\n                    mstore(\\r\\n                        BatchTransfer1155Params_ids_head_ptr,\\r\\n                        ERC1155BatchTransferGenericFailure_ids_offset\\r\\n                    )\\r\\n\\r\\n                    // Increase the offset to amounts by 32.\\r\\n                    mstore(\\r\\n                        BatchTransfer1155Params_amounts_head_ptr,\\r\\n                        add(\\r\\n                            OneWord,\\r\\n                            mload(BatchTransfer1155Params_amounts_head_ptr)\\r\\n                        )\\r\\n                    )\\r\\n\\r\\n                    // Return modified region. The total size stays the same as\\r\\n                    // `token` uses the same number of bytes as `data.length`.\\r\\n                    revert(0, transferDataSize)\\r\\n                }\\r\\n            }\\r\\n\\r\\n            // Reset the free memory pointer to the default value; memory must\\r\\n            // be assumed to be dirtied and not reused from this point forward.\\r\\n            // Also note that the zero slot is not reset to zero, meaning empty\\r\\n            // arrays cannot be safely created or utilized until it is restored.\\r\\n            mstore(FreeMemoryPointerSlot, DefaultFreeMemoryPointer)\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x88356eb85b2fb4f64ca2ce5fa37f63fba2f7c3483514efa960732bc109d465a4\",\"license\":\"MIT\"},\"contracts/lib/TokenTransferrerConstants.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.7;\\r\\n\\r\\n/*\\r\\n * -------------------------- Disambiguation & Other Notes ---------------------\\r\\n *    - The term \\\"head\\\" is used as it is in the documentation for ABI encoding,\\r\\n *      but only in reference to dynamic types, i.e. it always refers to the\\r\\n *      offset or pointer to the body of a dynamic type. In calldata, the head\\r\\n *      is always an offset (relative to the parent object), while in memory,\\r\\n *      the head is always the pointer to the body. More information found here:\\r\\n *      https://docs.soliditylang.org/en/v0.8.14/abi-spec.html#argument-encoding\\r\\n *        - Note that the length of an array is separate from and precedes the\\r\\n *          head of the array.\\r\\n *\\r\\n *    - The term \\\"body\\\" is used in place of the term \\\"head\\\" used in the ABI\\r\\n *      documentation. It refers to the start of the data for a dynamic type,\\r\\n *      e.g. the first word of a struct or the first word of the first element\\r\\n *      in an array.\\r\\n *\\r\\n *    - The term \\\"pointer\\\" is used to describe the absolute position of a value\\r\\n *      and never an offset relative to another value.\\r\\n *        - The suffix \\\"_ptr\\\" refers to a memory pointer.\\r\\n *        - The suffix \\\"_cdPtr\\\" refers to a calldata pointer.\\r\\n *\\r\\n *    - The term \\\"offset\\\" is used to describe the position of a value relative\\r\\n *      to some parent value. For example, OrderParameters_conduit_offset is the\\r\\n *      offset to the \\\"conduit\\\" value in the OrderParameters struct relative to\\r\\n *      the start of the body.\\r\\n *        - Note: Offsets are used to derive pointers.\\r\\n *\\r\\n *    - Some structs have pointers defined for all of their fields in this file.\\r\\n *      Lines which are commented out are fields that are not used in the\\r\\n *      codebase but have been left in for readability.\\r\\n */\\r\\n\\r\\nuint256 constant AlmostOneWord = 0x1f;\\r\\nuint256 constant OneWord = 0x20;\\r\\nuint256 constant TwoWords = 0x40;\\r\\nuint256 constant ThreeWords = 0x60;\\r\\n\\r\\nuint256 constant FreeMemoryPointerSlot = 0x40;\\r\\nuint256 constant ZeroSlot = 0x60;\\r\\nuint256 constant DefaultFreeMemoryPointer = 0x80;\\r\\n\\r\\nuint256 constant Slot0x80 = 0x80;\\r\\nuint256 constant Slot0xA0 = 0xa0;\\r\\nuint256 constant Slot0xC0 = 0xc0;\\r\\n\\r\\n// abi.encodeWithSignature(\\\"transferFrom(address,address,uint256)\\\")\\r\\nuint256 constant ERC20_transferFrom_signature = (\\r\\n    0x23b872dd00000000000000000000000000000000000000000000000000000000\\r\\n);\\r\\nuint256 constant ERC20_transferFrom_sig_ptr = 0x0;\\r\\nuint256 constant ERC20_transferFrom_from_ptr = 0x04;\\r\\nuint256 constant ERC20_transferFrom_to_ptr = 0x24;\\r\\nuint256 constant ERC20_transferFrom_amount_ptr = 0x44;\\r\\nuint256 constant ERC20_transferFrom_length = 0x64; // 4 + 32 * 3 == 100\\r\\n\\r\\n// abi.encodeWithSignature(\\r\\n//     \\\"safeTransferFrom(address,address,uint256,uint256,bytes)\\\"\\r\\n// )\\r\\nuint256 constant ERC1155_safeTransferFrom_signature = (\\r\\n    0xf242432a00000000000000000000000000000000000000000000000000000000\\r\\n);\\r\\nuint256 constant ERC1155_safeTransferFrom_sig_ptr = 0x0;\\r\\nuint256 constant ERC1155_safeTransferFrom_from_ptr = 0x04;\\r\\nuint256 constant ERC1155_safeTransferFrom_to_ptr = 0x24;\\r\\nuint256 constant ERC1155_safeTransferFrom_id_ptr = 0x44;\\r\\nuint256 constant ERC1155_safeTransferFrom_amount_ptr = 0x64;\\r\\nuint256 constant ERC1155_safeTransferFrom_data_offset_ptr = 0x84;\\r\\nuint256 constant ERC1155_safeTransferFrom_data_length_ptr = 0xa4;\\r\\nuint256 constant ERC1155_safeTransferFrom_length = 0xc4; // 4 + 32 * 6 == 196\\r\\nuint256 constant ERC1155_safeTransferFrom_data_length_offset = 0xa0;\\r\\n\\r\\n// abi.encodeWithSignature(\\r\\n//     \\\"safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)\\\"\\r\\n// )\\r\\nuint256 constant ERC1155_safeBatchTransferFrom_signature = (\\r\\n    0x2eb2c2d600000000000000000000000000000000000000000000000000000000\\r\\n);\\r\\n\\r\\nbytes4 constant ERC1155_safeBatchTransferFrom_selector = bytes4(\\r\\n    bytes32(ERC1155_safeBatchTransferFrom_signature)\\r\\n);\\r\\n\\r\\nuint256 constant ERC721_transferFrom_signature = ERC20_transferFrom_signature;\\r\\nuint256 constant ERC721_transferFrom_sig_ptr = 0x0;\\r\\nuint256 constant ERC721_transferFrom_from_ptr = 0x04;\\r\\nuint256 constant ERC721_transferFrom_to_ptr = 0x24;\\r\\nuint256 constant ERC721_transferFrom_id_ptr = 0x44;\\r\\nuint256 constant ERC721_transferFrom_length = 0x64; // 4 + 32 * 3 == 100\\r\\n\\r\\n// abi.encodeWithSignature(\\\"NoContract(address)\\\")\\r\\nuint256 constant NoContract_error_signature = (\\r\\n    0x5f15d67200000000000000000000000000000000000000000000000000000000\\r\\n);\\r\\nuint256 constant NoContract_error_sig_ptr = 0x0;\\r\\nuint256 constant NoContract_error_token_ptr = 0x4;\\r\\nuint256 constant NoContract_error_length = 0x24; // 4 + 32 == 36\\r\\n\\r\\n// abi.encodeWithSignature(\\r\\n//     \\\"TokenTransferGenericFailure(address,address,address,uint256,uint256)\\\"\\r\\n// )\\r\\nuint256 constant TokenTransferGenericFailure_error_signature = (\\r\\n    0xf486bc8700000000000000000000000000000000000000000000000000000000\\r\\n);\\r\\nuint256 constant TokenTransferGenericFailure_error_sig_ptr = 0x0;\\r\\nuint256 constant TokenTransferGenericFailure_error_token_ptr = 0x4;\\r\\nuint256 constant TokenTransferGenericFailure_error_from_ptr = 0x24;\\r\\nuint256 constant TokenTransferGenericFailure_error_to_ptr = 0x44;\\r\\nuint256 constant TokenTransferGenericFailure_error_id_ptr = 0x64;\\r\\nuint256 constant TokenTransferGenericFailure_error_amount_ptr = 0x84;\\r\\n\\r\\n// 4 + 32 * 5 == 164\\r\\nuint256 constant TokenTransferGenericFailure_error_length = 0xa4;\\r\\n\\r\\n// abi.encodeWithSignature(\\r\\n//     \\\"BadReturnValueFromERC20OnTransfer(address,address,address,uint256)\\\"\\r\\n// )\\r\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_signature = (\\r\\n    0x9889192300000000000000000000000000000000000000000000000000000000\\r\\n);\\r\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_sig_ptr = 0x0;\\r\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_token_ptr = 0x4;\\r\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_from_ptr = 0x24;\\r\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_to_ptr = 0x44;\\r\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_amount_ptr = 0x64;\\r\\n\\r\\n// 4 + 32 * 4 == 132\\r\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_length = 0x84;\\r\\n\\r\\nuint256 constant ExtraGasBuffer = 0x20;\\r\\nuint256 constant CostPerWord = 3;\\r\\nuint256 constant MemoryExpansionCoefficient = 0x200;\\r\\n\\r\\n// Values are offset by 32 bytes in order to write the token to the beginning\\r\\n// in the event of a revert\\r\\nuint256 constant BatchTransfer1155Params_ptr = 0x24;\\r\\nuint256 constant BatchTransfer1155Params_ids_head_ptr = 0x64;\\r\\nuint256 constant BatchTransfer1155Params_amounts_head_ptr = 0x84;\\r\\nuint256 constant BatchTransfer1155Params_data_head_ptr = 0xa4;\\r\\nuint256 constant BatchTransfer1155Params_data_length_basePtr = 0xc4;\\r\\nuint256 constant BatchTransfer1155Params_calldata_baseSize = 0xc4;\\r\\n\\r\\nuint256 constant BatchTransfer1155Params_ids_length_ptr = 0xc4;\\r\\n\\r\\nuint256 constant BatchTransfer1155Params_ids_length_offset = 0xa0;\\r\\nuint256 constant BatchTransfer1155Params_amounts_length_baseOffset = 0xc0;\\r\\nuint256 constant BatchTransfer1155Params_data_length_baseOffset = 0xe0;\\r\\n\\r\\nuint256 constant ConduitBatch1155Transfer_usable_head_size = 0x80;\\r\\n\\r\\nuint256 constant ConduitBatch1155Transfer_from_offset = 0x20;\\r\\nuint256 constant ConduitBatch1155Transfer_ids_head_offset = 0x60;\\r\\nuint256 constant ConduitBatch1155Transfer_amounts_head_offset = 0x80;\\r\\nuint256 constant ConduitBatch1155Transfer_ids_length_offset = 0xa0;\\r\\nuint256 constant ConduitBatch1155Transfer_amounts_length_baseOffset = 0xc0;\\r\\nuint256 constant ConduitBatch1155Transfer_calldata_baseSize = 0xc0;\\r\\n\\r\\n// Note: abbreviated version of above constant to adhere to line length limit.\\r\\nuint256 constant ConduitBatchTransfer_amounts_head_offset = 0x80;\\r\\n\\r\\nuint256 constant Invalid1155BatchTransferEncoding_ptr = 0x00;\\r\\nuint256 constant Invalid1155BatchTransferEncoding_length = 0x04;\\r\\nuint256 constant Invalid1155BatchTransferEncoding_selector = (\\r\\n    0xeba2084c00000000000000000000000000000000000000000000000000000000\\r\\n);\\r\\n\\r\\nuint256 constant ERC1155BatchTransferGenericFailure_error_signature = (\\r\\n    0xafc445e200000000000000000000000000000000000000000000000000000000\\r\\n);\\r\\nuint256 constant ERC1155BatchTransferGenericFailure_token_ptr = 0x04;\\r\\nuint256 constant ERC1155BatchTransferGenericFailure_ids_offset = 0xc0;\\r\\n\",\"keccak256\":\"0xd454a315133d009b29c940d91ff51341e82c6f03242af8693e88d0a0c5f4592a\",\"license\":\"MIT\"},\"contracts/lib/Verifiers.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.13;\\r\\n\\r\\nimport { OrderStatus } from \\\"./ConsiderationStructs.sol\\\";\\r\\n\\r\\nimport { Assertions } from \\\"./Assertions.sol\\\";\\r\\n\\r\\nimport { SignatureVerification } from \\\"./SignatureVerification.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Verifiers\\r\\n * @author 0age\\r\\n * @notice Verifiers contains functions for performing verifications.\\r\\n */\\r\\ncontract Verifiers is Assertions, SignatureVerification {\\r\\n    /**\\r\\n     * @dev Derive and set hashes, reference chainId, and associated domain\\r\\n     *      separator during deployment.\\r\\n     *\\r\\n     * @param conduitController A contract that deploys conduits, or proxies\\r\\n     *                          that may optionally be used to transfer approved\\r\\n     *                          ERC20/721/1155 tokens.\\r\\n     */\\r\\n    constructor(address conduitController) Assertions(conduitController) {}\\r\\n\\r\\n    /**\\r\\n     * @dev Internal view function to ensure that the current time falls within\\r\\n     *      an order's valid timespan.\\r\\n     *\\r\\n     * @param startTime       The time at which the order becomes active.\\r\\n     * @param endTime         The time at which the order becomes inactive.\\r\\n     * @param revertOnInvalid A boolean indicating whether to revert if the\\r\\n     *                        order is not active.\\r\\n     *\\r\\n     * @return valid A boolean indicating whether the order is active.\\r\\n     */\\r\\n    function _verifyTime(\\r\\n        uint256 startTime,\\r\\n        uint256 endTime,\\r\\n        bool revertOnInvalid\\r\\n    ) internal view returns (bool valid) {\\r\\n        // Revert if order's timespan hasn't started yet or has already ended.\\r\\n        if (startTime > block.timestamp || endTime <= block.timestamp) {\\r\\n            // Only revert if revertOnInvalid has been supplied as true.\\r\\n            if (revertOnInvalid) {\\r\\n                revert InvalidTime();\\r\\n            }\\r\\n\\r\\n            // Return false as the order is invalid.\\r\\n            return false;\\r\\n        }\\r\\n\\r\\n        // Return true as the order time is valid.\\r\\n        valid = true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal view function to verify the signature of an order. An\\r\\n     *      ERC-1271 fallback will be attempted if either the signature length\\r\\n     *      is not 32 or 33 bytes or if the recovered signer does not match the\\r\\n     *      supplied offerer. Note that in cases where a 32 or 33 byte signature\\r\\n     *      is supplied, only standard ECDSA signatures that recover to a\\r\\n     *      non-zero address are supported.\\r\\n     *\\r\\n     * @param offerer   The offerer for the order.\\r\\n     * @param orderHash The order hash.\\r\\n     * @param signature A signature from the offerer indicating that the order\\r\\n     *                  has been approved.\\r\\n     */\\r\\n    function _verifySignature(\\r\\n        address offerer,\\r\\n        bytes32 orderHash,\\r\\n        bytes memory signature\\r\\n    ) internal view {\\r\\n        // Skip signature verification if the offerer is the caller.\\r\\n        if (offerer == msg.sender) {\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        // Derive EIP-712 digest using the domain separator and the order hash.\\r\\n        bytes32 digest = _deriveEIP712Digest(_domainSeparator(), orderHash);\\r\\n\\r\\n        // Ensure that the signature for the digest is valid for the offerer.\\r\\n        _assertValidSignature(offerer, digest, signature);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal view function to validate that a given order is fillable\\r\\n     *      and not cancelled based on the order status.\\r\\n     *\\r\\n     * @param orderHash       The order hash.\\r\\n     * @param orderStatus     The status of the order, including whether it has\\r\\n     *                        been cancelled and the fraction filled.\\r\\n     * @param onlyAllowUnused A boolean flag indicating whether partial fills\\r\\n     *                        are supported by the calling function.\\r\\n     * @param revertOnInvalid A boolean indicating whether to revert if the\\r\\n     *                        order has been cancelled or filled beyond the\\r\\n     *                        allowable amount.\\r\\n     *\\r\\n     * @return valid A boolean indicating whether the order is valid.\\r\\n     */\\r\\n    function _verifyOrderStatus(\\r\\n        bytes32 orderHash,\\r\\n        OrderStatus storage orderStatus,\\r\\n        bool onlyAllowUnused,\\r\\n        bool revertOnInvalid\\r\\n    ) internal view returns (bool valid) {\\r\\n        // Ensure that the order has not been cancelled.\\r\\n        if (orderStatus.isCancelled) {\\r\\n            // Only revert if revertOnInvalid has been supplied as true.\\r\\n            if (revertOnInvalid) {\\r\\n                revert OrderIsCancelled(orderHash);\\r\\n            }\\r\\n\\r\\n            // Return false as the order status is invalid.\\r\\n            return false;\\r\\n        }\\r\\n\\r\\n        // Read order status numerator from storage and place on stack.\\r\\n        uint256 orderStatusNumerator = orderStatus.numerator;\\r\\n\\r\\n        // If the order is not entirely unused...\\r\\n        if (orderStatusNumerator != 0) {\\r\\n            // ensure the order has not been partially filled when not allowed.\\r\\n            if (onlyAllowUnused) {\\r\\n                // Always revert on partial fills when onlyAllowUnused is true.\\r\\n                revert OrderPartiallyFilled(orderHash);\\r\\n            }\\r\\n            // Otherwise, ensure that order has not been entirely filled.\\r\\n            else if (orderStatusNumerator >= orderStatus.denominator) {\\r\\n                // Only revert if revertOnInvalid has been supplied as true.\\r\\n                if (revertOnInvalid) {\\r\\n                    revert OrderAlreadyFilled(orderHash);\\r\\n                }\\r\\n\\r\\n                // Return false as the order status is invalid.\\r\\n                return false;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Return true as the order status is valid.\\r\\n        valid = true;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xe83348bbe188e361f227065609e000f26c08a86fab378a3c820d8c5c54abc046\",\"license\":\"MIT\"},\"contracts/lib/ZoneInteraction.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.13;\\r\\n\\r\\nimport { ZoneInterface } from \\\"../interfaces/ZoneInterface.sol\\\";\\r\\n\\r\\nimport { OrderType } from \\\"./ConsiderationEnums.sol\\\";\\r\\n\\r\\n// prettier-ignore\\r\\nimport { AdvancedOrder, CriteriaResolver } from \\\"./ConsiderationStructs.sol\\\";\\r\\n\\r\\nimport \\\"./ConsiderationConstants.sol\\\";\\r\\n\\r\\n// prettier-ignore\\r\\nimport {\\r\\n    ZoneInteractionErrors\\r\\n} from \\\"../interfaces/ZoneInteractionErrors.sol\\\";\\r\\n\\r\\nimport { LowLevelHelpers } from \\\"./LowLevelHelpers.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title ZoneInteraction\\r\\n * @author 0age\\r\\n * @notice ZoneInteraction contains logic related to interacting with zones.\\r\\n */\\r\\ncontract ZoneInteraction is ZoneInteractionErrors, LowLevelHelpers {\\r\\n    /**\\r\\n     * @dev Internal view function to determine if an order has a restricted\\r\\n     *      order type and, if so, to ensure that either the offerer or the zone\\r\\n     *      are the fulfiller or that a staticcall to `isValidOrder` on the zone\\r\\n     *      returns a magic value indicating that the order is currently valid.\\r\\n     *\\r\\n     * @param orderHash The hash of the order.\\r\\n     * @param zoneHash  The hash to provide upon calling the zone.\\r\\n     * @param orderType The type of the order.\\r\\n     * @param offerer   The offerer in question.\\r\\n     * @param zone      The zone in question.\\r\\n     */\\r\\n    function _assertRestrictedBasicOrderValidity(\\r\\n        bytes32 orderHash,\\r\\n        bytes32 zoneHash,\\r\\n        OrderType orderType,\\r\\n        address offerer,\\r\\n        address zone\\r\\n    ) internal view {\\r\\n        // Order type 2-3 require zone or offerer be caller or zone to approve.\\r\\n        if (\\r\\n            uint256(orderType) > 1 &&\\r\\n            msg.sender != zone &&\\r\\n            msg.sender != offerer\\r\\n        ) {\\r\\n            // Perform minimal staticcall to the zone.\\r\\n            _callIsValidOrder(zone, orderHash, offerer, zoneHash);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _callIsValidOrder(\\r\\n        address zone,\\r\\n        bytes32 orderHash,\\r\\n        address offerer,\\r\\n        bytes32 zoneHash\\r\\n    ) internal view {\\r\\n        // Perform minimal staticcall to the zone.\\r\\n        bool success = _staticcall(\\r\\n            zone,\\r\\n            abi.encodeWithSelector(\\r\\n                ZoneInterface.isValidOrder.selector,\\r\\n                orderHash,\\r\\n                msg.sender,\\r\\n                offerer,\\r\\n                zoneHash\\r\\n            )\\r\\n        );\\r\\n\\r\\n        // Ensure call was successful and returned the correct magic value.\\r\\n        _assertIsValidOrderStaticcallSuccess(success, orderHash);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal view function to determine whether an order is a restricted\\r\\n     *      order and, if so, to ensure that it was either submitted by the\\r\\n     *      offerer or the zone for the order, or that the zone returns the\\r\\n     *      expected magic value upon performing a staticcall to `isValidOrder`\\r\\n     *      or `isValidOrderIncludingExtraData` depending on whether the order\\r\\n     *      fulfillment specifies extra data or criteria resolvers.\\r\\n     *\\r\\n     * @param advancedOrder     The advanced order in question.\\r\\n     * @param criteriaResolvers An array where each element contains a reference\\r\\n     *                          to a specific offer or consideration, a token\\r\\n     *                          identifier, and a proof that the supplied token\\r\\n     *                          identifier is contained in the order's merkle\\r\\n     *                          root. Note that a criteria of zero indicates\\r\\n     *                          that any (transferable) token identifier is\\r\\n     *                          valid and that no proof needs to be supplied.\\r\\n     * @param priorOrderHashes  The order hashes of each order supplied prior to\\r\\n     *                          the current order as part of a \\\"match\\\" variety\\r\\n     *                          of order fulfillment (e.g. this array will be\\r\\n     *                          empty for single or \\\"fulfill available\\\").\\r\\n     * @param orderHash         The hash of the order.\\r\\n     * @param zoneHash          The hash to provide upon calling the zone.\\r\\n     * @param orderType         The type of the order.\\r\\n     * @param offerer           The offerer in question.\\r\\n     * @param zone              The zone in question.\\r\\n     */\\r\\n    function _assertRestrictedAdvancedOrderValidity(\\r\\n        AdvancedOrder memory advancedOrder,\\r\\n        CriteriaResolver[] memory criteriaResolvers,\\r\\n        bytes32[] memory priorOrderHashes,\\r\\n        bytes32 orderHash,\\r\\n        bytes32 zoneHash,\\r\\n        OrderType orderType,\\r\\n        address offerer,\\r\\n        address zone\\r\\n    ) internal view {\\r\\n        // Order type 2-3 require zone or offerer be caller or zone to approve.\\r\\n        if (\\r\\n            uint256(orderType) > 1 &&\\r\\n            msg.sender != zone &&\\r\\n            msg.sender != offerer\\r\\n        ) {\\r\\n            // If no extraData or criteria resolvers are supplied...\\r\\n            if (\\r\\n                advancedOrder.extraData.length == 0 &&\\r\\n                criteriaResolvers.length == 0\\r\\n            ) {\\r\\n                // Perform minimal staticcall to the zone.\\r\\n                _callIsValidOrder(zone, orderHash, offerer, zoneHash);\\r\\n            } else {\\r\\n                // Otherwise, extra data or criteria resolvers were supplied; in\\r\\n                // that event, perform a more verbose staticcall to the zone.\\r\\n                bool success = _staticcall(\\r\\n                    zone,\\r\\n                    abi.encodeWithSelector(\\r\\n                        ZoneInterface.isValidOrderIncludingExtraData.selector,\\r\\n                        orderHash,\\r\\n                        msg.sender,\\r\\n                        advancedOrder,\\r\\n                        priorOrderHashes,\\r\\n                        criteriaResolvers\\r\\n                    )\\r\\n                );\\r\\n\\r\\n                // Ensure call was successful and returned correct magic value.\\r\\n                _assertIsValidOrderStaticcallSuccess(success, orderHash);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal view function to ensure that a staticcall to `isValidOrder`\\r\\n     *      or `isValidOrderIncludingExtraData` as part of validating a\\r\\n     *      restricted order that was not submitted by the named offerer or zone\\r\\n     *      was successful and returned the required magic value.\\r\\n     *\\r\\n     * @param success   A boolean indicating the status of the staticcall.\\r\\n     * @param orderHash The order hash of the order in question.\\r\\n     */\\r\\n    function _assertIsValidOrderStaticcallSuccess(\\r\\n        bool success,\\r\\n        bytes32 orderHash\\r\\n    ) internal view {\\r\\n        // If the call failed...\\r\\n        if (!success) {\\r\\n            // Revert and pass reason along if one was returned.\\r\\n            _revertWithReasonIfOneIsReturned();\\r\\n\\r\\n            // Otherwise, revert with a generic error message.\\r\\n            revert InvalidRestrictedOrder(orderHash);\\r\\n        }\\r\\n\\r\\n        // Ensure result was extracted and matches isValidOrder magic value.\\r\\n        if (_doesNotMatchMagic(ZoneInterface.isValidOrder.selector)) {\\r\\n            revert InvalidRestrictedOrder(orderHash);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xc6040d5eef228fee6cf8cec91d75df6e36a3de0d48c2e93766d3b2055f2ef4a4\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x6101c060405234620000b9576200001f6200001962000114565b62000151565b6040516153f6908162000773823960805181612393015260a051816123b9015260c05181612370015260e05181818161162301526121fe0152610100518181816114ef015261224d0152610120518181816116bf015261229b0152610140518161231e01526101605181612344015261018051818181610f8e01528181611f9a015261209b01526101a051818181611fc701526120c80152f35b600080fd5b604081019081106001600160401b03821117620000da57604052565b634e487b7160e01b600052604160045260246000fd5b601f909101601f19168101906001600160401b03821190821017620000da57604052565b62005b6960208138039182604051938492620001318285620000f0565b833981010312620000b957516001600160a01b0381168103620000b95790565b604060049162000160620002e3565b610120526101005260e05260c05260a05260805246610140526200018362000237565b610160526001600160a01b03166101808190528151630a96ad3960e01b815292839182905afa90811562000203575b600091620001cd575b506101a052620001cb6001600055565b565b620001f3915060403d8111620001fb575b620001ea8183620000f0565b81019062000213565b5038620001bb565b503d620001de565b6200020d6200022a565b620001b2565b9190826040910312620000b9576020825192015190565b506040513d6000823e3d90fd5b60c05160805160a0516040519160208301938452604083015260608201524660808201523060a082015260a0815260c0810181811060018060401b03821117620000da5760405251902090565b604051906200029382620000be565b6003825262312e3160e81b6020830152565b90815180926000905b828210620002cb575011620002c1570190565b6000828201520190565b915080602080928401015181850152018391620002ae565b620002ed62000747565b8051602080920120916200030062000284565b8281519101209160405181810192816200032b85600a906909ecccccae492e8cada560b31b81520190565b6e1d5a5b9d0e081a5d195b551e5c194b608a1b8152600f016d1859191c995cdcc81d1bdad95b8b60921b8152600e017f75696e74323536206964656e7469666965724f7243726974657269612c0000008152601d017f75696e74323536207374617274416d6f756e742c0000000000000000000000008152601401701d5a5b9d0c8d4d88195b99105b5bdd5b9d607a1b8152601101602960f81b81526001010392601f19938481018452620003e19084620000f0565b60405171086dedce6d2c8cae4c2e8d2dedc92e8cada560731b8282019081529481601287016e1d5a5b9d0e081a5d195b551e5c194b608a1b8152600f016d1859191c995cdcc81d1bdad95b8b60921b8152600e017f75696e74323536206964656e7469666965724f7243726974657269612c0000008152601d017f75696e74323536207374617274416d6f756e742c0000000000000000000000008152601401711d5a5b9d0c8d4d88195b99105b5bdd5b9d0b60721b8152601201701859191c995cdcc81c9958da5c1a595b9d607a1b8152601101602960f81b8152600101038181018352620004d29083620000f0565b6040519283818101620004fc906010906f09ee4c8cae486dedae0dedccadce8e6560831b81520190565b6f1859191c995cdcc81bd999995c995c8b60821b81526010016c1859191c995cdcc81e9bdb994b609a1b8152600d017113d999995c925d195b56d7481bd999995c8b60721b81526012017f436f6e73696465726174696f6e4974656d5b5d20636f6e73696465726174696f8152611b8b60f21b60208201526022016f1d5a5b9d0e081bdc99195c951e5c194b60821b8152601001711d5a5b9d0c8d4d881cdd185c9d151a5b594b60721b81526012016f1d5a5b9d0c8d4d88195b99151a5b594b60821b815260100170189e5d195ccccc881e9bdb9952185cda0b607a1b81526011016c1d5a5b9d0c8d4d881cd85b1d0b609a1b8152600d017f6279746573333220636f6e647569744b65792c0000000000000000000000000081526013016e3ab4b73a191a9b1031b7bab73a32b960891b8152600f01602960f81b81526001010382810185526200064e9085620000f0565b6040516c08a92a06e626488dedac2d2dc5609b1b8282019081529080600d83016b1cdd1c9a5b99c81b985b594b60a21b8152600c016e1cdd1c9a5b99c81d995c9cda5bdb8b608a1b8152600f016f1d5a5b9d0c8d4d8818da185a5b92590b60821b81526010017f6164647265737320766572696679696e67436f6e7472616374000000000000008152601901602960f81b8152600101038481018252620006f69082620000f0565b5190209786519020968351902095604051938492830195866200071991620002a5565b6200072491620002a5565b6200072f91620002a5565b039081018252620007419082620000f0565b51902090565b604051906200075682620000be565b600d82526c21b7b739b4b232b930ba34b7b760991b602083015256fe60806040526004361015610013575b600080fd5b60003560e01c806306fdde031461013f57806346423aa71461013657806355944a421461012d5780635b34b9661461012457806379df72bd1461011b57806387201b41146101125780638814773214610109578063a817440414610100578063b3a34c4c146100f7578063e7acab24146100ee578063ed98a574146100e5578063f07ec373146100dc578063f47b7740146100d3578063fb0f3ee1146100ca5763fd9f1e10146100c257600080fd5b61000e611269565b5061000e610fb7565b5061000e610f30565b5061000e610eeb565b5061000e610e5a565b5061000e610dac565b5061000e610d48565b5061000e610cd7565b5061000e610ba6565b5061000e610ad2565b5061000e610957565b5061000e6108f2565b5061000e610861565b5061000e6101c7565b5061000e610199565b91908251928382526000905b848210610181575092806020939411610174575b601f01601f1916010190565b6000838284010152610168565b90602090818082850101519082860101520190610154565b503461000e57600036600319011261000e57602080526d0d436f6e73696465726174696f6e604d5260606020f35b503461000e57602036600319011261000e57600435600052600260205260806040600020546040519060ff81161515825260ff8160081c16151560208301526001600160781b038160101c16604083015260881c6060820152f35b50634e487b7160e01b600052604160045260246000fd5b60a0810190811067ffffffffffffffff82111761025557604052565b61025d610222565b604052565b60c0810190811067ffffffffffffffff82111761025557604052565b6020810190811067ffffffffffffffff82111761025557604052565b6040810190811067ffffffffffffffff82111761025557604052565b90601f8019910116810190811067ffffffffffffffff82111761025557604052565b60405190610160820182811067ffffffffffffffff82111761025557604052565b6040519061030682610239565b565b60209067ffffffffffffffff8111610322575b60051b0190565b61032a610222565b61031b565b6001600160a01b0381160361000e57565b60a435906103068261032f565b35906103068261032f565b3590600682101561000e57565b92919261037182610308565b604094610380865192836102b6565b819584835260208093019160a080960285019481861161000e57925b8584106103ac5750505050505050565b868483031261000e5784879184516103c381610239565b6103cc87610358565b8152828701356103db8161032f565b838201528587013586820152606080880135908201526080808801359082015281520193019261039c565b9080601f8301121561000e5781602061042193359101610365565b90565b92919261043082610308565b60409461043f865192836102b6565b819584835260208093019160c080960285019481861161000e57925b85841061046b5750505050505050565b868483031261000e57848791845161048281610262565b61048b87610358565b81528287013561049a8161032f565b838201528587013586820152606080880135908201526080808801359082015260a080880135906104ca8261032f565b82015281520193019261045b565b9080601f8301121561000e5781602061042193359101610424565b6004111561000e57565b3590610306826104f3565b9190916101608184031261000e5761051e6102d8565b926105288261034d565b84526105366020830161034d565b602085015267ffffffffffffffff90604083013582811161000e578161055d918501610406565b6040860152606083013591821161000e576105799183016104d8565b606084015261058a608082016104fd565b608084015260a081013560a084015260c081013560c084015260e081013560e0840152610100808201359084015261012080820135908401526101408091013590830152565b35906001600160781b038216820361000e57565b92919267ffffffffffffffff821161062c575b6040519161060f601f8201601f1916602001846102b6565b82948184528183011161000e578281602093846000960137010152565b610634610222565b6105f7565b9080601f8301121561000e57816020610421933591016105e4565b91909160a08184031261000e576106696102f9565b9267ffffffffffffffff823581811161000e5782610688918501610508565b8552610696602084016105d0565b60208601526106a7604084016105d0565b6040860152606083013581811161000e57826106c4918501610639565b6060860152608083013590811161000e576106df9201610639565b6080830152565b9080601f8301121561000e578135906106fe82610308565b9261070c60405194856102b6565b828452602092838086019160051b8301019280841161000e57848301915b84831061073a5750505050505090565b823567ffffffffffffffff811161000e57869161075c84848094890101610654565b81520192019161072a565b9181601f8401121561000e5782359167ffffffffffffffff831161000e576020808501948460051b01011161000e57565b50634e487b7160e01b600052602160045260246000fd5b600611156107b957565b610306610798565b60809080516107cf816107af565b8352816001600160a01b03918260208201511660208601526040810151604086015260608101516060860152015116910152565b90815180825260208080930193019160005b828110610823575050505090565b909192938260e06001926040885161083c8382516107c1565b808501516001600160a01b031660a0840152015160c082015201950193929101610815565b50606036600319011261000e5767ffffffffffffffff60043581811161000e5761088f9036906004016106e6565b9060243581811161000e576108a8903690600401610767565b60443592831161000e576108ee936108d46108ca6108da953690600401610767565b9490933691611a50565b9061379a565b604051918291602083526020830190610803565b0390f35b503461000e57600036600319011261000e5761090c6147c0565b3360005260016020526020604060002060018154018091556040518181527f721c20121297512b72821b97f5326877ea8ecf4bb9948fea5bfcb6453074d37f833392a2604051908152f35b503461000e5760031960203682011261000e5760043567ffffffffffffffff811161000e576101608160040192823603011261000e5761099682611434565b916109a360248301611434565b906109b16044840182611b4d565b6064850192916109c18484611b83565b929093608488016109d190611bc3565b956109db91611b83565b9690506109e66102d8565b6001600160a01b0390991689526001600160a01b031660208901523690610a0c92610365565b60408701523690610a1c92610424565b6060850152610a2e9060808501611bcd565b60a482013560a084015260c482013560c084015260e482013560e08401526101048201356101008401526101248201356101208401526101408301526101440135610a78916121f1565b604051908152602090f35b9092916040820191604081528451809352606081019260208096019060005b818110610abc575050506104219394818403910152610803565b8251151586529487019491870191600101610aa2565b5060e036600319011261000e5767ffffffffffffffff60043581811161000e57610b009036906004016106e6565b60243582811161000e57610b18903690600401610767565b909160443584811161000e57610b32903690600401610767565b9060643595861161000e57610b4e610b67963690600401610767565b929091610b59610340565b9560c4359760843596611b13565b906108ee60405192839283610a83565b602060031982011261000e576004359067ffffffffffffffff821161000e57610ba291600401610767565b9091565b503461000e57610bb536610b77565b610bbd6147c0565b60005b818110610bd35760405160018152602090f35b80610be1600192848661388c565b610beb8180613fa9565b610bf481611434565b91610c07610c023684610508565b614752565b91610c1c836000526002602052604060002090565b610c268185614b98565b50610c39610c35825460ff1690565b1590565b610c49575b505050505001610bc0565b7ffde361574a066b44b3b5fe98a87108b7565e327327954c4faeea56a4e6491a0a92610cca92610ca6610cac93610c99610c92610c8b60209687810190611474565b36916105e4565b898b6149e6565b805460ff19166001179055565b01611434565b6040519384526001600160a01b039081169416929081906020820190565b0390a33880808080610c3e565b50604036600319011261000e5767ffffffffffffffff60043581811161000e57610d05903690600401610767565b60249291923591821161000e576108ee92610d32610d2a6108da943690600401610767565b93909261402e565b60405190610d3f8261027e565b6000825261379a565b5060031960403682011261000e576004359067ffffffffffffffff821161000e57604090823603011261000e57610da2610d86602092600401613fbf565b60405190610d938261027e565b60008252339160243591613b28565b6040519015158152f35b5060031960803682011261000e576004359067ffffffffffffffff9081831161000e5760a090833603011261000e5760243590811161000e576108ee91610dfa610e3b923690600401610767565b90606435610e078161032f565b6001600160a01b038116610e4d5750610e35610e2933945b3690600401610654565b91604435933691611a50565b90613b28565b60405190151581529081906020820190565b610e29610e359194610e1f565b5060a036600319011261000e5767ffffffffffffffff60043581811161000e57610e88903690600401610767565b9060243583811161000e57610ea1903690600401610767565b91909260443594851161000e57610eca610ec2610b67963690600401610767565b92909361402e565b9160405193610ed88561027e565b6000855260843595339560643595612572565b503461000e57602036600319011261000e576020610f28600435610f0e8161032f565b6001600160a01b0316600052600160205260406000205490565b604051908152f35b503461000e57600036600319011261000e57610f7e610f4d61231b565b60405190610f5a8261029a565b6003825262312e3160e81b6020830152604051928392606084526060840190610148565b9060208301526001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001660408301520390f35b5060031960203682011261000e5760043567ffffffffffffffff811161000e576102408160040192823603011261000e5761012435908160021c9260018411933415850361124d57849360038211600283149161103e8360028611600119870102018815926001820185028460011b880103998a92600360a088026024013593168a6114a7565b6110508260051b6101c40135986107af565b1561110a5750505061107061106482611434565b6001600160a01b031690565b6001600160a01b039081166024840135176110f8576110cc6044946110c76110e2976110d8946110a260a48901611434565b9060648901946110b186611434565b9060e48b01359360c48c01359333931691611be4565b611434565b9161020484019061143e565b9390920135611861565b6110ec6001600055565b60405160018152602090f35b604051636ab37ce760e01b8152600490fd5b9194509161117361106460646111789661117d9961112661141b565b8a819b99611134839b6107af565b156111825750610ca69161114a60a48501611434565b611155868601611434565b9060e48601359160c4870135916001600160a01b0333921690611e18565b611916565b611f6a565b6110e2565b61118b816107af565b600381036111d257506111cd916111a460a48501611434565b6111af868601611434565b9060e48601359160c4870135916001600160a01b0333921690611eb9565b610ca6565b806111de6004926107af565b03611218576111cd916111f088611434565b6111fb868601611434565b6044860135916001600160a01b0360248801359216903390611e18565b6111cd9161122588611434565b611230868601611434565b6044860135916001600160a01b0360248801359216903390611eb9565b604051630a61be9f60e41b8152346004820152602490fd5b0390fd5b503461000e5761127836610b77565b6112806147c0565b60005b8181106112965760405160018152602090f35b6112a181838561478b565b6112aa81611434565b6020906112b8828401611434565b6001600160a01b039182811693843314158061140f575b6113fd576040956112e281880182611b4d565b6060808401926112f28486611b83565b90916080948a86890161130490611bc3565b9761130f908a611b83565b9a905061131a6102d8565b6001600160a01b03909c168c526001600160a01b03909116908b0152369061134192610365565b8c890152369061135092610424565b9086015284019061136091611bcd565b60a0808201359084015260c0808201359084015260e0808201359084015261010080820135908401526101208082013590840152610140918284015201356113a7916121f1565b936113bc856000526002602052604060002090565b805461ffff19166101001790555193845216917f6bacc01dbe442496068f7d234edd811f1a5f833243e0aec824f86ab861f3c90d90602090a3600101611283565b60405163203b1cdd60e21b8152600490fd5b508383163314156112cf565b604051906114288261029a565b60208083523683820137565b356104218161032f565b903590601e198136030182121561000e570180359067ffffffffffffffff821161000e57602001918160061b3603831361000e57565b903590601e198136030182121561000e570180359067ffffffffffffffff821161000e5760200191813603831361000e57565b9591906114b26147b1565b6114c6610140880135610120890135614991565b506114cf6117da565b6114ed6114e061020089018961143e565b6101e08a013591506117c1565b7f00000000000000000000000000000000000000000000000000000000000000006080528160a0526060602460c037604060646101203760e06080908120610160526001610264359081016102a060059290921b918201526102c081019384526024906102e00137610160928460a0528560c052600060e05260005b8394610204358210156115c65790604060a0600193602090818560061b6102840161010037838560061b6102840161012037019660e0608020885201968888528960c08201526101008360061b6102840191013701939293611569565b5090929350969590966001610204350160051b610160206060525b83610264358210156116145790604060a060019301958787528860c08201526101008360061b61028401910137016115e1565b505093509490506103069391507f00000000000000000000000000000000000000000000000000000000000000006080528260a052606060c460c03760206101046101203760c0608020600052602060002060e05260016102643560051b610200015261022092836102643560051b0152606060c46102406102643560051b01376117b9610c8b608435936116bc856001600160a01b03166000526001602052604060002090565b547f00000000000000000000000000000000000000000000000000000000000000006080526040608460a03760605161010052846101205260a0610144610140376101e0526101809485608020956102643560051b0190868252336101a06102643560051b015260806101c06102643560051b01526101206101e06102643560051b01527f9d9af8e38d66c62e2c12f0225249fd9d721c54b83f48d9352c97c6cacdcb6f3160a4359260a061026435026101e00190a360006060526117b0606082016110c761178a82611434565b9661179760808601611434565b906001600160a01b03809916906101608701358b614c52565b95810190611474565b9216906140ba565b106117c857565b604051632335530b60e11b8152600490fd5b601861012435106102643560061b61026001610244351461024061022435146020600435141616161561180957565b6040516339f3e3fd60e01b8152600490fd5b50634e487b7160e01b600052603260045260246000fd5b901561183b5790565b61042161181b565b9190811015611854575b60061b0190565b61185c61181b565b61184d565b919234936000915b8083106118ac5750505082821161189a578161188491611c7b565b80821161188f575050565b610306910333611c7b565b604051631a783b8d60e01b8152600490fd5b9091946118ba868385611843565b9081359080821161189a576118de82602060019501356118d98161032f565b611c7b565b0395019190611869565b50634e487b7160e01b600052601160045260246000fd5b81811061190a570390565b6119126118e8565b0390565b909392919081156119d657933361192f60a08301611434565b60e08301359260c08101355b6110f8578460051b6101e40335946102008201611958818461143e565b93905060005b848110611975575050505050956103069596611cdf565b8989858e61198d85611987898961143e565b90611843565b8035926119bb575b916119b593916119ae6110646020600199989601611434565b908c611cdf565b0161195e565b92909493919b8c6119cb916118ff565b9b9193949092611995565b9333946119e282611434565b604083013592602081013561193b565b81601f8201121561000e57803591611a0983610308565b92611a1760405194856102b6565b808452602092838086019260051b82010192831161000e578301905b828210611a41575050505090565b81358152908301908301611a33565b909291611a5c84610308565b91604094611a6c865194856102b6565b839581855260208095019160051b83019380851161000e5783925b858410611a975750505050505050565b67ffffffffffffffff90843582811161000e5786019060a08285031261000e578451611ac281610239565b8235815289830135600281101561000e578a82015285830135868201526060808401359082015260808084013594851161000e57611b04868c968796016119f2565b90820152815201930192611a87565b90611b4190610ba29a99989796959493986001600160a01b03811615600014611b47575033985b3691611a50565b90612572565b98611b3a565b903590601e198136030182121561000e570180359067ffffffffffffffff821161000e576020019160a082023603831361000e57565b903590601e198136030182121561000e570180359067ffffffffffffffff821161000e576020019160c082023603831361000e57565b600411156107b957565b35610421816104f3565b6004821015611bd95752565b611be1610798565b52565b949290959391841515600014611c37576103069660405196632671a55160e11b8852602060048901526001602489015260448801526064870152608486015260a485015260c484015260e4830152612082565b9291946002919450611c48816107af565b03611c6f57600103611c5d57610306936147de565b60405163efcc00b160e01b8152600490fd5b929190610306946148a1565b90611c8581611cc6565b600080808084865af115611c97575050565b60449250611ca36123fc565b6001600160a01b036040519263470c7c1d60e01b84521660048301526024820152fd5b15611ccd57565b60405163246cf94560e21b8152600490fd5b929193949094611cee83611cc6565b611cf88183611f57565b80611e0a575050604051926000946323b872dd60e01b865280600452816024528260445260208660648180885af1803d15601f3d1160018a51141617163d1515811615611d4e575b505050505050604052606052565b80863b151516611d4057908795969115611d7657632f8aeb3960e11b86526004879052602486fd5b15611d975750608494639889192360e01b8552600452602452604452606452fd5b3d611dbd575b5060a49463f486bc8760e01b855260045260245260445281606452608452fd5b601f3d0160051c9060051c908060030291808211611df1575b505060205a910110611de85785611d9d565b833d81803e3d90fd5b8080600392028380020360091c92030201018680611dd6565b90610306959294939161217c565b95909294939193611e298183611f57565b80611e40575050600103611c5d57610306936147de565b906064959391600097959397506020825114600014611ea65760c090600190604084526020840152632671a55160e11b60408401526020604484015280888401525b0201936002603b19860152601b198501526004840152602483015260448201520152565b5060c08682016001815101809152611e82565b959091929394611ec886611cc6565b611ed28183611f57565b80611ee2575050610306946148a1565b9060649596949392916020825114600014611f445760c090600190604084526020840152632671a55160e11b60408401526020604484015280888401525b0201936003603b19860152601b198501526004840152602483015260448201520152565b5060c08682016001815101809152611f20565b90602082015103611f655750565b610306905b60408082510361207e57602082015160c06064840151026044019180519260206001600160a01b036000928184927f00000000000000000000000000000000000000000000000000000000000000001660ff60a01b1783528684527f000000000000000000000000000000000000000000000000000000000000000086526055600b201696855281805284880182885af19051901561204c576001600160e01b03191663598e5aaf60e11b016120235750505060209052565b51630e7ccd9360e11b815260048101919091526001600160a01b03919091166024820152604490fd5b61126584836120596123fc565b5163344f54f560e21b81526001600160a01b0390911660048201529081906024820190565b5050565b6040519160206001600160a01b036101046000938285937f00000000000000000000000000000000000000000000000000000000000000001660ff60a01b1784528685527f00000000000000000000000000000000000000000000000000000000000000006040526055600b20169660405282805282875af190519015612149576001600160e01b03191663598e5aaf60e11b0161211e575050565b604051630e7ccd9360e11b815260048101919091526001600160a01b03919091166024820152604490fd5b611265836121556123fc565b60405163344f54f560e21b81526001600160a01b0390911660048201529081906024820190565b9060649492939160208251146000146121de5760c090600190604084526020840152632671a55160e11b60408401526020604484015280878401525b0201926001603b19850152601b1984015260048301526024820152600060448201520152565b5060c085820160018151018091526121b8565b91909161014081018051917f0000000000000000000000000000000000000000000000000000000000000000604051604083018051928351926020809501906000915b868684106122f85750505050506040519160051b8220917f00000000000000000000000000000000000000000000000000000000000000009093606086019481865101906000915b8a83106122d45750505050508560051b6040512093601f1901978851907f00000000000000000000000000000000000000000000000000000000000000008a5282519383528451958552865261018089209852525252565b8380600192601f1981510180519089815260e081208752520192019201919061227c565b80600192601f1981510180519088815260c0812087525201920192019190612234565b467f000000000000000000000000000000000000000000000000000000000000000003612366577f000000000000000000000000000000000000000000000000000000000000000090565b60405160208101907f000000000000000000000000000000000000000000000000000000000000000082527f000000000000000000000000000000000000000000000000000000000000000060408201527f000000000000000000000000000000000000000000000000000000000000000060608201524660808201523060a082015260a081526123f681610262565b51902090565b3d61240357565b601f3d0160051c60405160051c908060030291808211612436575b505060205a91011061242c57565b3d6000803e3d6000fd5b8080600392028380020360091c9203020101388061241e565b919082604091031261000e576040516040810181811067ffffffffffffffff821117612489575b6040526020808294803584520135910152565b612491610222565b612476565b9291926124a282610308565b6040926124b1845192836102b6565b819581835260208093019160061b84019381851161000e57915b8483106124da57505050505050565b8386916124e7848661244f565b8152019201916124cb565b929190926124ff84610308565b9161250d60405193846102b6565b829480845260208094019060051b83019282841161000e5780915b84831061253757505050505050565b823567ffffffffffffffff811161000e57820184601f8201121561000e5786916125678683858095359101612496565b815201920191612528565b9698979261258d8a61259c969561259495949998998b612790565b36916124f2565b9336916124f2565b9082518251916125b46125af8484612c25565b613068565b9760009586915b848310612696575050506000935b83851061260e57505050505080612603575b508251156125f157826125ed916134af565b9190565b60405163d5da9a1b60e01b8152600490fd5b8351038352386125db565b90919293948861262984612622898661276e565b518a613129565b8051608001516001600160a01b03166001600160a01b0361265761106460208501516001600160a01b031690565b9116036126715750506001809101955b01939291906125c9565b87916126909161268985896001979c0103809361276e565b528b61276e565b50612667565b9091968a6126b4836126ad8b879b98999a9b61276e565b518c6130c5565b8051608001516001600160a01b03166001600160a01b036126e261106460208501516001600160a01b031690565b9116036126ff5750506001809101975b01919095949392956125bb565b899161271c91612715856001969d03809361276e565b528d61276e565b506126f2565b9061272c82610308565b61273960405191826102b6565b828152809261274a601f1991610308565b0190602036910137565b602090805115612762570190565b61276a61181b565b0190565b6020918151811015612783575b60051b010190565b61278b61181b565b61277b565b9392909161279c6147b1565b8451926127a884612722565b9160008352601d604560003560e01c061160011b9060005b868110612868575050600314612856576127da9086612d09565b60005b8381106127ec57505050509050565b806127f96001928461276e565b51156128515761284b61280c828961276e565b5151612818838661276e565b51908661282c82516001600160a01b031690565b60208301516001600160a01b0316906060604085015194015194613ee0565b016127dd565b61284b565b6040516312d3f5a360e01b8152600490fd5b612872818a61276e565b519180156129d757612885868685614487565b92909160018501895282156129c35761289e858a61276e565b52600019019380519260a084015193604060c08201519101518051908560005b8381106129585750505050606080935101519485519560005b8781106128f05750505050505050506001905b016127c0565b808760a06129006001948661276e565b518861293c89898d608086019761291989518783612cb6565b918701958651908a518214600014612948575050508085525b8088528451612c7a565b905201519052016128d7565b61295192612cb6565b8552612932565b612962818461276e565b519b8c5115179b86868b6080840193845161297e908589612cb6565b60608192019586519881518a14600014996129a99760019b6129b3575050508187525b528451612c39565b90520186906128be565b6129bc92612cb6565b87526129a1565b5093600193925060009150602001526128ea565b919060006020600193015281810186526128ea565b6129f46147b1565b805192612a0084612722565b92600091828552601d6045843560e01c061160011b90835b878110612aa857505060031461285657612a329083612d09565b838110612a3f5750505050565b80612a4c6001928561276e565b5115612aa357612a9d612a5f828561276e565b5151612a6b838761276e565b5190612a7e81516001600160a01b031690565b60208201516001600160a01b0316906060604084015193015193613e0e565b01612a32565b612a9d565b612ab2818761276e565b5191858115612bf35750612ac7888685614699565b929091600185018b52888315612be15750612ae2858c61276e565b52600019019380519260a084015191604060c0860151950151805190858c5b838110612b875750505050606090510151938451948a5b868110612b3057505050505050506001905b01612a18565b80612b3d6001928461276e565b5160a0608082019189612b7b888b612b5787518d86612cb6565b60608601948d8651908a518214600014612948575050508085528088528451612c7a565b90520151905201612b18565b612b91818461276e565b519b8c5115179b868a8960808401938451612bad908589612cb6565b60608192019586519881518a1460001499612bd79760019b6129b357505050818752528451612c39565b9052018690612b01565b92505093600193925060200152612b2a565b6020600193929401528181018852612b2a565b8060001904821181151516612c19570290565b612c216118e8565b0290565b81198111612c31570190565b61276a6118e8565b9092838203612c485750505090565b829391612c64612c7094612c6a93039542039182870390612c06565b92612c06565b90612c25565b9081049015150290565b9092838203612c895750505090565b92612c6a612ca792612c648560019697039642039182880390612c06565b91600019830104019015150290565b919091828114612ce65782818309612cd557612cd191612c06565b0490565b63c63cf08960e01b60005260046000fd5b50905090565b600211156107b957565b51610421816107af565b611be1826107af565b815181519260005b828110612e205750505060005b828110612d2a57505050565b612d34818361276e565b51612d58612d4c60208301516001600160781b031690565b6001600160781b031690565b15612e175751606081018051519060005b828110612dcf575050506040809101908151519160005b838110612d9557505050506001905b01612d1e565b612db2612dac612da683855161276e565b51612cf6565b60031090565b612dbe57600101612d80565b825163a6cfc67360e01b8152600490fd5b612de0612dac612da683855161276e565b612dec57600101612d69565b6040517fff75a340000000000000000000000000000000000000000000000000000000008152600490fd5b50600190612d8f565b612e2a818361276e565b5180519086821015612f9057602091612e59612d4c84612e4a848b61276e565b5101516001600160781b031690565b15612f8557612e68908761276e565b5151916040928383015191830151612e7f81612cec565b612e8881612cec565b612f28578301518051821015612f175790612ea29161276e565b51916003835193612eb2856107af565b8490612ec984820191600483519814850390612d00565b606085015190525b1115612f075750906001929181612eec575b50505b01612d11565b612f00916080606083015192015191612fa2565b3880612ee3565b51634a75b57b60e11b8152600490fd5b8351635fd9fc6760e11b8152600490fd5b92906060809401518051821015612f7457600391612f459161276e565b5193845194612f53866107af565b8591612f6a85830192600484519914860390612d00565b8501519052612ed1565b82516330446bef60e11b8152600490fd5b505050600190612ee6565b6040516321a561b160e21b8152600490fd5b91909160009081526020808220928181019282825192600593841b0101915b828510612fe657505050505003612fd457565b6040516309bde33960e01b8152600490fd5b8451808711821b96875295841895909552604081209493830193612fc1565b604051906060820182811067ffffffffffffffff82111761305b575b8060405260408361303183610239565b6000928381528360808301528360a08301528360c08301528360e083015281528260208201520152565b613063610222565b613021565b9061307282610308565b61307f60405191826102b6565b8281528092613090601f1991610308565b019060005b8281106130a157505050565b6020906130ac613005565b82828501015201613095565b906002821015611bd95752565b9092916130d0613005565b93805115613110576130f2926001600160a01b0386931660808451015261319c565b81516060810151156131015750565b60806000918260208601520152565b60405163375c24c160e01b815260006004820152602490fd5b929190613134613005565b9381511561317157613147918591613344565b60208301903382526040840152825190606082015115613165575050565b60009182608092520152565b60405163375c24c160e01b815260016004820152602490fd5b50637fda727960e01b60005260046000fd5b929192602082019060208251518251811015613337575b60051b8201015192835192602060408501518183510151815181101561332a575b60051b010151600094602086970151613314575b9061012060609260408b5193805185526020810151602086015201516040840152805160208c0152015160408a01522091805160051b01905b81811061325b5750505050606082939451015261323b5750565b60011461324a576103066118e8565b63246cf94560e21b60005260046000fd5b602090959495019060208251518551811015613307575b60051b850101516020810151156132fe5751606060206040830151818651015181518110156132f1575b60051b01015196818801519081158a8381011060011b17179801966000828201522084149060408a0151610120820151149060208b01519051141616156132e4575b90613221565b6132ec61318a565b6132de565b6132f961318a565b61329c565b509493946132de565b61330f61318a565b613272565b60608201805160009091528015975095506131e8565b61333261318a565b6131d4565b61333f61318a565b6131b3565b92916020808301948551519181518310156134a2575b80600593841b8301015194606093828588510151818b5101518151811015613495575b831b010151926000968188990151613480575b51948451865281850151828701526040850151604087015260a0809501519a608087019b8c52878720948051851b01905b8181106133dc575050505050505083949550015261323b5750565b83909a999a01908c848351518551811015613473575b871b850101518581015115613469578a86915101518185510151815181101561345c575b881b0101518a81019b8d8d518091019e8f9115911060011b17179c9b60009052888b82208914925191015114161561344f575b906133c1565b61345761318a565b613449565b61346461318a565b613416565b5050999899613449565b61347b61318a565b6133f2565b84870180516000909152801599509750613390565b61349d61318a565b61337d565b6134aa61318a565b61335a565b9081516134bb81612722565b9260005b82811061357f5750505034906134d361141b565b9080519060005b82811061350e575050506134ed90611f6a565b806134fe575b506104216001600055565b6135089033611c7b565b386134f3565b613518818361276e565b518051908151613527816107af565b613530816107af565b15613564575b8560019392826040613555602061355e9601516001600160a01b031690565b91015191613627565b016134da565b956060829392018181511161189a5751900395909190613536565b613589818361276e565b516135a1612d4c60208301516001600160781b031690565b1561361e576135b96135b3838861276e565b60019052565b606080915101519081519160005b8381106135dc57505050506001905b016134bf565b826135e7828461276e565b510151806135f857506001016135c7565b6040516314bea84160e31b81526004810187905260248101929092526044820152606490fd5b506001906135d6565b9290918351613635816107af565b61363e816107af565b6136935750505061365c61106460208301516001600160a01b031690565b6001600160a01b0360408301519116176110f85780606061368a60806103069401516001600160a01b031690565b91015190611c7b565b909192600181516136a3816107af565b6136ac816107af565b036136fc5760408101516110f857610306936136d260208301516001600160a01b031690565b906001600160a01b0360606136f160808601516001600160a01b031690565b940151931691611cdf565b926002845161370a816107af565b613713816107af565b03613759578361373060206103069601516001600160a01b031690565b60808201516001600160a01b0316926001600160a01b0360606040850151940151941691611e18565b8361377160206103069601516001600160a01b031690565b60808201516001600160a01b0316926001600160a01b0360606040850151940151941691611eb9565b906137ac9094939294825190836129ec565b6137b582613068565b9160009485915b8083106137e957505050906137da91848294956137de575b506134af565b5090565b8251038252386137d4565b9091956137f787838561388c565b61381d613804828061143e565b906138146020948581019061143e565b929091896138c7565b906001600160a01b0361385261106461384260808651016001600160a01b0390511690565b938501516001600160a01b031690565b91160361386957506001809101965b0191906137bc565b96613886829860019383039061387f828a61276e565b528761276e565b50613861565b91908110156138af575b60051b81013590603e198136030182121561000e570190565b6138b761181b565b613896565b61042190369061244f565b929093916138d3613005565b9481158015613a89575b613a77576138e9613005565b6138fe816138f8368888612496565b88613344565b51916139158761390f368486612496565b8861319c565b61391f8751612cf6565b83519061392b826107af565b613934826107af565b61393d816107af565b14801590613a3f575b8015613a2c575b613a1a57610421956139ca95608095896060948588019687518784510151106000146139dd5750505061398c61398785936139b293611832565b6138bc565b6020836139a58d828a519151015190039684519061276e565b515101519101519061276e565b5101528651015190525b01516001600160a01b031690565b6080835101906001600160a01b03169052565b8697969450613a0c93506139a5856139fc613987602095604095611832565b945101518851855191039761276e565b5101525190865101526139bc565b6040516309cfb45560e01b8152600490fd5b506040875101516040840151141561394d565b508651602001516001600160a01b03166001600160a01b03613a6e61106460208701516001600160a01b031690565b91161415613946565b604051634c74edb760e11b8152600490fd5b5083156138dd565b60405190613a9e82610239565b604051608083610160830167ffffffffffffffff811184821017613b1b575b6040526000808452806020850152606093846040820152848082015281848201528160a08201528160c08201528160e08201528161010082015281610120820152816101408201528252806020830152604082015282808201520152565b613b23610222565b613abd565b909291613b336147c0565b6002600055613b428483614166565b9490919260405195613b538761029a565b6001875260005b602080821015613b7c5790602091613b70613a91565b90828b01015201613b5a565b5050613bb0839597613bab613bc99a613bb99799835115613be5575b6020840152825115613bd8575b82612d09565b612754565b51519586613bf2565b81516001600160a01b031661282c565b613bd36001600055565b600190565b613be061181b565b613ba5565b613bed61181b565b613b98565b939192909360a093848201519360c083015196613c0d61141b565b96604092838601908151519160005b838110613cea575050505034986060809601978851519860005b8a8110613c63575050505050505050505050613c5190611f6a565b80613c595750565b6103069033611c7b565b613c6e81835161276e565b518981018051613c8887878d8c6080880195865190613d9c565b8092528783015190528151613c9c816107af565b613ca5816107af565b15613cc2575b5090613cbc8d8c6001943390613627565b01613c36565b90919e9d808211613cd9579d9e9d039c908a613cab565b8851631a783b8d60e01b8152600490fd5b613cf581835161276e565b518051613d01816107af565b613d0a816107af565b15613d545790613d4e8d8f93868f8d613d366001988e9360608701938451956080890196875190613d65565b9052528c61012061355582516001600160a01b031690565b01613c1c565b87516312d3f5a360e01b8152600490fd5b909390848103613d7b5750506104219350612cb6565b9383613d906104219796613d96949686612cb6565b93612cb6565b90612c39565b909390848103613db25750506104219350612cb6565b9383613d906104219796613dc7949686612cb6565b90612c7a565b90815180825260208080930193019160005b828110613ded575050505090565b909192938260a082613e0260019489516107c1565b01950193929101613ddf565b91939290936040805193608091828601918652602090600082880152838188015285518093528160a088019601936000915b848310613e955750505050505091613e90827f9d9af8e38d66c62e2c12f0225249fd9d721c54b83f48d9352c97c6cacdcb6f31948380950360608501526001600160a01b03809116971695613dcd565b0390a3565b90919293949684836001928a518051613ead816107af565b8252808401516001600160a01b031684830152858101518683015260609081015190820152019801959493019190613e40565b92909493916040918251946080918287019187526001600160a01b0394856020921682890152838189015286518093528160a089019701936000915b848310613f65575050505050508282859493613e9093867f9d9af8e38d66c62e2c12f0225249fd9d721c54b83f48d9352c97c6cacdcb6f31989603606087015216971695613dcd565b90919293949784836001928b518051613f7d816107af565b8252808401518c1684830152858101518683015260609081015190820152019901959493019190613f1c565b90359061015e198136030182121561000e570190565b613fc7613a91565b50614011613fe3613fd88380613fa9565b926020810190611474565b613ffa60405194613ff386610239565b3690610508565b8452600160208501526001604085015236916105e4565b60608201526040516140228161027e565b60008152608082015290565b61403782610308565b9161404560405193846102b6565b808352601f1961405482610308565b0160005b8181106140a357505060005b8181106140715750505090565b80614087614082600193858761388c565b613fbf565b614091828761276e565b5261409c818661276e565b5001614064565b6020906140ae613a91565b82828801015201614058565b929190836000526002602052604060002091825460ff8160081c16614139576001600160781b038160101c16614120579460ff710100000000000000000000000000000100019596161561410f575b50505055565b614118926149e6565b388080614109565b60405163ee9e0e6360e01b815260048101879052602490fd5b604051630694555d60e21b815260048101879052602490fd5b90805b61415d575090565b80910680614155565b9091815192614181610c3560a086015160c087015190614991565b61447b5761419c612d4c60208501516001600160781b031690565b936141b4612d4c60408601516001600160781b031690565b948581118015614473575b6144615785811080614449575b614437576142186141dc83614752565b9360e084015160808501516141f081611bb9565b85516001600160a01b0316918761421160208901516001600160a01b031690565b948b6151ce565b61422c836000526002602052604060002090565b9161423a610c358486614b98565b614427578254958460ff881615614400575b5050506001600160781b0390818660101c169560881c968715156000146143ba576001810361438257505085945b856142858883612c25565b11614378575b8661429591612c25565b808287118383111761432a575b50906142f18184936142be61432596600160ff19825416179055565b845470ffffffffffffffffffffffffffffffff001916911660101b70ffffffffffffffffffffffffffffff000016178355565b815470ffffffffffffffffffffffffffffffffff1690861660881b70ffffffffffffffffffffffffffffffffff1916179055565b929190565b969061433d876143439298959498614152565b82614152565b80150180809204970492049480861181841117614362579091386142a2565b634e487b7160e01b600052601160045260246000fd5b808603965061428b565b959096868103614393575b5061427a565b6143ad816143a7896143b3959b9a9b612c06565b98612c06565b97612c06565b943861438d565b835470ffffffffffffffffffffffffffffff000084841660101b1670ffffffffffffffffffffffffffffffffff19909116176001178455909650945061432591906142f1565b606061441661441f94516001600160a01b031690565b920151916149e6565b38808461424c565b5050509150915090600090600090565b60405163a11b63ff60e01b8152600490fd5b506001608083015161445a81611bb9565b16156141cc565b604051632d02959960e11b8152600490fd5b5080156141bf565b50600092508291508190565b9192909282516144a3610c3560a083015160c0840151906149c2565b614689576144be612d4c60208601516001600160781b031690565b6144d5612d4c60408701516001600160781b031690565b958682118015614681575b6144615786821080614669575b61443757614541906144fe84614752565b9460e085015160808601519061451382611bb9565b8761452588516001600160a01b031690565b9361453a60208a01516001600160a01b031690565b958c615296565b614555836000526002602052604060002090565b91614563610c358486614c02565b614427578254958460ff88161561464b575b5050506001600160781b0390818660101c169560881c968715156000146143ba576001810361461f57505085945b856145ae8883612c25565b11614615575b866145be91612c25565b818611828211176145e5575b906142f18184936142be61432596600160ff19825416179055565b956145f761433d878998959498614152565b801501808092049704920494808611818411176143625790916145ca565b80860396506145b4565b959096868103614630575b506145a3565b6143ad816143a789614644959b9a9b612c06565b943861462a565b606061441661466194516001600160a01b031690565b388084614575565b506001608084015161467a81611bb9565b16156144ed565b5081156144e0565b5050915050600090600090600090565b9192909282516146b5610c3560a083015160c084015190614991565b614689576146d0612d4c60208601516001600160781b031690565b6146e7612d4c60408701516001600160781b031690565b95868211801561474a575b6144615786821080614732575b61443757614710906144fe84614752565b614724836000526002602052604060002090565b91614563610c358486614b98565b506001608084015161474381611bb9565b16156146ff565b5081156146f2565b6104219061476b606082015151610140830151906117c1565b80516001600160a01b0316600090815260016020526040902054906121f1565b9091610421928110156147a4575b60051b810190613fa9565b6147ac61181b565b614799565b6147b96147c0565b6002600055565b6001600054036147cc57565b604051637fa8a98760e01b8152600490fd5b9092813b1561488c57604051926000946323b872dd60e01b8652806004528160245282604452858060648180885af11561481e5750505050604052606052565b8593943d614848575b5060a49463f486bc8760e01b85526004526024526044526064526001608452fd5b601f3d0160051c9060051c908060030291808211614873575b505060205a910110611de85785614827565b8080600392028380020360091c92030201018680614861565b50632f8aeb3960e11b60005260045260246000fd5b929093833b1561497c57604051936080519160a0519360c05195600098637921219560e11b8a528060045281602452826044528360645260a06084528960a452898060c48180895af11561490557505050505060805260a05260c052604052606052565b89949550883d61492f575b5060a49563f486bc8760e01b8652600452602452604452606452608452fd5b601f3d0160051c9060051c908060030291808211614963575b505060205a91011061495a5786614910565b843d81803e3d90fd5b8080600392028380020360091c92030201018780614948565b83632f8aeb3960e11b60005260045260246000fd5b42109081156149b7575b506149a557600190565b6040516337bf561360e11b8152600490fd5b90504210153861499b565b42109081156149db575b506149d657600190565b600090565b9050421015386149cc565b9091336001600160a01b03831614614b9357614a0061231b565b9260009361190160f01b85526002526022526042832090836022528380528392815191601f198101805184604103918860018411938415614b28575b50851485151516978815614a72575b505050505050505015614a5b5750565b600490614a666123fc565b634f7fb80d60e01b8152fd5b90919293949596975060408252604319850193845195603f19019660208b60648a519b630b135d3f60e11b9d8e8b528c520188845afa998a614ac3575b505050505252523880808080808080614a4b565b8b5103614ad05780614aaf565b908a913b614b1957614b0a57640101000000821a15614af857632057875960e21b8152600490fd5b602491630f801e8560e11b8252600452fd5b638baa579f60e01b8152600490fd5b634f7fb80d60e01b8252600482fd5b9850506040840180519060608601518b1a99614b5f575b89865288835260208b60808560015afa5083835287865252885138614a3c565b9850601b8160ff1c01987f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82168152614b3f565b505050565b905460ff8160081c16614be9576001600160781b038160101c169081614bc1575b505050600190565b60881c1115614bd1578080614bb9565b602490604051906310fda3e160e01b82526004820152fd5b604051630694555d60e21b815260048101839052602490fd5b906000905460ff8160081c16614c49576001600160781b038160101c169081614c2f575b50505050600190565b60881c1115614c3f578080614c26565b614bd15750600090565b50905050600090565b9092916001906004811015614cb2575b1180614c9f575b80614c8c575b614c7a575b50505050565b614c8393614cbf565b38808080614c74565b506001600160a01b038216331415614c6f565b506001600160a01b038416331415614c69565b614cba610798565b614c62565b6000919290829161030695604051906001600160a01b0360208301936303874c7760e21b8552886024850152336044850152166064830152608482015260848152614d0981610262565b51915afa615353565b90815180825260208080930193019160005b828110614d32575050505090565b909192938260a060019287518051614d49816107af565b8252808401516001600160a01b03168483015260408082015190830152606080820151908301526080908101519082015201950193929101614d24565b90815180825260208080930193019160005b828110614da6575050505090565b909192938260c060019287518051614dbd816107af565b8252808401516001600160a01b039081168584015260408083015190840152606080830151908401526080808301519084015260a091820151169082015201950193929101614d98565b906004821015611bd95752565b6060519081815260208091019160809160005b828110614e35575050505090565b835185529381019392810192600101614e27565b90815180825260208080930193019160005b828110614e69575050505090565b835185529381019392810192600101614e5b565b908082519081815260208091019281808460051b8301019501936000915b848310614eab5750505050505090565b9091929394958480614f01600193601f198682030187528a5180518252614ed884820151858401906130b8565b60408082015190830152606080820151908301526080809101519160a080928201520190614e49565b9801930193019194939290614e9b565b9261505a906001600160a01b03610421969461506794875216602086015260a06040860152805160a08087015261014090614f5782880182516001600160a01b03169052565b6080615049614fae614f968a614f7f6020870151610160809301906001600160a01b03169052565b6040860151906101808d01526102a08c0190614d12565b60608501518b820361013f19016101a08d0152614d86565b614fc0838501516101c08c0190614e07565b60a08401516101e08b015260c08401516102008b015260e08401516102208b015261010094858501516102408c015261012094858101516102608d015201516102808b015261501f602087015160c08c01906001600160781b03169052565b60408601516001600160781b031660e08b01526060860151609f1995868c840301908c0152610148565b930151918784030190870152610148565b8381036060850152614e14565b916080818403910152614e7d565b939061042195936001600160a01b03615067946151c093885216602087015260a06040870152805160a080880152610140906150bc82890182516001600160a01b03169052565b60806151af6151136150fb8b60208601516150e561016091828401906001600160a01b03169052565b61018060408801519201526102a08d0190614d12565b60608501518c820361013f19016101a08e0152614d86565b615125838501516101c08d0190614e07565b60a08401516101e08c015260c08401516102008c015260e08401516102208c015261010094858501516102408d0152610120948c6102608783015191015201516102808c0152615185602087015160c08d01906001600160781b03169052565b60408601516001600160781b031660e08c01526060860151609f1995868d840301908d0152610148565b930151918884030190880152610148565b908482036060860152614e49565b9095919294936001906151e081611bb9565b1180615283575b80615270575b6151fa575b505050505050565b6080810151511580615267575b1561522257506152179450614cbf565b3880808080806151f2565b6000935083929450615254614d09615262976040519283916020830195630331315760e41b8752338b60248601614f11565b03601f1981018352826102b6565b615217565b50855115615207565b506001600160a01b0384163314156151ed565b506001600160a01b0382163314156151e7565b9196929395946001906152a881611bb9565b1180615340575b8061532d575b6152c3575b50505050505050565b6080820151511580615324575b156152ed5750506152e19450614cbf565b388080808080806152ba565b6000945084939550614d0961531f976152546040519384926020840196630331315760e41b8852338c60248701615075565b6152e1565b508051156152d0565b506001600160a01b0385163314156152b5565b506001600160a01b0383163314156152af565b156153a057600060203d14615395575b6001600160e01b031916633c78b38960e21b0161537d5750565b60249060405190633ed4053f60e21b82526004820152fd5b602081803e51615363565b6024906153ab6123fc565b60405190633ed4053f60e21b82526004820152fdfea2646970667358221220a45401c2d5b850ed055b2c9004ef4d81d758f2c3fbf33657e1ea46bb19ec3f9c64736f6c634300080e0033",
  "deployedBytecode": "0x60806040526004361015610013575b600080fd5b60003560e01c806306fdde031461013f57806346423aa71461013657806355944a421461012d5780635b34b9661461012457806379df72bd1461011b57806387201b41146101125780638814773214610109578063a817440414610100578063b3a34c4c146100f7578063e7acab24146100ee578063ed98a574146100e5578063f07ec373146100dc578063f47b7740146100d3578063fb0f3ee1146100ca5763fd9f1e10146100c257600080fd5b61000e611269565b5061000e610fb7565b5061000e610f30565b5061000e610eeb565b5061000e610e5a565b5061000e610dac565b5061000e610d48565b5061000e610cd7565b5061000e610ba6565b5061000e610ad2565b5061000e610957565b5061000e6108f2565b5061000e610861565b5061000e6101c7565b5061000e610199565b91908251928382526000905b848210610181575092806020939411610174575b601f01601f1916010190565b6000838284010152610168565b90602090818082850101519082860101520190610154565b503461000e57600036600319011261000e57602080526d0d436f6e73696465726174696f6e604d5260606020f35b503461000e57602036600319011261000e57600435600052600260205260806040600020546040519060ff81161515825260ff8160081c16151560208301526001600160781b038160101c16604083015260881c6060820152f35b50634e487b7160e01b600052604160045260246000fd5b60a0810190811067ffffffffffffffff82111761025557604052565b61025d610222565b604052565b60c0810190811067ffffffffffffffff82111761025557604052565b6020810190811067ffffffffffffffff82111761025557604052565b6040810190811067ffffffffffffffff82111761025557604052565b90601f8019910116810190811067ffffffffffffffff82111761025557604052565b60405190610160820182811067ffffffffffffffff82111761025557604052565b6040519061030682610239565b565b60209067ffffffffffffffff8111610322575b60051b0190565b61032a610222565b61031b565b6001600160a01b0381160361000e57565b60a435906103068261032f565b35906103068261032f565b3590600682101561000e57565b92919261037182610308565b604094610380865192836102b6565b819584835260208093019160a080960285019481861161000e57925b8584106103ac5750505050505050565b868483031261000e5784879184516103c381610239565b6103cc87610358565b8152828701356103db8161032f565b838201528587013586820152606080880135908201526080808801359082015281520193019261039c565b9080601f8301121561000e5781602061042193359101610365565b90565b92919261043082610308565b60409461043f865192836102b6565b819584835260208093019160c080960285019481861161000e57925b85841061046b5750505050505050565b868483031261000e57848791845161048281610262565b61048b87610358565b81528287013561049a8161032f565b838201528587013586820152606080880135908201526080808801359082015260a080880135906104ca8261032f565b82015281520193019261045b565b9080601f8301121561000e5781602061042193359101610424565b6004111561000e57565b3590610306826104f3565b9190916101608184031261000e5761051e6102d8565b926105288261034d565b84526105366020830161034d565b602085015267ffffffffffffffff90604083013582811161000e578161055d918501610406565b6040860152606083013591821161000e576105799183016104d8565b606084015261058a608082016104fd565b608084015260a081013560a084015260c081013560c084015260e081013560e0840152610100808201359084015261012080820135908401526101408091013590830152565b35906001600160781b038216820361000e57565b92919267ffffffffffffffff821161062c575b6040519161060f601f8201601f1916602001846102b6565b82948184528183011161000e578281602093846000960137010152565b610634610222565b6105f7565b9080601f8301121561000e57816020610421933591016105e4565b91909160a08184031261000e576106696102f9565b9267ffffffffffffffff823581811161000e5782610688918501610508565b8552610696602084016105d0565b60208601526106a7604084016105d0565b6040860152606083013581811161000e57826106c4918501610639565b6060860152608083013590811161000e576106df9201610639565b6080830152565b9080601f8301121561000e578135906106fe82610308565b9261070c60405194856102b6565b828452602092838086019160051b8301019280841161000e57848301915b84831061073a5750505050505090565b823567ffffffffffffffff811161000e57869161075c84848094890101610654565b81520192019161072a565b9181601f8401121561000e5782359167ffffffffffffffff831161000e576020808501948460051b01011161000e57565b50634e487b7160e01b600052602160045260246000fd5b600611156107b957565b610306610798565b60809080516107cf816107af565b8352816001600160a01b03918260208201511660208601526040810151604086015260608101516060860152015116910152565b90815180825260208080930193019160005b828110610823575050505090565b909192938260e06001926040885161083c8382516107c1565b808501516001600160a01b031660a0840152015160c082015201950193929101610815565b50606036600319011261000e5767ffffffffffffffff60043581811161000e5761088f9036906004016106e6565b9060243581811161000e576108a8903690600401610767565b60443592831161000e576108ee936108d46108ca6108da953690600401610767565b9490933691611a50565b9061379a565b604051918291602083526020830190610803565b0390f35b503461000e57600036600319011261000e5761090c6147c0565b3360005260016020526020604060002060018154018091556040518181527f721c20121297512b72821b97f5326877ea8ecf4bb9948fea5bfcb6453074d37f833392a2604051908152f35b503461000e5760031960203682011261000e5760043567ffffffffffffffff811161000e576101608160040192823603011261000e5761099682611434565b916109a360248301611434565b906109b16044840182611b4d565b6064850192916109c18484611b83565b929093608488016109d190611bc3565b956109db91611b83565b9690506109e66102d8565b6001600160a01b0390991689526001600160a01b031660208901523690610a0c92610365565b60408701523690610a1c92610424565b6060850152610a2e9060808501611bcd565b60a482013560a084015260c482013560c084015260e482013560e08401526101048201356101008401526101248201356101208401526101408301526101440135610a78916121f1565b604051908152602090f35b9092916040820191604081528451809352606081019260208096019060005b818110610abc575050506104219394818403910152610803565b8251151586529487019491870191600101610aa2565b5060e036600319011261000e5767ffffffffffffffff60043581811161000e57610b009036906004016106e6565b60243582811161000e57610b18903690600401610767565b909160443584811161000e57610b32903690600401610767565b9060643595861161000e57610b4e610b67963690600401610767565b929091610b59610340565b9560c4359760843596611b13565b906108ee60405192839283610a83565b602060031982011261000e576004359067ffffffffffffffff821161000e57610ba291600401610767565b9091565b503461000e57610bb536610b77565b610bbd6147c0565b60005b818110610bd35760405160018152602090f35b80610be1600192848661388c565b610beb8180613fa9565b610bf481611434565b91610c07610c023684610508565b614752565b91610c1c836000526002602052604060002090565b610c268185614b98565b50610c39610c35825460ff1690565b1590565b610c49575b505050505001610bc0565b7ffde361574a066b44b3b5fe98a87108b7565e327327954c4faeea56a4e6491a0a92610cca92610ca6610cac93610c99610c92610c8b60209687810190611474565b36916105e4565b898b6149e6565b805460ff19166001179055565b01611434565b6040519384526001600160a01b039081169416929081906020820190565b0390a33880808080610c3e565b50604036600319011261000e5767ffffffffffffffff60043581811161000e57610d05903690600401610767565b60249291923591821161000e576108ee92610d32610d2a6108da943690600401610767565b93909261402e565b60405190610d3f8261027e565b6000825261379a565b5060031960403682011261000e576004359067ffffffffffffffff821161000e57604090823603011261000e57610da2610d86602092600401613fbf565b60405190610d938261027e565b60008252339160243591613b28565b6040519015158152f35b5060031960803682011261000e576004359067ffffffffffffffff9081831161000e5760a090833603011261000e5760243590811161000e576108ee91610dfa610e3b923690600401610767565b90606435610e078161032f565b6001600160a01b038116610e4d5750610e35610e2933945b3690600401610654565b91604435933691611a50565b90613b28565b60405190151581529081906020820190565b610e29610e359194610e1f565b5060a036600319011261000e5767ffffffffffffffff60043581811161000e57610e88903690600401610767565b9060243583811161000e57610ea1903690600401610767565b91909260443594851161000e57610eca610ec2610b67963690600401610767565b92909361402e565b9160405193610ed88561027e565b6000855260843595339560643595612572565b503461000e57602036600319011261000e576020610f28600435610f0e8161032f565b6001600160a01b0316600052600160205260406000205490565b604051908152f35b503461000e57600036600319011261000e57610f7e610f4d61231b565b60405190610f5a8261029a565b6003825262312e3160e81b6020830152604051928392606084526060840190610148565b9060208301526001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001660408301520390f35b5060031960203682011261000e5760043567ffffffffffffffff811161000e576102408160040192823603011261000e5761012435908160021c9260018411933415850361124d57849360038211600283149161103e8360028611600119870102018815926001820185028460011b880103998a92600360a088026024013593168a6114a7565b6110508260051b6101c40135986107af565b1561110a5750505061107061106482611434565b6001600160a01b031690565b6001600160a01b039081166024840135176110f8576110cc6044946110c76110e2976110d8946110a260a48901611434565b9060648901946110b186611434565b9060e48b01359360c48c01359333931691611be4565b611434565b9161020484019061143e565b9390920135611861565b6110ec6001600055565b60405160018152602090f35b604051636ab37ce760e01b8152600490fd5b9194509161117361106460646111789661117d9961112661141b565b8a819b99611134839b6107af565b156111825750610ca69161114a60a48501611434565b611155868601611434565b9060e48601359160c4870135916001600160a01b0333921690611e18565b611916565b611f6a565b6110e2565b61118b816107af565b600381036111d257506111cd916111a460a48501611434565b6111af868601611434565b9060e48601359160c4870135916001600160a01b0333921690611eb9565b610ca6565b806111de6004926107af565b03611218576111cd916111f088611434565b6111fb868601611434565b6044860135916001600160a01b0360248801359216903390611e18565b6111cd9161122588611434565b611230868601611434565b6044860135916001600160a01b0360248801359216903390611eb9565b604051630a61be9f60e41b8152346004820152602490fd5b0390fd5b503461000e5761127836610b77565b6112806147c0565b60005b8181106112965760405160018152602090f35b6112a181838561478b565b6112aa81611434565b6020906112b8828401611434565b6001600160a01b039182811693843314158061140f575b6113fd576040956112e281880182611b4d565b6060808401926112f28486611b83565b90916080948a86890161130490611bc3565b9761130f908a611b83565b9a905061131a6102d8565b6001600160a01b03909c168c526001600160a01b03909116908b0152369061134192610365565b8c890152369061135092610424565b9086015284019061136091611bcd565b60a0808201359084015260c0808201359084015260e0808201359084015261010080820135908401526101208082013590840152610140918284015201356113a7916121f1565b936113bc856000526002602052604060002090565b805461ffff19166101001790555193845216917f6bacc01dbe442496068f7d234edd811f1a5f833243e0aec824f86ab861f3c90d90602090a3600101611283565b60405163203b1cdd60e21b8152600490fd5b508383163314156112cf565b604051906114288261029a565b60208083523683820137565b356104218161032f565b903590601e198136030182121561000e570180359067ffffffffffffffff821161000e57602001918160061b3603831361000e57565b903590601e198136030182121561000e570180359067ffffffffffffffff821161000e5760200191813603831361000e57565b9591906114b26147b1565b6114c6610140880135610120890135614991565b506114cf6117da565b6114ed6114e061020089018961143e565b6101e08a013591506117c1565b7f00000000000000000000000000000000000000000000000000000000000000006080528160a0526060602460c037604060646101203760e06080908120610160526001610264359081016102a060059290921b918201526102c081019384526024906102e00137610160928460a0528560c052600060e05260005b8394610204358210156115c65790604060a0600193602090818560061b6102840161010037838560061b6102840161012037019660e0608020885201968888528960c08201526101008360061b6102840191013701939293611569565b5090929350969590966001610204350160051b610160206060525b83610264358210156116145790604060a060019301958787528860c08201526101008360061b61028401910137016115e1565b505093509490506103069391507f00000000000000000000000000000000000000000000000000000000000000006080528260a052606060c460c03760206101046101203760c0608020600052602060002060e05260016102643560051b610200015261022092836102643560051b0152606060c46102406102643560051b01376117b9610c8b608435936116bc856001600160a01b03166000526001602052604060002090565b547f00000000000000000000000000000000000000000000000000000000000000006080526040608460a03760605161010052846101205260a0610144610140376101e0526101809485608020956102643560051b0190868252336101a06102643560051b015260806101c06102643560051b01526101206101e06102643560051b01527f9d9af8e38d66c62e2c12f0225249fd9d721c54b83f48d9352c97c6cacdcb6f3160a4359260a061026435026101e00190a360006060526117b0606082016110c761178a82611434565b9661179760808601611434565b906001600160a01b03809916906101608701358b614c52565b95810190611474565b9216906140ba565b106117c857565b604051632335530b60e11b8152600490fd5b601861012435106102643560061b61026001610244351461024061022435146020600435141616161561180957565b6040516339f3e3fd60e01b8152600490fd5b50634e487b7160e01b600052603260045260246000fd5b901561183b5790565b61042161181b565b9190811015611854575b60061b0190565b61185c61181b565b61184d565b919234936000915b8083106118ac5750505082821161189a578161188491611c7b565b80821161188f575050565b610306910333611c7b565b604051631a783b8d60e01b8152600490fd5b9091946118ba868385611843565b9081359080821161189a576118de82602060019501356118d98161032f565b611c7b565b0395019190611869565b50634e487b7160e01b600052601160045260246000fd5b81811061190a570390565b6119126118e8565b0390565b909392919081156119d657933361192f60a08301611434565b60e08301359260c08101355b6110f8578460051b6101e40335946102008201611958818461143e565b93905060005b848110611975575050505050956103069596611cdf565b8989858e61198d85611987898961143e565b90611843565b8035926119bb575b916119b593916119ae6110646020600199989601611434565b908c611cdf565b0161195e565b92909493919b8c6119cb916118ff565b9b9193949092611995565b9333946119e282611434565b604083013592602081013561193b565b81601f8201121561000e57803591611a0983610308565b92611a1760405194856102b6565b808452602092838086019260051b82010192831161000e578301905b828210611a41575050505090565b81358152908301908301611a33565b909291611a5c84610308565b91604094611a6c865194856102b6565b839581855260208095019160051b83019380851161000e5783925b858410611a975750505050505050565b67ffffffffffffffff90843582811161000e5786019060a08285031261000e578451611ac281610239565b8235815289830135600281101561000e578a82015285830135868201526060808401359082015260808084013594851161000e57611b04868c968796016119f2565b90820152815201930192611a87565b90611b4190610ba29a99989796959493986001600160a01b03811615600014611b47575033985b3691611a50565b90612572565b98611b3a565b903590601e198136030182121561000e570180359067ffffffffffffffff821161000e576020019160a082023603831361000e57565b903590601e198136030182121561000e570180359067ffffffffffffffff821161000e576020019160c082023603831361000e57565b600411156107b957565b35610421816104f3565b6004821015611bd95752565b611be1610798565b52565b949290959391841515600014611c37576103069660405196632671a55160e11b8852602060048901526001602489015260448801526064870152608486015260a485015260c484015260e4830152612082565b9291946002919450611c48816107af565b03611c6f57600103611c5d57610306936147de565b60405163efcc00b160e01b8152600490fd5b929190610306946148a1565b90611c8581611cc6565b600080808084865af115611c97575050565b60449250611ca36123fc565b6001600160a01b036040519263470c7c1d60e01b84521660048301526024820152fd5b15611ccd57565b60405163246cf94560e21b8152600490fd5b929193949094611cee83611cc6565b611cf88183611f57565b80611e0a575050604051926000946323b872dd60e01b865280600452816024528260445260208660648180885af1803d15601f3d1160018a51141617163d1515811615611d4e575b505050505050604052606052565b80863b151516611d4057908795969115611d7657632f8aeb3960e11b86526004879052602486fd5b15611d975750608494639889192360e01b8552600452602452604452606452fd5b3d611dbd575b5060a49463f486bc8760e01b855260045260245260445281606452608452fd5b601f3d0160051c9060051c908060030291808211611df1575b505060205a910110611de85785611d9d565b833d81803e3d90fd5b8080600392028380020360091c92030201018680611dd6565b90610306959294939161217c565b95909294939193611e298183611f57565b80611e40575050600103611c5d57610306936147de565b906064959391600097959397506020825114600014611ea65760c090600190604084526020840152632671a55160e11b60408401526020604484015280888401525b0201936002603b19860152601b198501526004840152602483015260448201520152565b5060c08682016001815101809152611e82565b959091929394611ec886611cc6565b611ed28183611f57565b80611ee2575050610306946148a1565b9060649596949392916020825114600014611f445760c090600190604084526020840152632671a55160e11b60408401526020604484015280888401525b0201936003603b19860152601b198501526004840152602483015260448201520152565b5060c08682016001815101809152611f20565b90602082015103611f655750565b610306905b60408082510361207e57602082015160c06064840151026044019180519260206001600160a01b036000928184927f00000000000000000000000000000000000000000000000000000000000000001660ff60a01b1783528684527f000000000000000000000000000000000000000000000000000000000000000086526055600b201696855281805284880182885af19051901561204c576001600160e01b03191663598e5aaf60e11b016120235750505060209052565b51630e7ccd9360e11b815260048101919091526001600160a01b03919091166024820152604490fd5b61126584836120596123fc565b5163344f54f560e21b81526001600160a01b0390911660048201529081906024820190565b5050565b6040519160206001600160a01b036101046000938285937f00000000000000000000000000000000000000000000000000000000000000001660ff60a01b1784528685527f00000000000000000000000000000000000000000000000000000000000000006040526055600b20169660405282805282875af190519015612149576001600160e01b03191663598e5aaf60e11b0161211e575050565b604051630e7ccd9360e11b815260048101919091526001600160a01b03919091166024820152604490fd5b611265836121556123fc565b60405163344f54f560e21b81526001600160a01b0390911660048201529081906024820190565b9060649492939160208251146000146121de5760c090600190604084526020840152632671a55160e11b60408401526020604484015280878401525b0201926001603b19850152601b1984015260048301526024820152600060448201520152565b5060c085820160018151018091526121b8565b91909161014081018051917f0000000000000000000000000000000000000000000000000000000000000000604051604083018051928351926020809501906000915b868684106122f85750505050506040519160051b8220917f00000000000000000000000000000000000000000000000000000000000000009093606086019481865101906000915b8a83106122d45750505050508560051b6040512093601f1901978851907f00000000000000000000000000000000000000000000000000000000000000008a5282519383528451958552865261018089209852525252565b8380600192601f1981510180519089815260e081208752520192019201919061227c565b80600192601f1981510180519088815260c0812087525201920192019190612234565b467f000000000000000000000000000000000000000000000000000000000000000003612366577f000000000000000000000000000000000000000000000000000000000000000090565b60405160208101907f000000000000000000000000000000000000000000000000000000000000000082527f000000000000000000000000000000000000000000000000000000000000000060408201527f000000000000000000000000000000000000000000000000000000000000000060608201524660808201523060a082015260a081526123f681610262565b51902090565b3d61240357565b601f3d0160051c60405160051c908060030291808211612436575b505060205a91011061242c57565b3d6000803e3d6000fd5b8080600392028380020360091c9203020101388061241e565b919082604091031261000e576040516040810181811067ffffffffffffffff821117612489575b6040526020808294803584520135910152565b612491610222565b612476565b9291926124a282610308565b6040926124b1845192836102b6565b819581835260208093019160061b84019381851161000e57915b8483106124da57505050505050565b8386916124e7848661244f565b8152019201916124cb565b929190926124ff84610308565b9161250d60405193846102b6565b829480845260208094019060051b83019282841161000e5780915b84831061253757505050505050565b823567ffffffffffffffff811161000e57820184601f8201121561000e5786916125678683858095359101612496565b815201920191612528565b9698979261258d8a61259c969561259495949998998b612790565b36916124f2565b9336916124f2565b9082518251916125b46125af8484612c25565b613068565b9760009586915b848310612696575050506000935b83851061260e57505050505080612603575b508251156125f157826125ed916134af565b9190565b60405163d5da9a1b60e01b8152600490fd5b8351038352386125db565b90919293948861262984612622898661276e565b518a613129565b8051608001516001600160a01b03166001600160a01b0361265761106460208501516001600160a01b031690565b9116036126715750506001809101955b01939291906125c9565b87916126909161268985896001979c0103809361276e565b528b61276e565b50612667565b9091968a6126b4836126ad8b879b98999a9b61276e565b518c6130c5565b8051608001516001600160a01b03166001600160a01b036126e261106460208501516001600160a01b031690565b9116036126ff5750506001809101975b01919095949392956125bb565b899161271c91612715856001969d03809361276e565b528d61276e565b506126f2565b9061272c82610308565b61273960405191826102b6565b828152809261274a601f1991610308565b0190602036910137565b602090805115612762570190565b61276a61181b565b0190565b6020918151811015612783575b60051b010190565b61278b61181b565b61277b565b9392909161279c6147b1565b8451926127a884612722565b9160008352601d604560003560e01c061160011b9060005b868110612868575050600314612856576127da9086612d09565b60005b8381106127ec57505050509050565b806127f96001928461276e565b51156128515761284b61280c828961276e565b5151612818838661276e565b51908661282c82516001600160a01b031690565b60208301516001600160a01b0316906060604085015194015194613ee0565b016127dd565b61284b565b6040516312d3f5a360e01b8152600490fd5b612872818a61276e565b519180156129d757612885868685614487565b92909160018501895282156129c35761289e858a61276e565b52600019019380519260a084015193604060c08201519101518051908560005b8381106129585750505050606080935101519485519560005b8781106128f05750505050505050506001905b016127c0565b808760a06129006001948661276e565b518861293c89898d608086019761291989518783612cb6565b918701958651908a518214600014612948575050508085525b8088528451612c7a565b905201519052016128d7565b61295192612cb6565b8552612932565b612962818461276e565b519b8c5115179b86868b6080840193845161297e908589612cb6565b60608192019586519881518a14600014996129a99760019b6129b3575050508187525b528451612c39565b90520186906128be565b6129bc92612cb6565b87526129a1565b5093600193925060009150602001526128ea565b919060006020600193015281810186526128ea565b6129f46147b1565b805192612a0084612722565b92600091828552601d6045843560e01c061160011b90835b878110612aa857505060031461285657612a329083612d09565b838110612a3f5750505050565b80612a4c6001928561276e565b5115612aa357612a9d612a5f828561276e565b5151612a6b838761276e565b5190612a7e81516001600160a01b031690565b60208201516001600160a01b0316906060604084015193015193613e0e565b01612a32565b612a9d565b612ab2818761276e565b5191858115612bf35750612ac7888685614699565b929091600185018b52888315612be15750612ae2858c61276e565b52600019019380519260a084015191604060c0860151950151805190858c5b838110612b875750505050606090510151938451948a5b868110612b3057505050505050506001905b01612a18565b80612b3d6001928461276e565b5160a0608082019189612b7b888b612b5787518d86612cb6565b60608601948d8651908a518214600014612948575050508085528088528451612c7a565b90520151905201612b18565b612b91818461276e565b519b8c5115179b868a8960808401938451612bad908589612cb6565b60608192019586519881518a1460001499612bd79760019b6129b357505050818752528451612c39565b9052018690612b01565b92505093600193925060200152612b2a565b6020600193929401528181018852612b2a565b8060001904821181151516612c19570290565b612c216118e8565b0290565b81198111612c31570190565b61276a6118e8565b9092838203612c485750505090565b829391612c64612c7094612c6a93039542039182870390612c06565b92612c06565b90612c25565b9081049015150290565b9092838203612c895750505090565b92612c6a612ca792612c648560019697039642039182880390612c06565b91600019830104019015150290565b919091828114612ce65782818309612cd557612cd191612c06565b0490565b63c63cf08960e01b60005260046000fd5b50905090565b600211156107b957565b51610421816107af565b611be1826107af565b815181519260005b828110612e205750505060005b828110612d2a57505050565b612d34818361276e565b51612d58612d4c60208301516001600160781b031690565b6001600160781b031690565b15612e175751606081018051519060005b828110612dcf575050506040809101908151519160005b838110612d9557505050506001905b01612d1e565b612db2612dac612da683855161276e565b51612cf6565b60031090565b612dbe57600101612d80565b825163a6cfc67360e01b8152600490fd5b612de0612dac612da683855161276e565b612dec57600101612d69565b6040517fff75a340000000000000000000000000000000000000000000000000000000008152600490fd5b50600190612d8f565b612e2a818361276e565b5180519086821015612f9057602091612e59612d4c84612e4a848b61276e565b5101516001600160781b031690565b15612f8557612e68908761276e565b5151916040928383015191830151612e7f81612cec565b612e8881612cec565b612f28578301518051821015612f175790612ea29161276e565b51916003835193612eb2856107af565b8490612ec984820191600483519814850390612d00565b606085015190525b1115612f075750906001929181612eec575b50505b01612d11565b612f00916080606083015192015191612fa2565b3880612ee3565b51634a75b57b60e11b8152600490fd5b8351635fd9fc6760e11b8152600490fd5b92906060809401518051821015612f7457600391612f459161276e565b5193845194612f53866107af565b8591612f6a85830192600484519914860390612d00565b8501519052612ed1565b82516330446bef60e11b8152600490fd5b505050600190612ee6565b6040516321a561b160e21b8152600490fd5b91909160009081526020808220928181019282825192600593841b0101915b828510612fe657505050505003612fd457565b6040516309bde33960e01b8152600490fd5b8451808711821b96875295841895909552604081209493830193612fc1565b604051906060820182811067ffffffffffffffff82111761305b575b8060405260408361303183610239565b6000928381528360808301528360a08301528360c08301528360e083015281528260208201520152565b613063610222565b613021565b9061307282610308565b61307f60405191826102b6565b8281528092613090601f1991610308565b019060005b8281106130a157505050565b6020906130ac613005565b82828501015201613095565b906002821015611bd95752565b9092916130d0613005565b93805115613110576130f2926001600160a01b0386931660808451015261319c565b81516060810151156131015750565b60806000918260208601520152565b60405163375c24c160e01b815260006004820152602490fd5b929190613134613005565b9381511561317157613147918591613344565b60208301903382526040840152825190606082015115613165575050565b60009182608092520152565b60405163375c24c160e01b815260016004820152602490fd5b50637fda727960e01b60005260046000fd5b929192602082019060208251518251811015613337575b60051b8201015192835192602060408501518183510151815181101561332a575b60051b010151600094602086970151613314575b9061012060609260408b5193805185526020810151602086015201516040840152805160208c0152015160408a01522091805160051b01905b81811061325b5750505050606082939451015261323b5750565b60011461324a576103066118e8565b63246cf94560e21b60005260046000fd5b602090959495019060208251518551811015613307575b60051b850101516020810151156132fe5751606060206040830151818651015181518110156132f1575b60051b01015196818801519081158a8381011060011b17179801966000828201522084149060408a0151610120820151149060208b01519051141616156132e4575b90613221565b6132ec61318a565b6132de565b6132f961318a565b61329c565b509493946132de565b61330f61318a565b613272565b60608201805160009091528015975095506131e8565b61333261318a565b6131d4565b61333f61318a565b6131b3565b92916020808301948551519181518310156134a2575b80600593841b8301015194606093828588510151818b5101518151811015613495575b831b010151926000968188990151613480575b51948451865281850151828701526040850151604087015260a0809501519a608087019b8c52878720948051851b01905b8181106133dc575050505050505083949550015261323b5750565b83909a999a01908c848351518551811015613473575b871b850101518581015115613469578a86915101518185510151815181101561345c575b881b0101518a81019b8d8d518091019e8f9115911060011b17179c9b60009052888b82208914925191015114161561344f575b906133c1565b61345761318a565b613449565b61346461318a565b613416565b5050999899613449565b61347b61318a565b6133f2565b84870180516000909152801599509750613390565b61349d61318a565b61337d565b6134aa61318a565b61335a565b9081516134bb81612722565b9260005b82811061357f5750505034906134d361141b565b9080519060005b82811061350e575050506134ed90611f6a565b806134fe575b506104216001600055565b6135089033611c7b565b386134f3565b613518818361276e565b518051908151613527816107af565b613530816107af565b15613564575b8560019392826040613555602061355e9601516001600160a01b031690565b91015191613627565b016134da565b956060829392018181511161189a5751900395909190613536565b613589818361276e565b516135a1612d4c60208301516001600160781b031690565b1561361e576135b96135b3838861276e565b60019052565b606080915101519081519160005b8381106135dc57505050506001905b016134bf565b826135e7828461276e565b510151806135f857506001016135c7565b6040516314bea84160e31b81526004810187905260248101929092526044820152606490fd5b506001906135d6565b9290918351613635816107af565b61363e816107af565b6136935750505061365c61106460208301516001600160a01b031690565b6001600160a01b0360408301519116176110f85780606061368a60806103069401516001600160a01b031690565b91015190611c7b565b909192600181516136a3816107af565b6136ac816107af565b036136fc5760408101516110f857610306936136d260208301516001600160a01b031690565b906001600160a01b0360606136f160808601516001600160a01b031690565b940151931691611cdf565b926002845161370a816107af565b613713816107af565b03613759578361373060206103069601516001600160a01b031690565b60808201516001600160a01b0316926001600160a01b0360606040850151940151941691611e18565b8361377160206103069601516001600160a01b031690565b60808201516001600160a01b0316926001600160a01b0360606040850151940151941691611eb9565b906137ac9094939294825190836129ec565b6137b582613068565b9160009485915b8083106137e957505050906137da91848294956137de575b506134af565b5090565b8251038252386137d4565b9091956137f787838561388c565b61381d613804828061143e565b906138146020948581019061143e565b929091896138c7565b906001600160a01b0361385261106461384260808651016001600160a01b0390511690565b938501516001600160a01b031690565b91160361386957506001809101965b0191906137bc565b96613886829860019383039061387f828a61276e565b528761276e565b50613861565b91908110156138af575b60051b81013590603e198136030182121561000e570190565b6138b761181b565b613896565b61042190369061244f565b929093916138d3613005565b9481158015613a89575b613a77576138e9613005565b6138fe816138f8368888612496565b88613344565b51916139158761390f368486612496565b8861319c565b61391f8751612cf6565b83519061392b826107af565b613934826107af565b61393d816107af565b14801590613a3f575b8015613a2c575b613a1a57610421956139ca95608095896060948588019687518784510151106000146139dd5750505061398c61398785936139b293611832565b6138bc565b6020836139a58d828a519151015190039684519061276e565b515101519101519061276e565b5101528651015190525b01516001600160a01b031690565b6080835101906001600160a01b03169052565b8697969450613a0c93506139a5856139fc613987602095604095611832565b945101518851855191039761276e565b5101525190865101526139bc565b6040516309cfb45560e01b8152600490fd5b506040875101516040840151141561394d565b508651602001516001600160a01b03166001600160a01b03613a6e61106460208701516001600160a01b031690565b91161415613946565b604051634c74edb760e11b8152600490fd5b5083156138dd565b60405190613a9e82610239565b604051608083610160830167ffffffffffffffff811184821017613b1b575b6040526000808452806020850152606093846040820152848082015281848201528160a08201528160c08201528160e08201528161010082015281610120820152816101408201528252806020830152604082015282808201520152565b613b23610222565b613abd565b909291613b336147c0565b6002600055613b428483614166565b9490919260405195613b538761029a565b6001875260005b602080821015613b7c5790602091613b70613a91565b90828b01015201613b5a565b5050613bb0839597613bab613bc99a613bb99799835115613be5575b6020840152825115613bd8575b82612d09565b612754565b51519586613bf2565b81516001600160a01b031661282c565b613bd36001600055565b600190565b613be061181b565b613ba5565b613bed61181b565b613b98565b939192909360a093848201519360c083015196613c0d61141b565b96604092838601908151519160005b838110613cea575050505034986060809601978851519860005b8a8110613c63575050505050505050505050613c5190611f6a565b80613c595750565b6103069033611c7b565b613c6e81835161276e565b518981018051613c8887878d8c6080880195865190613d9c565b8092528783015190528151613c9c816107af565b613ca5816107af565b15613cc2575b5090613cbc8d8c6001943390613627565b01613c36565b90919e9d808211613cd9579d9e9d039c908a613cab565b8851631a783b8d60e01b8152600490fd5b613cf581835161276e565b518051613d01816107af565b613d0a816107af565b15613d545790613d4e8d8f93868f8d613d366001988e9360608701938451956080890196875190613d65565b9052528c61012061355582516001600160a01b031690565b01613c1c565b87516312d3f5a360e01b8152600490fd5b909390848103613d7b5750506104219350612cb6565b9383613d906104219796613d96949686612cb6565b93612cb6565b90612c39565b909390848103613db25750506104219350612cb6565b9383613d906104219796613dc7949686612cb6565b90612c7a565b90815180825260208080930193019160005b828110613ded575050505090565b909192938260a082613e0260019489516107c1565b01950193929101613ddf565b91939290936040805193608091828601918652602090600082880152838188015285518093528160a088019601936000915b848310613e955750505050505091613e90827f9d9af8e38d66c62e2c12f0225249fd9d721c54b83f48d9352c97c6cacdcb6f31948380950360608501526001600160a01b03809116971695613dcd565b0390a3565b90919293949684836001928a518051613ead816107af565b8252808401516001600160a01b031684830152858101518683015260609081015190820152019801959493019190613e40565b92909493916040918251946080918287019187526001600160a01b0394856020921682890152838189015286518093528160a089019701936000915b848310613f65575050505050508282859493613e9093867f9d9af8e38d66c62e2c12f0225249fd9d721c54b83f48d9352c97c6cacdcb6f31989603606087015216971695613dcd565b90919293949784836001928b518051613f7d816107af565b8252808401518c1684830152858101518683015260609081015190820152019901959493019190613f1c565b90359061015e198136030182121561000e570190565b613fc7613a91565b50614011613fe3613fd88380613fa9565b926020810190611474565b613ffa60405194613ff386610239565b3690610508565b8452600160208501526001604085015236916105e4565b60608201526040516140228161027e565b60008152608082015290565b61403782610308565b9161404560405193846102b6565b808352601f1961405482610308565b0160005b8181106140a357505060005b8181106140715750505090565b80614087614082600193858761388c565b613fbf565b614091828761276e565b5261409c818661276e565b5001614064565b6020906140ae613a91565b82828801015201614058565b929190836000526002602052604060002091825460ff8160081c16614139576001600160781b038160101c16614120579460ff710100000000000000000000000000000100019596161561410f575b50505055565b614118926149e6565b388080614109565b60405163ee9e0e6360e01b815260048101879052602490fd5b604051630694555d60e21b815260048101879052602490fd5b90805b61415d575090565b80910680614155565b9091815192614181610c3560a086015160c087015190614991565b61447b5761419c612d4c60208501516001600160781b031690565b936141b4612d4c60408601516001600160781b031690565b948581118015614473575b6144615785811080614449575b614437576142186141dc83614752565b9360e084015160808501516141f081611bb9565b85516001600160a01b0316918761421160208901516001600160a01b031690565b948b6151ce565b61422c836000526002602052604060002090565b9161423a610c358486614b98565b614427578254958460ff881615614400575b5050506001600160781b0390818660101c169560881c968715156000146143ba576001810361438257505085945b856142858883612c25565b11614378575b8661429591612c25565b808287118383111761432a575b50906142f18184936142be61432596600160ff19825416179055565b845470ffffffffffffffffffffffffffffffff001916911660101b70ffffffffffffffffffffffffffffff000016178355565b815470ffffffffffffffffffffffffffffffffff1690861660881b70ffffffffffffffffffffffffffffffffff1916179055565b929190565b969061433d876143439298959498614152565b82614152565b80150180809204970492049480861181841117614362579091386142a2565b634e487b7160e01b600052601160045260246000fd5b808603965061428b565b959096868103614393575b5061427a565b6143ad816143a7896143b3959b9a9b612c06565b98612c06565b97612c06565b943861438d565b835470ffffffffffffffffffffffffffffff000084841660101b1670ffffffffffffffffffffffffffffffffff19909116176001178455909650945061432591906142f1565b606061441661441f94516001600160a01b031690565b920151916149e6565b38808461424c565b5050509150915090600090600090565b60405163a11b63ff60e01b8152600490fd5b506001608083015161445a81611bb9565b16156141cc565b604051632d02959960e11b8152600490fd5b5080156141bf565b50600092508291508190565b9192909282516144a3610c3560a083015160c0840151906149c2565b614689576144be612d4c60208601516001600160781b031690565b6144d5612d4c60408701516001600160781b031690565b958682118015614681575b6144615786821080614669575b61443757614541906144fe84614752565b9460e085015160808601519061451382611bb9565b8761452588516001600160a01b031690565b9361453a60208a01516001600160a01b031690565b958c615296565b614555836000526002602052604060002090565b91614563610c358486614c02565b614427578254958460ff88161561464b575b5050506001600160781b0390818660101c169560881c968715156000146143ba576001810361461f57505085945b856145ae8883612c25565b11614615575b866145be91612c25565b818611828211176145e5575b906142f18184936142be61432596600160ff19825416179055565b956145f761433d878998959498614152565b801501808092049704920494808611818411176143625790916145ca565b80860396506145b4565b959096868103614630575b506145a3565b6143ad816143a789614644959b9a9b612c06565b943861462a565b606061441661466194516001600160a01b031690565b388084614575565b506001608084015161467a81611bb9565b16156144ed565b5081156144e0565b5050915050600090600090600090565b9192909282516146b5610c3560a083015160c084015190614991565b614689576146d0612d4c60208601516001600160781b031690565b6146e7612d4c60408701516001600160781b031690565b95868211801561474a575b6144615786821080614732575b61443757614710906144fe84614752565b614724836000526002602052604060002090565b91614563610c358486614b98565b506001608084015161474381611bb9565b16156146ff565b5081156146f2565b6104219061476b606082015151610140830151906117c1565b80516001600160a01b0316600090815260016020526040902054906121f1565b9091610421928110156147a4575b60051b810190613fa9565b6147ac61181b565b614799565b6147b96147c0565b6002600055565b6001600054036147cc57565b604051637fa8a98760e01b8152600490fd5b9092813b1561488c57604051926000946323b872dd60e01b8652806004528160245282604452858060648180885af11561481e5750505050604052606052565b8593943d614848575b5060a49463f486bc8760e01b85526004526024526044526064526001608452fd5b601f3d0160051c9060051c908060030291808211614873575b505060205a910110611de85785614827565b8080600392028380020360091c92030201018680614861565b50632f8aeb3960e11b60005260045260246000fd5b929093833b1561497c57604051936080519160a0519360c05195600098637921219560e11b8a528060045281602452826044528360645260a06084528960a452898060c48180895af11561490557505050505060805260a05260c052604052606052565b89949550883d61492f575b5060a49563f486bc8760e01b8652600452602452604452606452608452fd5b601f3d0160051c9060051c908060030291808211614963575b505060205a91011061495a5786614910565b843d81803e3d90fd5b8080600392028380020360091c92030201018780614948565b83632f8aeb3960e11b60005260045260246000fd5b42109081156149b7575b506149a557600190565b6040516337bf561360e11b8152600490fd5b90504210153861499b565b42109081156149db575b506149d657600190565b600090565b9050421015386149cc565b9091336001600160a01b03831614614b9357614a0061231b565b9260009361190160f01b85526002526022526042832090836022528380528392815191601f198101805184604103918860018411938415614b28575b50851485151516978815614a72575b505050505050505015614a5b5750565b600490614a666123fc565b634f7fb80d60e01b8152fd5b90919293949596975060408252604319850193845195603f19019660208b60648a519b630b135d3f60e11b9d8e8b528c520188845afa998a614ac3575b505050505252523880808080808080614a4b565b8b5103614ad05780614aaf565b908a913b614b1957614b0a57640101000000821a15614af857632057875960e21b8152600490fd5b602491630f801e8560e11b8252600452fd5b638baa579f60e01b8152600490fd5b634f7fb80d60e01b8252600482fd5b9850506040840180519060608601518b1a99614b5f575b89865288835260208b60808560015afa5083835287865252885138614a3c565b9850601b8160ff1c01987f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82168152614b3f565b505050565b905460ff8160081c16614be9576001600160781b038160101c169081614bc1575b505050600190565b60881c1115614bd1578080614bb9565b602490604051906310fda3e160e01b82526004820152fd5b604051630694555d60e21b815260048101839052602490fd5b906000905460ff8160081c16614c49576001600160781b038160101c169081614c2f575b50505050600190565b60881c1115614c3f578080614c26565b614bd15750600090565b50905050600090565b9092916001906004811015614cb2575b1180614c9f575b80614c8c575b614c7a575b50505050565b614c8393614cbf565b38808080614c74565b506001600160a01b038216331415614c6f565b506001600160a01b038416331415614c69565b614cba610798565b614c62565b6000919290829161030695604051906001600160a01b0360208301936303874c7760e21b8552886024850152336044850152166064830152608482015260848152614d0981610262565b51915afa615353565b90815180825260208080930193019160005b828110614d32575050505090565b909192938260a060019287518051614d49816107af565b8252808401516001600160a01b03168483015260408082015190830152606080820151908301526080908101519082015201950193929101614d24565b90815180825260208080930193019160005b828110614da6575050505090565b909192938260c060019287518051614dbd816107af565b8252808401516001600160a01b039081168584015260408083015190840152606080830151908401526080808301519084015260a091820151169082015201950193929101614d98565b906004821015611bd95752565b6060519081815260208091019160809160005b828110614e35575050505090565b835185529381019392810192600101614e27565b90815180825260208080930193019160005b828110614e69575050505090565b835185529381019392810192600101614e5b565b908082519081815260208091019281808460051b8301019501936000915b848310614eab5750505050505090565b9091929394958480614f01600193601f198682030187528a5180518252614ed884820151858401906130b8565b60408082015190830152606080820151908301526080809101519160a080928201520190614e49565b9801930193019194939290614e9b565b9261505a906001600160a01b03610421969461506794875216602086015260a06040860152805160a08087015261014090614f5782880182516001600160a01b03169052565b6080615049614fae614f968a614f7f6020870151610160809301906001600160a01b03169052565b6040860151906101808d01526102a08c0190614d12565b60608501518b820361013f19016101a08d0152614d86565b614fc0838501516101c08c0190614e07565b60a08401516101e08b015260c08401516102008b015260e08401516102208b015261010094858501516102408c015261012094858101516102608d015201516102808b015261501f602087015160c08c01906001600160781b03169052565b60408601516001600160781b031660e08b01526060860151609f1995868c840301908c0152610148565b930151918784030190870152610148565b8381036060850152614e14565b916080818403910152614e7d565b939061042195936001600160a01b03615067946151c093885216602087015260a06040870152805160a080880152610140906150bc82890182516001600160a01b03169052565b60806151af6151136150fb8b60208601516150e561016091828401906001600160a01b03169052565b61018060408801519201526102a08d0190614d12565b60608501518c820361013f19016101a08e0152614d86565b615125838501516101c08d0190614e07565b60a08401516101e08c015260c08401516102008c015260e08401516102208c015261010094858501516102408d0152610120948c6102608783015191015201516102808c0152615185602087015160c08d01906001600160781b03169052565b60408601516001600160781b031660e08c01526060860151609f1995868d840301908d0152610148565b930151918884030190880152610148565b908482036060860152614e49565b9095919294936001906151e081611bb9565b1180615283575b80615270575b6151fa575b505050505050565b6080810151511580615267575b1561522257506152179450614cbf565b3880808080806151f2565b6000935083929450615254614d09615262976040519283916020830195630331315760e41b8752338b60248601614f11565b03601f1981018352826102b6565b615217565b50855115615207565b506001600160a01b0384163314156151ed565b506001600160a01b0382163314156151e7565b9196929395946001906152a881611bb9565b1180615340575b8061532d575b6152c3575b50505050505050565b6080820151511580615324575b156152ed5750506152e19450614cbf565b388080808080806152ba565b6000945084939550614d0961531f976152546040519384926020840196630331315760e41b8852338c60248701615075565b6152e1565b508051156152d0565b506001600160a01b0385163314156152b5565b506001600160a01b0383163314156152af565b156153a057600060203d14615395575b6001600160e01b031916633c78b38960e21b0161537d5750565b60249060405190633ed4053f60e21b82526004820152fd5b602081803e51615363565b6024906153ab6123fc565b60405190633ed4053f60e21b82526004820152fdfea2646970667358221220a45401c2d5b850ed055b2c9004ef4d81d758f2c3fbf33657e1ea46bb19ec3f9c64736f6c634300080e0033",
  "devdoc": {
    "author": "0age",
    "custom:coauthor": "d1ll0ntransmissions11",
    "custom:version": "1.1",
    "errors": {
      "BadContractSignature()": [
        {
          "details": "Revert with an error when an EIP-1271 call to an account fails."
        }
      ],
      "BadFraction()": [
        {
          "details": "Revert with an error when supplying a fraction with a value of zero      for the numerator or denominator, or one where the numerator exceeds      the denominator."
        }
      ],
      "BadReturnValueFromERC20OnTransfer(address,address,address,uint256)": [
        {
          "details": "Revert with an error when an ERC20 token transfer returns a falsey      value.",
          "params": {
            "amount": "The amount for the attempted ERC20 transfer.",
            "from": "The source of the attempted ERC20 transfer.",
            "to": "The recipient of the attempted ERC20 transfer.",
            "token": "The token for which the ERC20 transfer was attempted."
          }
        }
      ],
      "BadSignatureV(uint8)": [
        {
          "details": "Revert with an error when a signature that does not contain a v      value of 27 or 28 has been supplied.",
          "params": {
            "v": "The invalid v value."
          }
        }
      ],
      "ConsiderationCriteriaResolverOutOfRange()": [
        {
          "details": "Revert with an error when providing a criteria resolver that refers      to an order with a consideration item that has not been supplied."
        }
      ],
      "ConsiderationNotMet(uint256,uint256,uint256)": [
        {
          "details": "Revert with an error if a consideration amount has not been fully      zeroed out after applying all fulfillments.",
          "params": {
            "considerationIndex": "The index of the consideration item on the                           order.",
            "orderIndex": "The index of the order with the consideration                           item with a shortfall.",
            "shortfallAmount": "The unfulfilled consideration amount."
          }
        }
      ],
      "CriteriaNotEnabledForItem()": [
        {
          "details": "Revert with an error when providing a criteria resolver that refers      to an order with an item that does not expect a criteria to be      resolved."
        }
      ],
      "ERC1155BatchTransferGenericFailure(address,address,address,uint256[],uint256[])": [
        {
          "details": "Revert with an error when a batch ERC1155 token transfer reverts.",
          "params": {
            "amounts": "The amounts for the attempted transfer.",
            "from": "The source of the attempted transfer.",
            "identifiers": "The identifiers for the attempted transfer.",
            "to": "The recipient of the attempted transfer.",
            "token": "The token for which the transfer was attempted."
          }
        }
      ],
      "EtherTransferGenericFailure(address,uint256)": [
        {
          "details": "Revert with an error when an ether transfer reverts."
        }
      ],
      "InexactFraction()": [
        {
          "details": "Revert with an error when attempting to apply a fraction as part of      a partial fill that does not divide the target amount cleanly."
        }
      ],
      "InsufficientEtherSupplied()": [
        {
          "details": "Revert with an error when insufficient ether is supplied as part of      msg.value when fulfilling orders."
        }
      ],
      "Invalid1155BatchTransferEncoding()": [
        {
          "details": "Revert with an error when attempting to execute an 1155 batch      transfer using calldata not produced by default ABI encoding or with      different lengths for ids and amounts arrays."
        }
      ],
      "InvalidBasicOrderParameterEncoding()": [
        {
          "details": "Revert with an error when attempting to fill a basic order using      calldata not produced by default ABI encoding."
        }
      ],
      "InvalidCallToConduit(address)": [
        {
          "details": "Revert with an error when a call to a conduit fails with revert data      that is too expensive to return."
        }
      ],
      "InvalidCanceller()": [
        {
          "details": "Revert with an error when attempting to cancel an order as a caller      other than the indicated offerer or zone."
        }
      ],
      "InvalidConduit(bytes32,address)": [
        {
          "details": "Revert with an error when attempting to fill an order referencing an      invalid conduit (i.e. one that has not been deployed)."
        }
      ],
      "InvalidERC721TransferAmount()": [
        {
          "details": "Revert with an error when an ERC721 transfer with amount other than      one is attempted."
        }
      ],
      "InvalidFulfillmentComponentData()": [
        {
          "details": "Revert with an error when an order or item index are out of range      or a fulfillment component does not match the type, token,      identifier, or conduit preference of the initial consideration item."
        }
      ],
      "InvalidMsgValue(uint256)": [
        {
          "details": "Revert with an error when a caller attempts to supply callvalue to a      non-payable basic order route or does not supply any callvalue to a      payable basic order route."
        }
      ],
      "InvalidNativeOfferItem()": [
        {
          "details": "Revert with an error when attempting to fulfill an order with an      offer for ETH outside of matching orders."
        }
      ],
      "InvalidProof()": [
        {
          "details": "Revert with an error when providing a criteria resolver that      contains an invalid proof with respect to the given item and      chosen identifier."
        }
      ],
      "InvalidRestrictedOrder(bytes32)": [
        {
          "details": "Revert with an error when attempting to fill an order that specifies      a restricted submitter as its order type when not submitted by      either the offerer or the order's zone or approved as valid by the      zone in question via a staticcall to `isValidOrder`.",
          "params": {
            "orderHash": "The order hash for the invalid restricted order."
          }
        }
      ],
      "InvalidSignature()": [
        {
          "details": "Revert with an error when a signer cannot be recovered from the      supplied signature."
        }
      ],
      "InvalidSigner()": [
        {
          "details": "Revert with an error when the signer recovered by the supplied      signature does not match the offerer or an allowed EIP-1271 signer      as specified by the offerer in the event they are a contract."
        }
      ],
      "InvalidTime()": [
        {
          "details": "Revert with an error when attempting to fill an order outside the      specified start time and end time."
        }
      ],
      "MismatchedFulfillmentOfferAndConsiderationComponents()": [
        {
          "details": "Revert with an error when the initial offer item named by a      fulfillment component does not match the type, token, identifier,      or conduit preference of the initial consideration item."
        }
      ],
      "MissingFulfillmentComponentOnAggregation(uint8)": [
        {
          "details": "Revert with an error when a fulfillment is provided that does not      declare at least one component as part of a call to fulfill      available orders."
        }
      ],
      "MissingItemAmount()": [
        {
          "details": "Revert with an error when attempting to fulfill an order where an      item has an amount of zero."
        }
      ],
      "MissingOriginalConsiderationItems()": [
        {
          "details": "Revert with an error when an order is supplied for fulfillment with      a consideration array that is shorter than the original array."
        }
      ],
      "NoContract(address)": [
        {
          "details": "Revert with an error when an account being called as an assumed      contract does not have code and returns no data.",
          "params": {
            "account": "The account that should contain code."
          }
        }
      ],
      "NoReentrantCalls()": [
        {
          "details": "Revert with an error when a caller attempts to reenter a protected      function."
        }
      ],
      "NoSpecifiedOrdersAvailable()": [
        {
          "details": "Revert with an error when attempting to fulfill any number of      available orders when none are fulfillable."
        }
      ],
      "OfferAndConsiderationRequiredOnFulfillment()": [
        {
          "details": "Revert with an error when a fulfillment is provided that does not      declare at least one offer component and at least one consideration      component."
        }
      ],
      "OfferCriteriaResolverOutOfRange()": [
        {
          "details": "Revert with an error when providing a criteria resolver that refers      to an order with an offer item that has not been supplied."
        }
      ],
      "OrderAlreadyFilled(bytes32)": [
        {
          "details": "Revert with an error when attempting to fill an order that has      already been fully filled.",
          "params": {
            "orderHash": "The order hash on which a fill was attempted."
          }
        }
      ],
      "OrderCriteriaResolverOutOfRange()": [
        {
          "details": "Revert with an error when providing a criteria resolver that refers      to an order that has not been supplied."
        }
      ],
      "OrderIsCancelled(bytes32)": [
        {
          "details": "Revert with an error when attempting to fill an order that has been      cancelled.",
          "params": {
            "orderHash": "The hash of the cancelled order."
          }
        }
      ],
      "OrderPartiallyFilled(bytes32)": [
        {
          "details": "Revert with an error when attempting to fill a basic order that has      been partially filled.",
          "params": {
            "orderHash": "The hash of the partially used order."
          }
        }
      ],
      "PartialFillsNotEnabledForOrder()": [
        {
          "details": "Revert with an error when a partial fill is attempted on an order      that does not specify partial fill support in its order type."
        }
      ],
      "TokenTransferGenericFailure(address,address,address,uint256,uint256)": [
        {
          "details": "Revert with an error when an ERC20, ERC721, or ERC1155 token      transfer reverts.",
          "params": {
            "amount": "The amount for the attempted transfer.",
            "from": "The source of the attempted transfer.",
            "identifier": "The identifier for the attempted transfer.",
            "to": "The recipient of the attempted transfer.",
            "token": "The token for which the transfer was attempted."
          }
        }
      ],
      "UnresolvedConsiderationCriteria()": [
        {
          "details": "Revert with an error if a consideration item still has unresolved      criteria after applying all criteria resolvers."
        }
      ],
      "UnresolvedOfferCriteria()": [
        {
          "details": "Revert with an error if an offer item still has unresolved criteria      after applying all criteria resolvers."
        }
      ],
      "UnusedItemParameters()": [
        {
          "details": "Revert with an error when attempting to fulfill an order where an      item has unused parameters. This includes both the token and the      identifier parameters for native transfers as well as the identifier      parameter for ERC20 transfers. Note that the conduit does not      perform this check, leaving it up to the calling channel to enforce      when desired."
        }
      ]
    },
    "kind": "dev",
    "methods": {
      "cancel((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256)[])": {
        "params": {
          "orders": "The orders to cancel."
        },
        "returns": {
          "cancelled": "A boolean indicating whether the supplied orders have                   been successfully cancelled."
        }
      },
      "constructor": {
        "params": {
          "conduitController": "A contract that deploys conduits, or proxies                          that may optionally be used to transfer approved                          ERC20/721/1155 tokens."
        }
      },
      "fulfillAdvancedOrder(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),uint120,uint120,bytes,bytes),(uint256,uint8,uint256,uint256,bytes32[])[],bytes32,address)": {
        "params": {
          "advancedOrder": "The order to fulfill along with the fraction                            of the order to attempt to fill. Note that                            both the offerer and the fulfiller must first                            approve this contract (or their conduit if                            indicated by the order) to transfer any                            relevant tokens on their behalf and that                            contracts must implement `onERC1155Received`                            to receive ERC1155 tokens as consideration.                            Also note that all offer and consideration                            components must have no remainder after                            multiplication of the respective amount with                            the supplied fraction for the partial fill to                            be considered valid.",
          "criteriaResolvers": "An array where each element contains a                            reference to a specific offer or                            consideration, a token identifier, and a proof                            that the supplied token identifier is                            contained in the merkle root held by the item                            in question's criteria element. Note that an                            empty criteria indicates that any                            (transferable) token identifier on the token                            in question is valid and that no associated                            proof needs to be supplied.",
          "fulfillerConduitKey": "A bytes32 value indicating what conduit, if                            any, to source the fulfiller's token approvals                            from. The zero hash signifies that no conduit                            should be used (and direct approvals set on                            Consideration).",
          "recipient": "The intended recipient for all received items,                            with `address(0)` indicating that the caller                            should receive the items."
        },
        "returns": {
          "fulfilled": "A boolean indicating whether the order has been                   successfully fulfilled."
        }
      },
      "fulfillAvailableAdvancedOrders(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),uint120,uint120,bytes,bytes)[],(uint256,uint8,uint256,uint256,bytes32[])[],(uint256,uint256)[][],(uint256,uint256)[][],bytes32,address,uint256)": {
        "params": {
          "advancedOrders": "The orders to fulfill along with the                                  fraction of those orders to attempt to                                  fill. Note that both the offerer and the                                  fulfiller must first approve this                                  contract (or their conduit if indicated                                  by the order) to transfer any relevant                                  tokens on their behalf and that                                  contracts must implement                                  `onERC1155Received` in order to receive                                  ERC1155 tokens as consideration. Also                                  note that all offer and consideration                                  components must have no remainder after                                  multiplication of the respective amount                                  with the supplied fraction for an                                  order's partial fill amount to be                                  considered valid.",
          "considerationFulfillments": "An array of FulfillmentComponent arrays                                  indicating which consideration items to                                  attempt to aggregate when preparing                                  executions.",
          "criteriaResolvers": "An array where each element contains a                                  reference to a specific offer or                                  consideration, a token identifier, and a                                  proof that the supplied token identifier                                  is contained in the merkle root held by                                  the item in question's criteria element.                                  Note that an empty criteria indicates                                  that any (transferable) token                                  identifier on the token in question is                                  valid and that no associated proof needs                                  to be supplied.",
          "fulfillerConduitKey": "A bytes32 value indicating what conduit,                                  if any, to source the fulfiller's token                                  approvals from. The zero hash signifies                                  that no conduit should be used (and                                  direct approvals set on Consideration).",
          "maximumFulfilled": "The maximum number of orders to fulfill.",
          "offerFulfillments": "An array of FulfillmentComponent arrays                                  indicating which offer items to attempt                                  to aggregate when preparing executions.",
          "recipient": "The intended recipient for all received                                  items, with `address(0)` indicating that                                  the caller should receive the items."
        },
        "returns": {
          "availableOrders": "An array of booleans indicating if each order                         with an index corresponding to the index of the                         returned boolean was fulfillable or not.",
          "executions": "     An array of elements indicating the sequence of                         transfers performed as part of matching the given                         orders."
        }
      },
      "fulfillAvailableOrders(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),bytes)[],(uint256,uint256)[][],(uint256,uint256)[][],bytes32,uint256)": {
        "params": {
          "considerationFulfillments": "An array of FulfillmentComponent arrays                                  indicating which consideration items to                                  attempt to aggregate when preparing                                  executions.",
          "fulfillerConduitKey": "A bytes32 value indicating what conduit,                                  if any, to source the fulfiller's token                                  approvals from. The zero hash signifies                                  that no conduit should be used (and                                  direct approvals set on Consideration).",
          "maximumFulfilled": "The maximum number of orders to fulfill.",
          "offerFulfillments": "An array of FulfillmentComponent arrays                                  indicating which offer items to attempt                                  to aggregate when preparing executions.",
          "orders": "The orders to fulfill. Note that both                                  the offerer and the fulfiller must first                                  approve this contract (or the                                  corresponding conduit if indicated) to                                  transfer any relevant tokens on their                                  behalf and that contracts must implement                                  `onERC1155Received` to receive ERC1155                                  tokens as consideration."
        },
        "returns": {
          "availableOrders": "An array of booleans indicating if each order                         with an index corresponding to the index of the                         returned boolean was fulfillable or not.",
          "executions": "     An array of elements indicating the sequence of                         transfers performed as part of matching the given                         orders."
        }
      },
      "fulfillBasicOrder((address,uint256,uint256,address,address,address,uint256,uint256,uint8,uint256,uint256,bytes32,uint256,bytes32,bytes32,uint256,(uint256,address)[],bytes))": {
        "params": {
          "parameters": "Additional information on the fulfilled order. Note                   that the offerer and the fulfiller must first approve                   this contract (or their chosen conduit if indicated)                   before any tokens can be transferred. Also note that                   contract recipients of ERC1155 consideration items must                   implement `onERC1155Received` in order to receive those                   items."
        },
        "returns": {
          "fulfilled": "A boolean indicating whether the order has been                   successfully fulfilled."
        }
      },
      "fulfillOrder(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),bytes),bytes32)": {
        "params": {
          "fulfillerConduitKey": "A bytes32 value indicating what conduit, if                            any, to source the fulfiller's token approvals                            from. The zero hash signifies that no conduit                            should be used (and direct approvals set on                            Consideration).",
          "order": "The order to fulfill. Note that both the                            offerer and the fulfiller must first approve                            this contract (or the corresponding conduit if                            indicated) to transfer any relevant tokens on                            their behalf and that contracts must implement                            `onERC1155Received` to receive ERC1155 tokens                            as consideration."
        },
        "returns": {
          "fulfilled": "A boolean indicating whether the order has been                   successfully fulfilled."
        }
      },
      "getCounter(address)": {
        "params": {
          "offerer": "The offerer in question."
        },
        "returns": {
          "counter": "The current counter."
        }
      },
      "getOrderHash((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256))": {
        "params": {
          "order": "The components of the order."
        },
        "returns": {
          "orderHash": "The order hash."
        }
      },
      "getOrderStatus(bytes32)": {
        "params": {
          "orderHash": "The order hash in question."
        },
        "returns": {
          "isCancelled": "A boolean indicating whether the order in question                     has been cancelled.",
          "isValidated": "A boolean indicating whether the order in question                     has been validated (i.e. previously approved or                     partially filled).",
          "totalFilled": "The total portion of the order that has been filled                     (i.e. the \"numerator\").",
          "totalSize": "  The total size of the order that is either filled or                     unfilled (i.e. the \"denominator\")."
        }
      },
      "incrementCounter()": {
        "returns": {
          "newCounter": "The new counter."
        }
      },
      "information()": {
        "returns": {
          "conduitController": "The conduit Controller set for this contract.",
          "domainSeparator": "  The domain separator for this contract.",
          "version": "          The contract version."
        }
      },
      "matchAdvancedOrders(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),uint120,uint120,bytes,bytes)[],(uint256,uint8,uint256,uint256,bytes32[])[],((uint256,uint256)[],(uint256,uint256)[])[])": {
        "params": {
          "advancedOrders": "The advanced orders to match. Note that both the                          offerer and fulfiller on each order must first                          approve this contract (or their conduit if                          indicated by the order) to transfer any relevant                          tokens on their behalf and each consideration                          recipient must implement `onERC1155Received` in                          order to receive ERC1155 tokens. Also note that                          the offer and consideration components for each                          order must have no remainder after multiplying                          the respective amount with the supplied fraction                          in order for the group of partial fills to be                          considered valid.",
          "criteriaResolvers": "An array where each element contains a reference                          to a specific order as well as that order's                          offer or consideration, a token identifier, and                          a proof that the supplied token identifier is                          contained in the order's merkle root. Note that                          an empty root indicates that any (transferable)                          token identifier is valid and that no associated                          proof needs to be supplied.",
          "fulfillments": "An array of elements allocating offer components                          to consideration components. Note that each                          consideration component must be fully met in                          order for the match operation to be valid."
        },
        "returns": {
          "executions": "An array of elements indicating the sequence of                    transfers performed as part of matching the given                    orders."
        }
      },
      "matchOrders(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),bytes)[],((uint256,uint256)[],(uint256,uint256)[])[])": {
        "params": {
          "fulfillments": "An array of elements allocating offer components                          to consideration components. Note that each                          consideration component must be fully met in                          order for the match operation to be valid.",
          "orders": "The orders to match. Note that both the offerer                          and fulfiller on each order must first approve                          this contract (or their conduit if indicated by                          the order) to transfer any relevant tokens on                          their behalf and each consideration recipient                          must implement `onERC1155Received` in order to                          receive ERC1155 tokens."
        },
        "returns": {
          "executions": "An array of elements indicating the sequence of                    transfers performed as part of matching the given                    orders."
        }
      },
      "name()": {
        "returns": {
          "contractName": "The name of this contract."
        }
      },
      "validate(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),bytes)[])": {
        "params": {
          "orders": "The orders to validate."
        },
        "returns": {
          "validated": "A boolean indicating whether the supplied orders have                   been successfully validated."
        }
      }
    },
    "title": "Consideration",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "cancel((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256)[])": {
        "notice": "Cancel an arbitrary number of orders. Note that only the offerer         or the zone of a given order may cancel it. Callers should ensure         that the intended order was cancelled by calling `getOrderStatus`         and confirming that `isCancelled` returns `true`."
      },
      "constructor": {
        "notice": "Derive and set hashes, reference chainId, and associated domain         separator during deployment."
      },
      "fulfillAdvancedOrder(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),uint120,uint120,bytes,bytes),(uint256,uint8,uint256,uint256,bytes32[])[],bytes32,address)": {
        "notice": "Fill an order, fully or partially, with an arbitrary number of         items for offer and consideration alongside criteria resolvers         containing specific token identifiers and associated proofs."
      },
      "fulfillAvailableAdvancedOrders(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),uint120,uint120,bytes,bytes)[],(uint256,uint8,uint256,uint256,bytes32[])[],(uint256,uint256)[][],(uint256,uint256)[][],bytes32,address,uint256)": {
        "notice": "Attempt to fill a group of orders, fully or partially, with an         arbitrary number of items for offer and consideration per order         alongside criteria resolvers containing specific token         identifiers and associated proofs. Any order that is not         currently active, has already been fully filled, or has been         cancelled will be omitted. Remaining offer and consideration         items will then be aggregated where possible as indicated by the         supplied offer and consideration component arrays and aggregated         items will be transferred to the fulfiller or to each intended         recipient, respectively. Note that a failing item transfer or an         issue with order formatting will cause the entire batch to fail."
      },
      "fulfillAvailableOrders(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),bytes)[],(uint256,uint256)[][],(uint256,uint256)[][],bytes32,uint256)": {
        "notice": "Attempt to fill a group of orders, each with an arbitrary number         of items for offer and consideration. Any order that is not         currently active, has already been fully filled, or has been         cancelled will be omitted. Remaining offer and consideration         items will then be aggregated where possible as indicated by the         supplied offer and consideration component arrays and aggregated         items will be transferred to the fulfiller or to each intended         recipient, respectively. Note that a failing item transfer or an         issue with order formatting will cause the entire batch to fail.         Note that this function does not support criteria-based orders or         partial filling of orders (though filling the remainder of a         partially-filled order is supported)."
      },
      "fulfillBasicOrder((address,uint256,uint256,address,address,address,uint256,uint256,uint8,uint256,uint256,bytes32,uint256,bytes32,bytes32,uint256,(uint256,address)[],bytes))": {
        "notice": "Fulfill an order offering an ERC20, ERC721, or ERC1155 item by         supplying Ether (or other native tokens), ERC20 tokens, an ERC721         item, or an ERC1155 item as consideration. Six permutations are         supported: Native token to ERC721, Native token to ERC1155, ERC20         to ERC721, ERC20 to ERC1155, ERC721 to ERC20, and ERC1155 to         ERC20 (with native tokens supplied as msg.value). For an order to         be eligible for fulfillment via this method, it must contain a         single offer item (though that item may have a greater amount if         the item is not an ERC721). An arbitrary number of \"additional         recipients\" may also be supplied which will each receive native         tokens or ERC20 items from the fulfiller as consideration. Refer         to the documentation for a more comprehensive summary of how to         utilize this method and what orders are compatible with it."
      },
      "fulfillOrder(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),bytes),bytes32)": {
        "notice": "Fulfill an order with an arbitrary number of items for offer and         consideration. Note that this function does not support         criteria-based orders or partial filling of orders (though         filling the remainder of a partially-filled order is supported)."
      },
      "getCounter(address)": {
        "notice": "Retrieve the current counter for a given offerer."
      },
      "getOrderHash((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256))": {
        "notice": "Retrieve the order hash for a given order."
      },
      "getOrderStatus(bytes32)": {
        "notice": "Retrieve the status of a given order by hash, including whether         the order has been cancelled or validated and the fraction of the         order that has been filled."
      },
      "incrementCounter()": {
        "notice": "Cancel all orders from a given offerer with a given zone in bulk         by incrementing a counter. Note that only the offerer may         increment the counter."
      },
      "information()": {
        "notice": "Retrieve configuration information for this contract."
      },
      "matchAdvancedOrders(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),uint120,uint120,bytes,bytes)[],(uint256,uint8,uint256,uint256,bytes32[])[],((uint256,uint256)[],(uint256,uint256)[])[])": {
        "notice": "Match an arbitrary number of full or partial orders, each with an         arbitrary number of items for offer and consideration, supplying         criteria resolvers containing specific token identifiers and         associated proofs as well as fulfillments allocating offer         components to consideration components."
      },
      "matchOrders(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),bytes)[],((uint256,uint256)[],(uint256,uint256)[])[])": {
        "notice": "Match an arbitrary number of orders, each with an arbitrary         number of items for offer and consideration along with a set of         fulfillments allocating offer components to consideration         components. Note that this function does not support         criteria-based or partial filling of orders (though filling the         remainder of a partially-filled order is supported)."
      },
      "name()": {
        "notice": "Retrieve the name of this contract."
      },
      "validate(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),bytes)[])": {
        "notice": "Validate an arbitrary number of orders, thereby registering their         signatures as valid and allowing the fulfiller to skip signature         verification on fulfillment. Note that validated orders may still         be unfulfillable due to invalid item amounts or other factors;         callers should determine whether validated orders are fulfillable         by simulating the fulfillment call prior to execution. Also note         that anyone can validate a signed order, but only the offerer can         validate an order without supplying a signature."
      }
    },
    "notice": "Consideration is a generalized ETH/ERC20/ERC721/ERC1155 marketplace.         It minimizes external calls to the greatest extent possible and         provides lightweight methods for common routes as well as more         flexible methods for composing advanced orders or groups of orders.         Each order contains an arbitrary number of items that may be spent         (the \"offer\") along with an arbitrary number of items that must be         received back by the indicated recipients (the \"consideration\").",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 19847,
        "contract": "contracts/lib/Consideration.sol:Consideration",
        "label": "_reentrancyGuard",
        "offset": 0,
        "slot": "0",
        "type": "t_uint256"
      },
      {
        "astId": 16170,
        "contract": "contracts/lib/Consideration.sol:Consideration",
        "label": "_counters",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 19210,
        "contract": "contracts/lib/Consideration.sol:Consideration",
        "label": "_orderStatus",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_bytes32,t_struct(OrderStatus)16120_storage)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_bytes32,t_struct(OrderStatus)16120_storage)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => struct OrderStatus)",
        "numberOfBytes": "32",
        "value": "t_struct(OrderStatus)16120_storage"
      },
      "t_struct(OrderStatus)16120_storage": {
        "encoding": "inplace",
        "label": "struct OrderStatus",
        "members": [
          {
            "astId": 16113,
            "contract": "contracts/lib/Consideration.sol:Consideration",
            "label": "isValidated",
            "offset": 0,
            "slot": "0",
            "type": "t_bool"
          },
          {
            "astId": 16115,
            "contract": "contracts/lib/Consideration.sol:Consideration",
            "label": "isCancelled",
            "offset": 1,
            "slot": "0",
            "type": "t_bool"
          },
          {
            "astId": 16117,
            "contract": "contracts/lib/Consideration.sol:Consideration",
            "label": "numerator",
            "offset": 2,
            "slot": "0",
            "type": "t_uint120"
          },
          {
            "astId": 16119,
            "contract": "contracts/lib/Consideration.sol:Consideration",
            "label": "denominator",
            "offset": 17,
            "slot": "0",
            "type": "t_uint120"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_uint120": {
        "encoding": "inplace",
        "label": "uint120",
        "numberOfBytes": "15"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}